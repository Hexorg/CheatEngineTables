<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="21">
  <Files>
    <compact.lua Encoding="Ascii85">tyWEM/2DfO+?ylHAs0}yBiLC4y)_mFMzbkkZ-P3T90FrOStDDpObQg.ts8iMduK;W^?A#@@kA7B4mrb[H./G4^L?dBp35qF7H;O0,KT6%9_70GZfoGREKL*HYq6GgnHH7SCWsoo5sfvaTBMc!28M=TD$bWdrx3,P(26a[vxxz[F*9Ka3K6T#Is,4f%7gCmyskg[K-ZqvZ5Ix-tMl4cW*(Q$wu)^76t@6bLYqi*8/i@3xFy%UvWO{i+)InR2oOS+RU{pZwnJ5+Wu/KduXg5Da3HMNKu@8unZR?L(mB!xp:!c^=YTMrf][WNcMHTPuoGFTJ8jl1?xn)E-sZW1rWu!wZRIZl)y9Cth8t[O;S6%tqtOde9!fI@.uVTBtMHU=([t=?tg3BTANlnOthL!bm,(pfhh)D$$i0#4Af6tJKLoKN/5EF(69fwsjP+i0VVhH*@Eubt?S5Lqd76,X1[^O%A^SLD7U;uYdsVf6FJ+3+A$C4.UWAI)fucN!;R1$#.)uak!hloqHQ6f_q**m_Fu}o{c?XlvL=}e1amY5T!3mGaTuj1NV9Lc3C4Qe3VNQNzV$BMcxzn:/x7.L_$UgQ7PtgqtveuAx7mu6:LeV#)6L9s_t[PjFEULLXgO9^j:HYg/c(Ys2W!B.EoodLK#+hHF$syunpXFGa[)=Ao6%6%XaSPb5pI,m,0cjylQ/$}ll40f1#a/8+1^6B{:JRxY!_#D2L!.Y]*zk8C?EPI^YE,f.l}8:T*Zgw*WnD={,p1hBA+.[=.Y7]s,B715l]Fa$mn*3YEaoFw):CMNcN%xTP3@V/R4baHuJT#D,jXpPaQQWFSxkz4=_[_3!iDuwaM8w!q.0Zkz+uI#),a/s53O;U@HInzl90(*PY56$5FRNfQk36=Py2wP)_3.8bZT+^kd$Ug3N7?EH=Iv-sgK(PqITO2nhzpx#dLFbrb/UzA*z9f+e0EnDg@yQzt]%}c$7YuO@M[fYGidXAD,yoCv#ulC(GC+cZ8@qr%1KyuMP4Xs1221StS9v99qwU.BwH3E)g7HT336ms^sbn.U:CFk_L_4yD#H$M4T2*bPlmiTb#tB+z?w4P{TcLnNzRt_5u-Dqvu4+[;(80m{9]O^PB!=mxF%5Nq6=YXgW-cjuWvuo)[,v*8pw$qMdAhlJ];[^E(+#!^qUH@z=o/=qXjHqb1B(kc([iSPs1;mi!Q,cj(8N@xnS9Ozc1CEIDGX1,tYR(pv.Lw1{BM?T04C,,zdxe3omZo^2OSSR3.nsOXsB-X+5*TC#odB^xE,kGkH{1jF:q3,sm8]}R,m:%4PVHU_0pa=m{}p?lP0v-m2CL.r*]BY-vv5y_]fY7k*.gnQlbuWFXqGzYv6Fy)t10SMi9^MFP]9a*rTELIrc(ZaXL=huStv,)Xg3ln[+WR6dCiS3-?y)q(JucE]A)I:fEM2DcaCF0[)%{^p}rNG$HhHA1Mb{ta5VbtXrT5$8/6m@q1O2TNDs1(]T7J,pg-#$7[q8xMQ/m;$dLsdQ(4gmhqZ$W?,[jo$ppjV%);O.bJykwU.$JVdL$7#zRanriS:Th0%!Hi!#s3_zB=ot/ybwej6GKNgZJGUTNy6WQOSi+62f@TaZkAxR2MnwBX9RCsrbmD];:KQUV.QpFQ(}vDWLJ6K6,ga+wUD^c4ocOSYPC!ZnUpUIuZP84)4Q3Q,Vf(!43aNyP/{/3vDh?3T[mpE?Wk/x=O?tMR%DdLj0FbVZm]-$xA;0d8f.CrSGt{KihI9X+ct?j[(?kExXBg*@qMbY/,SspusdM5V=#Sf(W_!oF5]Cxbh%kO*E_=RR@B4SLTJT$8XG.BrTY?t$*HM.iZ?C9(R0cQw-Z*S:MrfOQ(J*XS$ObL?JpTg</compact.lua>
    <feedback.wav Encoding="Ascii85">i),D62:a7u3j*(Nj$y88xg]ol3:9lR42%p*VGInDwLu(f1[g#M%/K$6L6FpcAjxom!GYlekUqm]?V_pm.)uCVatRBN9_goIi6x0Zbqs6+3_N2-lfVb??^Ws2^Ey?R$zC^YbY4_R_A8OFosY6CUlxM22z,4V2T}vss_llEXaE2</feedback.wav>
    <sabotage.wav Encoding="Ascii85">by7QP6k!xS[nTSs+xk8zcN0)_+-2uw2/T:;QW;2U42Z8GMFQGPP_{Gbq(HYuj]^}S^))$N8yyj;GzlrhLgFY0ikkiM5Fw8lXMcdVxQBD@Db9V_Qo![.sj2A/XB#t?:kG1pbpQ(4!5QG$NSm0jv1fE3E4Eu^mJz^$(hQ:8)#Lc;ou9k2U{pS/0o/Kin9FoHCb+r,E,J?rP,qI]bg+[UjNnTe!1m)xR@3.tQMFNfy@PV{G,:n)NX$}$hguJZ7EQ$RzP^W0i^lPKCtzCCZJ;MtY*UDwm6{ZUzlnX-V#7gkNzubpuQ)#1Mx$Q];YS5AiF,SKEiQ#e/Wn]MqW0xz%QL8%z$?[?*Of[7,%o,?I=U+Xm/2B8q{0VQY@#e5HIfwmlrf?p=uNxrN@*[P._D.KXf(?s5BXGl(I32(t!:-IMTQH6[D-$YAG-zu:)@?t18O4Vbd1zTLXLGITWX)/^^neU;g/8Fa}kJccq:HxJ:**+l=vNU!0p%3o.Zgao8uQ}=GY(n5WA2=)N0]lca+*zoDCcRqnmhHuh]2,bOzi;Fq5;^Aym-Y,2wxgVN8AphHx?5a=U:571%%V@@^c(cBPT$s7LIBjcV[8oxJf3(RlyM5s4FW%ZF=t9+YN7g}v4xp)/FiK!UXW0^?MF</sabotage.wav>
    <anystuff.lua Encoding="Ascii85">rBq#O,b_UE*1Za@2jNj/ZHj36nAI6w[fgmegZ5z%)xBQ)tk#x-C5PpuzkOGdWxHMXRFYu%-h1xHxhJA.4i46;%B_E2ZS{UTxD^95uXU?6*J(.4Ba.aS[YUl_5b:0=gpgdLwN%9ozpKPoSqX=ITouoaX9U=(D2G6))mAgXd@7Y-+o(fQgfTy*u[+{wYuzB3O*0O}B^X4Cp?So0;jtpATFA,C89fek51[hXSK2.@^c}spmk$8$qZaq090.83q8rc8Pr;lHpV+rK=MaCsp@9,q4+t:dkB?p^8{Y@Dd/$gwDMK(9/iEJREO{!f=P8G/cJhAm=(IQi;6;y@GuxQ/F2xMfm?LhSV{695Il_MNPN^8L5!i.3wrv!]Cz!F@[2quPdgn1,qkWSu%THlTUAVP.,F#3!.t)oQ#cN?/JQp.txH0aP*.]i7O$=-YDe^NWh%N{G7(5.yE6nX89y29DL?/,ko1c#K*eTo]rB{JGx1hjPNSe9[dAg)+W]AXe5GER%,PzzL@ph.Z#x[!IFioV_?k$n][a,_Lzh:p8!q{jgXb)zAJ_q-AWJI#;(B?x$;.{1XhL?U.9Qy9Ol^^uxwe[87FoOS)w]JMs6A3x4J4p^**rH9d$qup-kR/SDy2RsB9l#Z^=q2Y/-gegW;Hn$$,!Gu8XbS__6noPQR6T5hv1EqMfwi72u+{iUpoGL@?m]5#^pE1j2]Z#PSr%to$R,cppsd3/x,?T:4xy]!u!CYo?Ngs@^Nf{DLi2gwHe,};yKV!+S!Xr3c^x)j)9odu:QX]MB;LxCnoQ7+Fm?z.t4r{GRU{;uUZ*J]g3;8I]HiV@;pCSK^{%</anystuff.lua>
  </Files>
  <CheatEntries>
    <CheatEntry>
      <ID>11151</ID>
      <Description>"INIT"</Description>
      <Options moHideChildren="1"/>
      <LastState Activated="1"/>
      <Color>28A028</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}
if GetCEVersion()&lt;6.5 then showMessage('need ce 6.5+');error('!ce ver')end
--if syntaxcheck then return end
function loadLuafromTableFileAndRun(n)
  local tf,err,loadsrc = findTableFile(n),tostring(n)..' not load from table file',_VERSION:match('5.3') and load or loadstring
  if tf==nil then tf = findTableFile(n..'.lua') end
  assert(tf~=nil, err)
  local st, ss = tf.Stream, createStringStream()
  ss.copyFrom(st,st.Size)
  local str = ss.DataString
  ss.Destroy()
  local ok, ret = pcall(loadsrc,str,'-')
  if not ok then error(err..', '..tostring(ret),2) end
  ok, ret = pcall(ret,n)
  if not ok then error(err..', '..tostring(ret),2) end
  return ret~=nil and ret or true
end
-- Test
function tohex(n)return string.format('%X',n or 0)end

if not _compactLoaded then
  pcall(loadLuafromTableFileAndRun,'anystuff.lua')
  pcall(populateHKSound,'sabotage.wav','feedback.wav')
  pcall(loadLuafromTableFileAndRun,'compact.lua')
  _compactLoaded = true

  -- change global print behaviours, for preventing 'format 2' from AA GetMonoStruct
  local ok2print,oprint = true,print
  function EnablePrint(b,s) ok2print = b ~= false  end

  print = function(...) if ok2print then return oprint(...) end end

  local function aa_EnablePrint(s,sc)
    if sc~=true then EnablePrint(s:lower():match('^%s*(.-)%s*$')~='false','aa_')end
  end
  registerAutoAssemblerCommand('enablePrint',aa_EnablePrint)

end

function checkMono(syntax,force)
  if syntax then return 0 end
  if not readInteger'mono_domain_get' or 0==LaunchMonoDataCollector() then error"Can't Launch Mono." end
  local ok,ret = autoAssemble"globalalloc(__,$4000,7ff00000)"
---[===[
  if ok then
    local addr = 'CheckIsPlayer'
    local test = readPointer(addr..'+1f0')
    if test==nil or test~=readPointer(test) or force then
      ok = autoAssemble[[
globalalloc(CheckIsPlayer,$200)

globalalloc(AddStats,$200)

aobscanRegion(inStamina,Necro:Actor:TryAttack+300,Necro:Actor:TryAttack+500,d9 e0 83 ec 04 83 ec 04 d9 1c 24 68)
aobscanRegion(inExhaust,Necro:Actor:TryAttack+400,Necro:Actor:TryAttack+500,D9 1c 24 68)// 01 02 03 04 05 06 07 08 09 0a
aobscanRegion(inHealth,Necro:Actor:OnSuccessfulAttack,Necro:Actor:OnSuccessfulAttack+50,83 ec 04 83 ec 04 d9 1c 24 68)

AddStats+100:
dq 3 // count
AddStats+108:
readmem(inStamina+0c,4)
AddStats+110:
readmem(inExhaust+04,4)
AddStats+118:
readmem(inHealth+0a,4)


AddStats+1f8:
dq "Necro:Actor:Add"

define(fnAddStats,AddStats+1f8)

label(doneAdd)
AddStats:
push esi
mov  esi,esp
push eax
push edi
mov  edi,AddStats
mov  eax,[esi+0c]
mov  [edi+0d0],eax
inc  dword ptr[edi+0b0]
test eax,eax
jle  doneAdd
cmp  eax,[edi+100]
jg   doneAdd
mov  eax,[edi+eax*8+100]

mov  [edi+0e0],eax

sub  esp,8
fstp dword ptr[esp]
push eax
push [esi+8]
call [fnAddStats]
add  esp,10

fstp dword ptr [edi+0f0]

doneAdd:
pop  edi
pop  eax
pop  esi
ret  08


CheckIsPlayer+1f0:
dq CheckIsPlayer+1f0

define(fnIsPlayer,CheckIsPlayer+1f8)
fnIsPlayer:
dq "Necro:Actor:get_IsPlayer"

CheckIsPlayer: // input: actor base in stack
push eax
mov  eax,esp
sub  esp,0c
push [eax+08]
call [fnIsPlayer]
add  esp,10
test eax,eax
pop  eax
ret 4
]]
    end
    -- recheck
    test = ok and readPointer(addr..'+1f0') or nil
    ok = not (test==nil or test~=readPointer(test))
  end
--]===]
  return ok
end

[ENABLE]
[DISABLE]
if syntaxcheck then return end
if monopipe~=nil then monopipe.Destroy() ; monopipe=nil end

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>11160</ID>
          <Description>"ApplyHitDamage v2"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,PlayerHitDamage)
define(hack,inHit)

[ENABLE]

aobscanRegion(inHit,Necro:Actor:ApplyHitDamage,Necro:Actor:ApplyHitDamage+100,0f b6 80 ?? ?? 00 00)


alloc(PlayerHitDamage,$1000,__)
registersymbol(PlayerHitDamage)

cave:
dd (float)2,(float)0.25

cave+40:
dd 1 // Enabled == true

define(Enabled,cave+40)

cave+100:
dq cave,hack

cave+180:
readmem(hack,32)

label(done)
cave+300:
reassemble(hack)  // eax -&gt; isALive?
test eax,eax
jne  @f
jmp  hack+07      //
@@:
push edx
push ecx
push ebx
push eax
push esi
push edi

mov  eax,[Enabled]
test eax,eax
je   done

  mov  eax,[ebp+10] // damageScale negative?
  test eax,eax
  jge  @f
  inc  edi
  @@:

  push [ebp+8]
  call CheckIsPlayer
  je   @f
  inc  edi
  @@:

  and  edi,1

  mov  eax,cave
  lea  eax,[eax+edi*4]// mul address for damage scale

  fld  dword ptr[ebp+10]
  fmul dword ptr[eax]
  fstp dword ptr[ebp+10]

done:
pop  edi
pop  esi
pop  eax
pop  ebx
pop  ecx
pop  edx
jmp  hack+07

hack:
jmp  cave+300
nop
nop


[DISABLE]

[cave+108]:
readmem(cave+180,32)


dealloc(PlayerHitDamage)
unregistersymbol(PlayerHitDamage)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11203</ID>
              <Description>"ON/off "</Description>
              <DropDownList ReadOnly="1" DescriptionOnly="1" DisplayValueAsItem="1">0:off
1:ON
</DropDownList>
              <LastState Value="1" RealAddress="7FF10040"/>
              <Color>000000</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>PlayerHitDamage+40</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11147</ID>
              <Description>"from Player mul"</Description>
              <LastState Value="2" RealAddress="7FF10000"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PlayerHitDamage</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11202</ID>
              <Description>"to Player mul"</Description>
              <LastState Value="0.25" RealAddress="7FF10004"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PlayerHitDamage+4</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11192</ID>
          <Description>"TryAttack"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck)
if check == 0 then return end

{$asm}

define(cave,PlayerTryAttack)
define(hack,inStamina)

[ENABLE]
//                                                                          00 01 02 03 04 05 06 07 08 09 0a 0b 0c
aobscanRegion(inStamina,Necro:Actor:TryAttack+300,Necro:Actor:TryAttack+500,d9 e0 83 ec 04 83 ec 04 d9 1c 24 68)// +5

alloc(PlayerTryAttack,$1000,__)
registersymbol(PlayerTryAttack)


cave:
dd (float)4,(float)10   //  &lt;============  SETUP HERE, +ve health / -ve exhaust per attack

cave+40:
dd 1 // Enabled == true

define(Enabled,cave+40)

cave+100:
dq cave,hack

cave+180:
readmem(hack,32)

label(done)
cave+300:
reassemble(hack)  // fchs

push edx
push ecx
push ebx
push eax
push esi
push edi

mov  eax,[Enabled]
test eax,eax
je   done

  mov  esi,[ebp+8]

  push esi
  call CheckIsPlayer
  je   done

  fld  dword ptr[cave] // restore health amount
  push 3    // index for health
  push esi
  call AddStats

  fld  dword ptr[cave+4]
  fchs      // decrease Exhaust
  push 2    // index for Exhaust
  push esi
  call AddStats

  fchs      // gain stamina instead of cost

done:
pop  edi
pop  esi
pop  eax
pop  ebx
pop  ecx
pop  edx

reassemble(hack+2)
jmp  hack+05

hack:
jmp  cave+300


[DISABLE]

[cave+108]:
readmem(cave+180,32)


dealloc(PlayerTryAttack)
unregistersymbol(PlayerTryAttack)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11194</ID>
              <Description>"ON/off (+gain attacking stamina cost)"</Description>
              <DropDownList ReadOnly="1" DescriptionOnly="1" DisplayValueAsItem="1">0:off
1:ON
</DropDownList>
              <LastState Value="1" RealAddress="7FEE0040"/>
              <Color>000000</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>PlayerTryAttack+40</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11193</ID>
              <Description>"restore Health amount"</Description>
              <LastState Value="4" RealAddress="7FEE0000"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PlayerTryAttack</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11195</ID>
              <Description>"restore Exhaust amount"</Description>
              <LastState Value="10" RealAddress="7FEE0004"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PlayerTryAttack+4</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11212</ID>
          <Description>"TryJump (jump in air/quick jump for bigger jump force)"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck)
if check == 0 then return end

{$asm}

define(cave,PlayerTryJump)
define(hack,inJump)

[ENABLE]
//                                                                 [00 01 02 03 04]05 06 07 08 09 0a 0b 0c
aobscanRegion(inJump,Necro:Actor:TryJump+50,Necro:Actor:TryJump+100,83 c4 10 85 c0 75 ?? 8b 46 ?? 83 ec 0c)// +5

alloc(PlayerTryJump,$1000,__)
registersymbol(PlayerTryJump)



cave+44:
readmem(hack+06,1)

cave+40:
dd 1 // Enabled == true

define(Enabled,cave+40)

cave+100:
dq cave,hack

cave+180:
readmem(hack,32)


cave+300:
reassemble(hack)  // fchs
push eax
mov  eax,[Enabled]
test eax,eax
pop  eax
je   @f
  movsx eax,byte ptr[cave+44]
  add   eax,hack+09
  mov   [cave+48],eax
  xor   eax,eax
  inc   eax
  jmp   [cave+48] // should enable jump by only removing onGround constraint

@@:
reassemble(hack+02)
jmp  hack+05

hack:
jmp  cave+300


[DISABLE]

[cave+108]:
readmem(cave+180,32)


dealloc(PlayerTryJump)
unregistersymbol(PlayerTryJump)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11213</ID>
              <Description>"ON/off"</Description>
              <DropDownList ReadOnly="1" DescriptionOnly="1" DisplayValueAsItem="1">0:off
1:ON
</DropDownList>
              <LastState Value="1" RealAddress="7FF20040"/>
              <Color>000000</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>PlayerTryJump+40</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11205</ID>
          <Description>"MovementInput (+sprint while charging)"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,MovementInput)
define(hack,inMove)

[ENABLE]
aobscanRegion(inMove,Necro:ThirdPersonCameraControl:UpdateMovementInput+500,Necro:ThirdPersonCameraControl:UpdateMovementInput+800,7a 03 0f 92 c0 85 c0 0f 84 ?? ?? 00 00 d9 85 ?? ?? ?? ?? dd 9d ?? ?? ?? ?? d9 05)

alloc(MovementInput,$1000,__)
registersymbol(MovementInput)



cave:
dd (float)1

cave+40:
dd 1 // Enabled == true

define(Enabled,cave+40)

cave+100:
dq cave,hack,hack+19



cave+180:
readmem(hack,32)
cave+1a0:
readmem(hack+19,32)

cave+300:
pushf
push eax
mov  eax,[cave+40]
test eax,eax
pop  eax
je   @f
popf
call cave+900
jmp  hack+05

@@:// no mod
popf
jp   hack+05
setb al
jmp  hack+05



cave+900:
xor  eax,eax
inc  eax
ret


cave+500:
mov  eax,[cave+40]
test eax,eax
jne  @f
reassemble(hack+19)
jmp  hack+1f

@@:

fld  dword ptr[cave]
reassemble(hack+13) // fstp [some local]
fld  dword ptr[cave]

jmp  hack+1f // 19+06 = 1f


hack:
jmp  cave+300

hack+19:
jmp  cave+500
nop



[DISABLE]

[cave+108]:
readmem(cave+180,32)
[cave+110]:
readmem(cave+1a0,32)


dealloc(MovementInput)
unregistersymbol(MovementInput)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11227</ID>
              <Description>"toggle ,  HOTKEY /"</Description>
              <LastState Activated="1"/>
              <Color>28A028</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
MovementInput+40:
dd 1
[DISABLE]
MovementInput+40:
dd 0

</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Toggle Activation</Action>
                  <Keys>
                    <Key>191</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>11207</ID>
              <Description>"speed factor, max=sprint = 1,normal =0.67"</Description>
              <LastState Value="1" RealAddress="7FED0000"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>MovementInput</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11165</ID>
          <Description>"SprintAddStamina"</Description>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

[ENABLE]
//                                                                             00 01 02 03 04 05 06 07
aobscanRegion(sprint,Necro:Actor:_UpdateStats+380,Necro:Actor:_UpdateStats+480,b8 ?? ?? ?? ?? d9 00 d9 e0 d9)

sprint+07:
db 90 90

[DISABLE]
aobscanRegion(sprint,Necro:Actor:_UpdateStats+380,Necro:Actor:_UpdateStats+480,b8 ?? ?? ?? ?? d9 00 90 90 d9)

sprint+07:
db d9 e0 // fchs

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>11200</ID>
          <Description>"DropLoot mul"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,DropLoot)
define(hack,inDrop)

[ENABLE]

aobscanRegion(inDrop,Necro:Actor:DropLoot,Necro:Actor:DropLoot+100,55 8b ec 57 83 ec)//+7

alloc(DropLoot,$1000,__)
registersymbol(DropLoot)



cave:
dd #2

cave+40:
dd 1 // Enabled == true

define(Enabled,cave+40)



cave+100:
dq cave,hack

cave+180:
readmem(hack,32)

label(nxt)
label(cont)
label(done)
cave+300:
pop  [cave+20]


mov  eax,[Enabled]
test eax,eax
je    @f
mov  eax,[cave]
mov  [cave+10],eax

@@:
cmp  dword ptr[cave+10],1
jle  done
dec  dword ptr[cave+10]
call nxt
jmp  @b

done:
push cont
nxt:
reassemble(hack)
reassemble(hack+1)
reassemble(hack+3)
reassemble(hack+4)
jmp  hack+07
cont:
push [cave+20]
ret

hack:
jmp  cave+300
nop
nop


[DISABLE]

[cave+108]:
readmem(cave+180,32)


dealloc(DropLoot)
unregistersymbol(DropLoot)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11204</ID>
              <Description>"ON/off"</Description>
              <DropDownList ReadOnly="1" DescriptionOnly="1" DisplayValueAsItem="1">0:off
1:ON
</DropDownList>
              <LastState Value="1" RealAddress="7FF30040"/>
              <Color>000000</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>DropLoot+40</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11201</ID>
              <Description>"mul/loop count"</Description>
              <LastState Value="2" RealAddress="7FF30000"/>
              <Color>000000</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>DropLoot</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11214</ID>
          <Description>"Pickup Stackable mul"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,PickupStackable)
define(hack,inKey)
define(hac2,inAmmo)
define(hac3,inIngr)
define(hac4,inGold)

[ENABLE]
// AddKey AddIngredient AddCurrency AddAmmo

aobscanRegion(inKey,Necro:Inventory:AddKey,Necro:Inventory:AddKey+50,c7 45 ?? 00 00 00 00 83 7d 10 00)//+7
aobscanRegion(inAmmo,Necro:Inventory:AddAmmo,Necro:Inventory:AddAmmo+50,c7 45 ?? 00 00 00 00 83 7d 10 00)
aobscanRegion(inIngr,Necro:Inventory:AddCurrency,Necro:Inventory:AddCurrency+50,c7 45 ?? 00 00 00 00 83 7d 10 00)
aobscanRegion(inGold,Necro:Inventory:AddIngredient,Necro:Inventory:AddIngredient+50,c7 45 ?? 00 00 00 00 83 7d 10 00)

alloc(PickupStackable,$1000,__)
registersymbol(PickupStackable)

cave:
dd (float)2,(float)5,(float)10,(float)10

cave+100:
dq cave,hack,hac2,hac3,hac4

cave+180:
readmem(hack,32)
cave+1a0:
readmem(hac2,32)
cave+1c0:
readmem(hac3,32)
cave+1e0:
readmem(hac4,32)

cave+300:
reassemble(hack)
  fild  dword ptr[ebp+10]
  fmul  dword ptr[cave]
  fistp dword ptr[ebp+10]
jmp hack+07
cave+500:
reassemble(hac2)
  fild  dword ptr[ebp+10]
  fmul  dword ptr[cave+04]
  fistp dword ptr[ebp+10]
jmp hac2+07
cave+700:
reassemble(hac3)
  fild  dword ptr[ebp+10]
  fmul  dword ptr[cave+08]
  fistp dword ptr[ebp+10]
jmp hac3+07
cave+900:
reassemble(hac4)
  fild  dword ptr[ebp+10]
  fmul  dword ptr[cave+0c]
  fistp dword ptr[ebp+10]
jmp hac4+07


hack:
jmp  cave+300
nop
nop
hac2:
jmp  cave+500
nop
nop
hac3:
jmp  cave+700
nop
nop
hac4:
jmp  cave+900
nop
nop


[DISABLE]

[cave+108]:
readmem(cave+180,32)
[cave+110]:
readmem(cave+1a0,32)
[cave+118]:
readmem(cave+1c0,32)
[cave+120]:
readmem(cave+1e0,32)


dealloc(PickupStackable)
unregistersymbol(PickupStackable)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11217</ID>
              <Description>"Key"</Description>
              <LastState Value="2" RealAddress="7FEC0000"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PickupStackable</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11226</ID>
              <Description>"Ammo"</Description>
              <LastState Value="5" RealAddress="7FEC0004"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PickupStackable+04</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11225</ID>
              <Description>"Ingredient"</Description>
              <LastState Value="10" RealAddress="7FEC0008"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PickupStackable+08</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11224</ID>
              <Description>"Currency"</Description>
              <LastState Value="10" RealAddress="7FEC000C"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>PickupStackable+0c</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11228</ID>
          <Description>"RemoveCurrency Mul (Gem/Token)"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,RemoveCurrencyMul)
define(hack,inRC)

[ENABLE]

aobscanRegion(inRC,Necro:Inventory:RemoveCurrency,Necro:Inventory:RemoveCurrency+50,8b ?? 08 8b ?? 0c)

alloc(RemoveCurrencyMul,$1000,__)
registersymbol(RemoveCurrencyMul)

cave:
dd (float)0.2

cave+100:
dq cave,hack

cave+180:
readmem(hack,32)

cave+300:
reassemble(hack)
reassemble(hack+3)
  fild  dword ptr[ebp+10]
  fmul  dword ptr[cave]
  fistp dword ptr[ebp+10]
  cmp  dword ptr[ebp+10],1
  jge  @f
  mov  dword ptr[ebp+10],1
  @@:
jmp hack+06


hack:
jmp  cave+300
nop

[DISABLE]

[cave+108]:
readmem(cave+180,32)


dealloc(RemoveCurrencyMul)
unregistersymbol(RemoveCurrencyMul)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11229</ID>
              <Description>"mul"</Description>
              <LastState Value="0.200000003" RealAddress="7FF40000"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>RemoveCurrencyMul</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11230</ID>
          <Description>"Anim Speed Mul OnChange"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,SpeedMul)
define(hack,inChg)
define(hac2,inRef)

[ENABLE]
aobscanRegion(inChg,Necro:Actor:SpeedStatValueChange,Necro:Actor:SpeedStatValueChange+50,83 c4 10 b8 ?? ?? ?? ?? d9 00)
aobscanRegion(inRef,Necro:Actor:RefreshSpeed,Necro:Actor:RefreshSpeed+50,83 c4 10 b8 ?? ?? ?? ?? d9 00)

alloc(SpeedMul,$1000,__)
registersymbol(SpeedMul)


cave:
dd (float)1.67,(float)4

cave+40:
dd 1 // Enabled == true

define(Enabled,cave+40)

cave+100:
dq cave,hack,hac2



cave+180:
readmem(hack,32)
cave+1a0:
readmem(hac2,32)

cave+300:
reassemble(hack)
reassemble(hack+03)
reassemble(hack+08)

cmp  dword ptr [Enabled],0
je   @f
  call cave+900
@@:
jmp  hack+0a

cave+500:
reassemble(hac2)
reassemble(hac2+03)
reassemble(hac2+08)

cmp  dword ptr [Enabled],0
je   @f
  call cave+900
@@:
jmp  hac2+0a


cave+900:
push esi
  mov  esi,cave

  push [ebp+08]
  call CheckIsPlayer
  jne  @f
  add  esi,4
@@:
  fstp dword ptr[esp+08]
  fmul dword ptr[esi]
  fld  dword ptr[esp+08]
  fmul dword ptr[esi]
pop  esi
ret


hack:
jmp  cave+300
nop
nop
nop
nop
nop

hac2:
jmp  cave+500
nop
nop
nop
nop
nop



[DISABLE]

[cave+108]:
readmem(cave+180,32)
[cave+110]:
readmem(cave+1a0,32)


dealloc(SpeedMul)
unregistersymbol(SpeedMul)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11233</ID>
              <Description>"ON/off"</Description>
              <DropDownList ReadOnly="1" DescriptionOnly="1" DisplayValueAsItem="1">0:off
1:ON
</DropDownList>
              <LastState Value="1" RealAddress="7FEB0040"/>
              <Color>000000</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>SpeedMul+40</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11232</ID>
              <Description>"for player"</Description>
              <LastState Value="1.899999976" RealAddress="7FEB0000"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>SpeedMul</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>11234</ID>
              <Description>"for others (seems not work, check note)"</Description>
              <LastState Value="4" RealAddress="7FEB0004"/>
              <Color>000000</Color>
              <VariableType>Float</VariableType>
              <Address>SpeedMul+04</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>11236</ID>
          <Description>"ItemSlot 5xEq, 15xItm  &lt;keep Enabled&gt;"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <Color>28A028</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
local check = checkMono(syntaxcheck,true)
if check == 0 then return end

{$asm}

define(cave,ItemSlot)
define(hack,inSlot)

[ENABLE]

aobscanRegion(inSlot,Necro:Inventory:GetMaxItemsFromSlot,Necro:Inventory:GetMaxItemsFromSlot+50,55 8b ?? 83)

globalalloc(ItemSlot,$1000,__)
//registersymbol(ItemSlot)

cave:
dd (float)0.2

cave+40:
dd 1

cave+100:
dq cave,hack

cave+180:
readmem(hack,32)

cave+300:
pop  dword ptr[cave+60]
push @f
reassemble(hack)
reassemble(hack+1)
reassemble(hack+3)
jmp hack+06
@@:
push dword ptr[cave+60]
cmp  eax,0a
jne  @f
mov  eax,0f
ret
@@:
cmp  eax,02
jne  @f
mov  eax,05
@@:
ret

hack:
jmp  cave+300
nop

[DISABLE]

[cave+108]:
readmem(cave+180,32)


//dealloc(ItemSlot)
//unregistersymbol(ItemSlot)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>11235</ID>
              <Description>"note: Enable before enter level, and  keep Enabled"</Description>
              <LastState/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>11237</ID>
              <Description>"====: between Save &amp; Load to keep saved Itms."</Description>
              <LastState/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
[DISABLE]

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>11161</ID>
      <Description>"IGNORE"</Description>
      <Options moHideChildren="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>__</Name>
      <Address>7FF00000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>CheckIsPlayer</Name>
      <Address>7FF04000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>AddStats</Name>
      <Address>7FF04200</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>ItemSlot</Name>
      <Address>7FF04400</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
</CheatTable>
