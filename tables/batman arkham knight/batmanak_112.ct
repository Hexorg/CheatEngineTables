<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="24">
  <CheatEntries>
    <CheatEntry>
      <ID>187</ID>
      <Description>"[Enable]"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <Color>000080</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

alloc( pHook, 256, BatmanAK.exe )
label( GObjects )
registersymbol( GObjects )
label( MaxGObjects )
registersymbol( MaxGObjects )
label( GNames )
registersymbol( GNames )
label( pLocalPlayer )
registersymbol( pLocalPlayer )
label( pRPlayerControllerCombat )
registersymbol( pRPlayerControllerCombat )
label( back )

BatmanAK.exe+3484E24:
GObjects:

BatmanAK.exe+3A82168:
MaxGObjects:

BatmanAK.exe+3A98AF8:
GNames:

pHook:
mov rax,[rax]
mov [pLocalPlayer],rax
mov rcx,[rax+5C]
mov [pRPlayerControllerCombat],rcx
jmp back

pLocalPlayer:
dq 0
pRPlayerControllerCombat:
dq 0

BatmanAK.exe+48CD4D2:
jmp pHook
db 90 90
back:

[DISABLE]

BatmanAK.exe+48CD4D2:
db 48 8B 00 48 8B 48 5C

unregistersymbol( pRPlayerControllerCombat )
unregistersymbol( pLocalPlayer )
unregistersymbol( GNames )
unregistersymbol( MaxGObjects )
unregistersymbol( GObjects )

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>194</ID>
          <Description>"Set Hook &amp; Emulate RCheatManager UObject"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

alloc( pCave, 1024, BatmanAK.exe )
alloc( pObject, 64, BatmanAK.exe )
registersymbol( pObject )
label( back )

label( pRPlayerControllerCombat_a )
registersymbol( pRPlayerControllerCombat_a )
label( szRCheatManager )
label( szDefault_RCheatManager )
label( szNull_0 )
label( szInvalid_0 )
label( szSpace_0 )
label( szDot_0 )
label( szFunctionName_0 )

label( pCave_loop )
label( pCave_next )
label( pCave_continue )
label( pCave_exit )
label( pCave_out )
label( pCave_check )

label( GetName_0 )
label( GetName_0_invalid )

label( GetFullName_0 )
label( GetFullName_0_null )
label( GetFullName_0_continue )
label( GetFullName_0_exit )

pCave+500:
pRPlayerControllerCombat_a:
dq 0
db 0,0
szRCheatManager:
db 'Class BmGame.RCheatManager',0
pCave+5C0:
szDefault_RCheatManager:
db 'RCheatManager BmGame.Default__RCheatManager',0
szNull_0:
db '(null)',0,0
szInvalid_0:
db 'INVALID NAME INDEX',0,0
szSpace_0:
db 20,0,0
szDot_0:
db 2E,0,0
szFunctionName_0:
dd 0

pObject+8:
db 60 80 08 00 20 00 00 00

pCave:
mov rax,[rcx]							 // original code
mov rax,[rax+5C]						 // original code
test rax,rax
je pCave_exit
cmp [pRPlayerControllerCombat_a],rax
je pCave_check
  mov [pObject+34],rax
  mov [pRPlayerControllerCombat_a],rax
  // hook_start
  push rbx
  push rcx
  push rdx
  push rsi
  push rdi
  sub rsp,20
  mov rax,GObjects
  xor edi,edi
  cmp [MaxGObjects],edi
  jna pCave_out
    xor ebx,ebx
    pCave_loop:
    mov rcx,rax
    cmp qword ptr [rbx+rcx],0
    je pCave_continue
      mov rcx,[rbx+rcx]
      call GetFullName_0
      lea rdx,[szRCheatManager]          // "Class BmGame.RCheatManager"
      mov rcx,rax
      call msvcrt.strcmp
      test eax,eax
      jne short @f
        mov rax,GObjects
        mov rax,[rax+rbx]
        mov [pObject+44],rax
        jmp pCave_next
	  @@:
      mov rax,GObjects
      mov rcx,rax
      mov rcx,[rbx+rcx]
      call GetFullName_0
      lea rdx,[szDefault_RCheatManager]  // "RCheatManager BmGame.Default__RCheatManager"
      mov rcx,rax
      lea rcx,[szFunctionName_0]
      call msvcrt.strcmp
	  jne short @f
        mov rax,GObjects
        mov rax,[rax+rbx]
        mov rax,[rax]
	    mov [pObject],rax
	  pCave_next:
      mov rax,GObjects
    pCave_continue:
    inc edi
    add rbx,8
    cmp edi,[MaxGObjects]
    jb pCave_loop
  mov rax,[pRPlayerControllerCombat_a]
  mov r8,pObject
  mov [rax+4D0],r8
  pCave_out:
  add rsp,20
  pop rdi
  pop rsi
  pop rdx
  pop rcx
  pop rbx
// hook end
pCave_exit:
jmp back

pCave_check:
cmp [rax+4D0],0
jne short @f
  mov r8,pObject
  mov [rax+4D0],r8
@@:
jmp pCave_exit

db CC CC CC CC

// *************
// ** GetName **
// *************

GetName_0:
mov rax,GNames
mov r8d,[rcx+3C]                    // FName_Index
mov r9d,[rax+8]
cmp r8d,r9d
ja short GetName_0_invalid
  mov rax,[rax]
  mov rax,[rax+r8*8]
  mov edx,[rax]
  test dl,1
  je short @f
    lea rax,[rax+C]                 // if UNICODE
    ret
  @@:
  test dl,2
  je short @f
    mov rax,[rax+C]
    ret
  @@:
  lea rax,[rax+C]
  ret
GetName_0_invalid:
lea rax,[szInvalid_0]               // "INVALID NAME INDEX"
ret

db CC CC CC CC

//*********************************
//********   GetFullName   ********
//*********************************

GetFullName_0:
mov [rsp+8],rbx
push rdi
sub rsp,20
mov rbx,rcx
mov rcx,[rcx+44]
test rcx,rcx
je GetFullName_0_null
  mov rax,[rbx+34]
  test rax,rax
  je GetFullName_0_null
    cmp qword ptr [rax+34],0
    je short @f
      call GetName_0
      lea rdi,[szFunctionName_0]
      mov rdx,rax
      mov rcx,rdi
      call msvcrt.strcpy
      lea rdx,[szSpace_0]           // " "
      mov rcx,rdi
      call msvcrt.strcat
      mov rcx,[rbx+34]
      mov rcx,[rcx+34]
      call GetName_0
      mov rcx,rdi
      mov rdx,rax
      call msvcrt.strcat
      lea rdx,[szDot_0]             // "."
      jmp GetFullName_0_continue
    @@:
    call GetName_0
    lea rdi,[szFunctionName_0]
    mov rdx,rax
    mov rcx,rdi
    call msvcrt.strcpy
    lea rdx,[szSpace_0]             // " "
	GetFullName_0_continue:
    mov rcx,rdi
    call msvcrt.strcat
    mov rcx,[rbx+34]
    call GetName_0
    mov rcx,rdi
    mov rdx,rax
    call msvcrt.strcat
    lea rdx,[szDot_0]               // "."
    mov rcx,rdi
    call msvcrt.strcat
    mov rcx,rbx
    call GetName_0
    mov rcx,rdi
    mov rdx,rax
    call msvcrt.strcat
    mov rax,rdi
    jmp short GetFullName_0_exit
GetFullName_0_null:
lea rax,[szNull_0]                  // "(null)"
GetFullName_0_exit:
mov rbx,[rsp+30]
add rsp,20
pop rdi
ret

db CC CC CC CC

// BatmanAK.exe+48CBC7E - 48 8B 01              - mov rax,[rcx]
// BatmanAK.exe+48CBC81 - 48 8B 40 5C           - mov rax,[rax+5C]

BatmanAK.exe+48CBC7E:
jmp pCave
db 90 90
back:

[DISABLE]

[pRPlayerControllerCombat_a]+4D0:
dq 0

BatmanAK.exe+48CBC7E:
db 48 8B 01 48 8B 40 5C

unregistersymbol( pRPlayerControllerCombat_a )
unregistersymbol( pObject )
dealloc( pObject )
dealloc( pCave )
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>189</ID>
          <Description>"GNames &amp; GObjects Dumper"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <Color>000000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

alloc( DumpHandlerThread, 1024, BatmanAK.exe )
registersymbol( DumpHandlerThread )
label( DumpHandlerThread_loop )
CreateThread( DumpHandlerThread )
alloc( DumpHandlerOff, 4, BatmanAK.exe )
registersymbol( DumpHandlerOff )
label( ExitDumpHandler )

label( szWrite )
label( szNamesFile )
label( szObjectsFile )
label( szNamesFormat )
label( szNamesFormatW )
label( szObjectsFormat )
//label( szObjectsFormatW )
label( szInvalid )
label( szNull )
label( szSpace )
label( szDot )
label( szFunctionName )

label( DumpNames )
label( DumpNames_a )
label( DumpNames_b )
label( DumpNames_loop )
label( DumpNames_exit )

label( DumpObjects )
label( DumpObjects_loop )
label( DumpNames_continue )
label( DumpObjects_exit )

label( GetName )
label( GetName_invalid )

label( GetFullName )
label( GetFullName_null )
label( GetFullName_continue )
label( GetFullName_exit )

DumpHandlerOff:
dd 0

DumpHandlerThread+500:
szWrite:
db 'w+',0
szNamesFile:
db 'NamesDump.txt',0
szObjectsFile:
db 'ObjectsDump.txt',0
szNamesFormat:
db 'Name[%06i] %s',0A,0
szNamesFormatW:
db 'Name[%06i] %S',0A,0,0
szObjectsFormat:
db 'UObject[%06i] %-50s 0x%llX ( %-50s )',0A,0
//szObjectsFormatW:
//db 'UObject[%06i] %-50S 0x%llX ( %-50S )',0A,0,0
szInvalid:
db 'INVALID NAME INDEX',0
szNull:
db '(null)',0
szSpace:
db 20,0,0
szDot:
db 2E,0,0
szFunctionName:
dd 0

DumpHandlerThread:
sub rsp,28
DumpHandlerThread_loop:
mov rcx,A
call Sleep
cmp [DumpHandlerOff],1
je ExitDumpHandler
  mov rcx,6F //VK_NUMPAD /
  call GetAsyncKeyState
  test ax,ax
  jne @f
    jmp DumpHandlerThread_loop
  @@:
  call DumpNames
  call DumpObjects
  mov rcx,C8
  call Sleep
  jmp DumpHandlerThread_loop

// ***************
// ** DumpNames **
// ***************

DumpNames:
mov [rsp+10],rbx
push rdi
sub rsp,20
and qword ptr [rsp+30],0
lea r8,[szWrite]                    // "w+"
lea rdx,[szNamesFile]               // "NameDump.txt"
lea rcx,[rsp+30]
call msvcrt.fopen_s
mov rax,GNames
xor edi,edi
cmp [rax+8],edi
jna DumpNames_exit
  xor ebx,ebx
  DumpNames_loop:
  mov r9,[rax]
  cmp qword ptr [r9+rbx],0
  je short DumpNames_continue
    mov r9,[r9+rbx]
    mov edx,[r9]
	test dl,1
	je short @f
		lea r9,[r9+C]
		lea rdx,[szNamesFormatW]    // "Name[%06i] %S"
		jmp short DumpNames_b
	@@:
	test dl,2
	je short @f
		mov r9,[r9+C]
		jmp short DumpNames_a
	@@:
	lea r9,[r9+C]
	DumpNames_a:
    lea rdx,[szNamesFormat]         // "Name[%06i] %s"
	DumpNames_b:
	mov rcx,[rsp+30]
    mov r8d,edi
    call msvcrt.fprintf
    mov rax,GNames
  DumpNames_continue:
  inc edi
  add rbx,8
  cmp edi,[rax+8]
  jb DumpNames_loop
DumpNames_exit:
mov rcx,[rsp+30]
call msvcrt.fclose
mov rbx,[rsp+38]
add rsp,20
pop rdi
ret

db CC CC CC CC

// *****************
// ** DumpObjects **
// *****************

DumpObjects:
mov rax,rsp
mov [rax+10],rbx
mov [rax+18],rsi
push rdi
sub rsp,30
and qword ptr [rax+08],0
lea r8,[szWrite]                    // "w+"
lea rdx,[szObjectsFile]             // "ObjectDump.txt"
lea rcx,[rax+8]
call msvcrt.fopen_s
mov rax,GObjects
xor esi,esi
cmp [MaxGObjects],esi
jna DumpObjects_exit
  xor edi,edi
  DumpObjects_loop:
  mov rcx,rax
  cmp qword ptr [rcx+rdi],0
  je short @f
    mov rbx,[rdi+rcx]
    mov rcx,[rcx+rdi]
    call GetFullName
    mov rcx,rbx
    mov r11,rax
    call GetName
    mov rcx,[rsp+40]
    mov [rsp+28],r11
    lea rdx,[szObjectsFormat]       // "UObject[%06i] %-50s 0x%08X ( %-50s )"
    mov r8d,esi
    mov r9,rax
    mov [rsp+20],rbx
    call msvcrt.fprintf
    mov rax,GObjects
  @@:
  inc esi
  add rdi,8
  cmp esi,[MaxGObjects]
  jb DumpObjects_loop
DumpObjects_exit:
mov rcx,[rsp+40]
call msvcrt.fclose
mov rbx,[rsp+48]
mov rsi,[rsp+50]
add rsp,30
pop rdi
ret

db CC CC CC CC

// *************
// ** GetName **
// *************

GetName:
mov rax,GNames
mov r8d,[rcx+3C]                    // FName_Index
mov r9d,[rax+8]
cmp r8d,r9d
ja short GetName_invalid
  mov rax,[rax]
  mov rax,[rax+r8*8]
  mov edx,[rax]
  test dl,1
  je short @f
    lea rax,[rax+C]                 // if UNICODE
    ret
  @@:
  test dl,2
  je short @f
    mov rax,[rax+C]
    ret
  @@:
  lea rax,[rax+C]
  ret
GetName_invalid:
lea rax,[szInvalid]                 // "INVALID NAME INDEX"
ret

db CC CC CC CC

//*********************************
//********   GetFullName   ********
//*********************************

GetFullName:
mov [rsp+8],rbx
push rdi
sub rsp,20
mov rbx,rcx
mov rcx,[rcx+44]
test rcx,rcx
je GetFullName_null
  mov rax,[rbx+34]
  test rax,rax
  je GetFullName_null
    cmp qword ptr [rax+34],0
    je short @f
      call GetName
      lea rdi,[szFunctionName]
      mov rdx,rax
      mov rcx,rdi
      call msvcrt.strcpy
      lea rdx,[szSpace]             // " "
      mov rcx,rdi
      call msvcrt.strcat
      mov rcx,[rbx+34]
      mov rcx,[rcx+34]
      call GetName
      mov rcx,rdi
      mov rdx,rax
      call msvcrt.strcat
      lea rdx,[szDot]               // "."
      jmp short GetFullName_continue
    @@:
    call GetName
    lea rdi,[szFunctionName]
    mov rdx,rax
    mov rcx,rdi
    call msvcrt.strcpy
    lea rdx,[szSpace]               // " "
	GetFullName_continue:
    mov rcx,rdi
    call msvcrt.strcat
    mov rcx,[rbx+34]
    call GetName
    mov rcx,rdi
    mov rdx,rax
    call msvcrt.strcat
    lea rdx,[szDot]                 // "."
    mov rcx,rdi
    call msvcrt.strcat
    mov rcx,rbx
    call GetName
    mov rcx,rdi
    mov rdx,rax
    call msvcrt.strcat
    mov rax,rdi
    jmp short GetFullName_exit
GetFullName_null:
lea rax,[szNull]                    // "(null)"
GetFullName_exit:
mov rbx,[rsp+30]
add rsp,20
pop rdi
ret

db CC CC CC CC

ExitDumpHandler:
add rsp,28
mov [DumpHandlerOff],2
ret

[DISABLE]

{$lua}

if( syntaxcheck == false ) then --actual execution
  local starttime = getTickCount()

if readInteger( "DumpHandlerOff" ) == 0 then --could be 2 already
  writeInteger( "DumpHandlerOff", 1 ) --tell the thread to kill itself
end

while( getTickCount() &lt; starttime + 1000 ) and ( readInteger( "DumpHandlerOff" ) ~= 2 ) do --wait till it has finished
  sleep( 20 )
end

if( getTickCount() &gt; starttime + 1000 ) then --could happen when the window is shown
  showMessage( 'Disabling the thread failed!' )
  error( 'Thread disabling failed!' )
end
  sleep( 1 )
end

{$asm}

unregistersymbol( DumpHandlerOff )
dealloc( DumpHandlerOff )
unregistersymbol( DumpHandlerThread )
dealloc( DumpHandlerThread )
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>201</ID>
      <Description>"Disable Incremental Timer"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

alloc( DisableIncrementalTimer, 256, BatmanAK.exe )
label( back )

DisableIncrementalTimer:
push rcx
lea rcx,[rcx+1C4]
cmp rcx,rdi
pop rcx
jne short @f
movss [rdi],xmm15
jmp back+4
@@:
movss [rdi],xmm7
jmp back+4

// BatmanAK.exe+5345DF0 - F3 0F11 3F            - movss [rdi],xmm7
// BatmanAK.exe+5345DF4 - EB 04                 - jmp BatmanAK.exe+5345DFA
// BatmanAK.exe+5345DF6 - F3 0F11 37            - movss [rdi],xmm6
// BatmanAK.exe+5345DFA - 48 8B 5C 24 50        - mov rbx,[rsp+50]

BatmanAK.exe+5345DF0:
jmp DisableIncrementalTimer
db 90
back:

[DISABLE]

BatmanAK.exe+5345DF0:
db F3 0F 11 3F EB 04

dealloc( DisableIncrementalTimer )
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>205</ID>
      <Description>"Disable Decremental Timer"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

alloc( DisableDecrementalTimer, 256, BatmanAK.exe )
label( back )

DisableDecrementalTimer:
push rcx
lea rcx,[rcx+1C4]
cmp rcx,rdi
pop rcx
je short @f
movss [rdi],xmm7
@@:
jmp back+4

// BatmanAK.exe+5345FEB - F3 0F11 3F            - movss [rdi],xmm7
// BatmanAK.exe+5345FEF - EB 04                 - jmp BatmanAK.exe+5345FF5
// BatmanAK.exe+5345FF1 - F3 0F11 37            - movss [rdi],xmm6
// BatmanAK.exe+5345FF5 - 48 8B 5C 24 50        - mov rbx,[rsp+50]

BatmanAK.exe+5345FEB:
jmp DisableDecrementalTimer
db 90
back:

[DISABLE]

BatmanAK.exe+5345FEB:
db F3 0F 11 3F EB 04

dealloc( DisableDecrementalTimer )
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>207</ID>
      <Description>"Increase Combat Power"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

alloc( IncreaseCombatPower, 128, BatmanAK.exe )
label( back )

IncreaseCombatPower:
or [r13+BFC],800
or [r13+00000BFC],00080000
jmp back

BatmanAK.exe+46C6568:
jmp IncreaseCombatPower
db 90 90 90 90 90 90
back:

//BatmanAK.exe+46C6568 - 41 81 8D FC0B0000 00000800 - or [r13+00000BFC],00080000
//BatmanAK.exe+46C6573 - 0F28 74 24 20         - movaps xmm6,[rsp+20]

[DISABLE]

BatmanAK.exe+46C6568:
or [r13+00000BFC],00080000

dealloc( IncreaseCombatPower )
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>190</ID>
      <Description>"[Debug]"</Description>
      <Options moHideChildren="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <Color>C0C0C0</Color>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>193</ID>
          <Description>"[Scripts]"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>159</ID>
              <Description>"GNames &amp; GObjects Dumper (ASCII)"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

alloc( DumpHandlerThread, 1024, BatmanAK.exe )
registersymbol( DumpHandlerThread )
label( DumpHandlerThread_loop )
CreateThread( DumpHandlerThread )
alloc( DumpHandlerOff, 4, BatmanAK.exe )
registersymbol( DumpHandlerOff )
label( ExitDumpHandler )

label( szWrite )
label( szNamesFile )
label( szObjectsFile )
label( szNamesFormat )
label( szObjectsFormat )
label( szInvalid )
label( szNull )
label( szFormat )
label( szSeparator )
label( szBuffer )
label( szFunctionName )
label( szOutputDebug )

label( DumpNames )
label( DumpNames_loop )
label( DumpNames_exit )

label( DumpObjects )
label( DumpObjects_loop )
label( DumpObjects_exit )

label( GetName )

/*

label( GetObject )

label( FindObject )
label( FindObject_0 )
label( FindObject_1 )
label( FindObject_exit )

label( GetFullName )
label( GetFullName_0 )
label( GetFullName_NULL )

label( OutputDebug )

*/

DumpHandlerOff:
dd 0

DumpHandlerThread+500:
szWrite:
db 'w+',0
szNamesFile:
db 'NamesDump.txt',0
szObjectsFile:
db 'ObjectsDump.txt',0
szNamesFormat:
db 'Name[%06i] %s',0A,0
//szObjectsFormat:
//db 'UObject[%06i] %-50s 0x%llX ( %-50s )',0A,0
szObjectsFormat:
db 'UObject[%06i] %-50s 0x%llX',0A,0
szInvalid:
db 'INVALID NAME INDEX',0
szNull:
db '(null)',0
szFormat:
db '0x%08X',0
szSeparator:
db ' | ',0
szBuffer:
dd 0
dd 0
dd 0
szFunctionName:
dd 0

DumpHandlerThread+600:
szOutputDebug:
dd 0

DumpHandlerThread:
sub rsp,28
DumpHandlerThread_loop:
mov rcx,A
call Sleep
cmp [DumpHandlerOff],1
je ExitDumpHandler
  mov rcx,6F //VK_NUMPAD /
  call GetAsyncKeyState
  test ax,ax
  jne @f
    jmp DumpHandlerThread_loop
  @@:
  //call DumpNames
  call DumpObjects
  mov rcx,C8
  call Sleep
  jmp DumpHandlerThread_loop

// ***************
// ** DumpNames **
// ***************

DumpNames:
mov [rsp+10],rbx
push rdi
sub rsp,20
and qword ptr [rsp+30],0
lea r8,[szWrite]    //w+
lea rdx,[szNamesFile]     // "NameDump.txt"
lea rcx,[rsp+30]
call msvcr100.fopen_s
mov rax,GNames
xor edi,edi
cmp [rax+8],edi
jbe DumpNames_exit
  xor ebx,ebx
DumpNames_loop:
  mov r9,[rax]
  cmp qword ptr [r9+rbx],0
  je short @f
    mov r9,[r9+rbx]
    add r9,0C    // add r9,14
    mov r9,[r9]
    mov rcx,[rsp+30]
    lea rdx,[szNamesFormat]    // "Name[%06i] %s"
    mov r8d,edi
    call msvcr100.fprintf
    mov rax,GNames
  @@:
  inc edi
  add rbx,8
  cmp edi,[rax+8]
  jb DumpNames_loop
DumpNames_exit:
mov rcx,[rsp+30]
call msvcr100.fclose
mov rbx,[rsp+38]
add rsp,20
pop rdi
ret

db CC CC CC CC

// *****************
// ** DumpObjects **
// *****************

DumpObjects:
mov rax,rsp
mov [rax+10],rbx
mov [rax+18],rsi
push rdi
sub rsp,30
and qword ptr [rax+8],0
lea r8,[szWrite]    // "w+"
lea rdx,[szObjectsFile]    // "ObjectDump.txt"
lea rcx,[rax+08]
call msvcr100.fopen_s
mov rax,GObjects
xor esi,esi
cmp [rax+8],esi
jbe DumpObjects_exit
  xor edi,edi
  DumpObjects_loop:
  mov rbx,[rax]
  cmp qword ptr [rbx+rdi],0
  je short @f
    mov rbx,[rbx+rdi]
    mov rcx,rbx
    call GetName
    mov rcx,[rsp+40]
    lea rdx,[szObjectsFormat]    // "UObject[%06i] %-50s 0x%X"
    mov r9,rax
    mov r8d,esi
    mov [rsp+20],rbx
    call msvcr100.fprintf
    mov rax,GObjects
  @@:
  inc esi
  add rdi,8
  cmp esi,[rax+8]
  jb DumpObjects_loop
DumpObjects_exit:
mov rcx,[rsp+40]
call msvcr100.fclose
mov rbx,[rsp+48]
mov rsi,[rsp+50]
add rsp,30
pop rdi
ret

db CC CC CC CC

// *************
// ** GetName **
// *************

GetName:
mov rax,GNames
mov r8d,[rcx+48]
mov r9d,[rax+08]
cmp r8d,r9d
ja short @f
  mov rax,[rax]
  mov rax,[rax+r8*8]
  add rax,14
  ret
@@:
mov rax,szInvalid
ret

db CC CC

/*

// ***************
// ** GetObject **
// ***************

GetObject:
mov edi,eax
test edi,edi
je short @f
  mov eax,[edi+28]
  test eax,eax
  je short @f
    call GetFullName
    ret
@@:
mov eax,szInvalid    // "INVALID NAME INDEX"
ret

db CC CC

// ****************
// ** FindObject **
// ****************

FindObject:
push ebp
mov ebp,esp
mov ecx,GObjects
push esi
push edi
xor esi,esi
cmp [ecx+4],esi
jle FindObject_exit
FindObject_0:
    mov eax,[ecx]
    mov edi,[eax+esi*4]
    test edi,edi
    je short @f
      mov eax,[edi+28]
      test eax,eax
      je short @f
        push [ebp+8]
        call GetFullName
        push eax
        call msvcr100.stricmp
        add esp,8
        test eax,eax
        je FindObject_1
          mov ecx,GObjects
    @@:
    inc esi
    cmp esi,[ecx+4]
    jl FindObject_0
FindObject_exit:
    pop edi
    pop esi
    mov esp,ebp
    pop ebp
    ret 4
FindObject_1:
    mov eax,edi
    pop edi
    pop esi
    mov esp,ebp
    pop ebp
    ret 4

db CC CC

//*********************************
//********   GetFullName   ********
//*********************************

GetFullName:
mov eax,[edi+28]                   // Class
test eax,eax
je GetFullName_NULL
  mov ecx,[edi+1C]                   // Outer
  test ecx,ecx
  je GetFullName_NULL
    cmp [ecx+1C],0                     // Outer-&gt;Outer
    je GetFullName_0
      mov ebx,szFunctionName
      mov ecx,GNames                     // GNames pointer
      mov eax,[eax+20]                   // FName_Index
      mov edx,[ecx]
      mov eax,[edx+eax*4]
      add eax,10                         // Class-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov dl,[eax]
        mov [ebx],dl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],20              // space character
      inc ebx
      mov ecx,[edi+1C]                   // Outer
      mov edx,[ecx+1C]                   // Outer-&gt;Outer
      mov eax,[edx+20]                   // FName_Index
      mov ecx,GNames                     // GNames pointer
      mov edx,[ecx]
      mov eax,[edx+eax*4]
      add eax,10                         // Outer-&gt;Outer-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov dl,[eax]
        mov [ebx],dl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],2E              // . character
      inc ebx
      mov ecx,[edi+1C]                   // Outer
      mov edx,[ecx+20]                   // FName_Index
      mov eax,GNames                     // GNames pointer
      mov ecx,[eax]
      mov edx,[ecx+edx*4]
      add edx,10                         // Outer-&gt;GetName
      @@:
      cmp byte ptr [edx],0
      je short @f
        mov al,[edx]
        mov [ebx],al
        inc ebx
        inc edx
        jmp short @b
      @@:
      mov byte ptr [ebx],2E              // . character
      inc ebx
      mov ecx,GNames                     // GNames pointer
      mov edx,[ecx]
      mov eax,[edi+20]                   // this - FName_Index
      mov eax,[edx+eax*4]
      add eax,10                         // this-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov dl,[eax]
        mov [ebx],dl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],0
      mov eax,szFunctionName
      ret
      GetFullName_0:
      mov ebx,szFunctionName
      mov edx,GNames                     // GNames pointer
      mov ecx,[eax+20]                   // FName_Index
      mov eax,[edx]
      mov ecx,[eax+ecx*4]
      add ecx,10                         // Class-&gt;GetName
      @@:
      cmp byte ptr [ecx],0
      je short @f
        mov al,[ecx]
        mov [ebx],al
        inc ebx
        inc ecx
        jmp short @b
      @@:
      mov byte ptr [ebx],20              // space character
      inc ebx
      mov edx,[edi+1C]                   // Outer
      mov eax,[edx+20]                   // FName_Index
      mov ecx,GNames                     // GNames pointer
      mov edx,[ecx]
      mov eax,[edx+eax*4]
      add eax,10                         // Outer-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov cl,[eax]
        mov [ebx],cl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],2E              // . character
      inc ebx
      mov edx,GNames                     // GNames pointer
      mov eax,[edx]
      mov ecx,[edi+20]                   // this - FName_Index
      mov ecx,[eax+ecx*4]
      add ecx,10                         // this-&gt;GetName
      @@:
      cmp byte ptr [ecx],0
      je short @f
        mov al,[ecx]
        mov [ebx],al
        inc ebx
        inc ecx
        jmp short @b
      @@:
      mov byte ptr [ebx],0
      mov eax,szFunctionName
      ret
GetFullName_NULL:
mov eax,szNull
ret

db CC CC

//*********************
//**   OutputDebug   **
//*********************

OutputDebug:
push ebp
mov ebp,esp
mov eax,szOutputDebug
mov ecx,ebx
@@:
  cmp byte ptr [ecx],0
  je short @f
    mov dl,[ecx]
    mov [eax],dl
    inc ecx
    inc eax
    jmp short @b
  @@:
  mov byte ptr [eax],0
  push szSeparator
  push szOutputDebug
  call lstrcatA
  push [ebp+8]
  push szFormat
  push szBuffer
  call wsprintfA
  add esp,C
  push szBuffer
  push szOutputDebug
  call lstrcatA
  push szOutputDebug
  call OutputDebugStringA
  mov esp,ebp
  pop ebp
  ret 4

*/

ExitDumpHandler:
add rsp,28
mov [DumpHandlerOff],2
ret

[DISABLE]

{$lua}

if( syntaxcheck == false ) then --actual execution
  local starttime = getTickCount()

if readInteger( "DumpHandlerOff" ) == 0 then --could be 2 already
  writeInteger( "DumpHandlerOff", 1 ) --tell the thread to kill itself
end

while( getTickCount() &lt; starttime + 1000 ) and ( readInteger( "DumpHandlerOff" ) ~= 2 ) do --wait till it has finished
  sleep( 20 )
end

if( getTickCount() &gt; starttime + 1000 ) then --could happen when the window is shown
  showMessage( 'Disabling the thread failed!' )
  error( 'Thread disabling failed!' )
end
  sleep( 1 )
end

{$asm}

unregistersymbol( DumpHandlerOff )
dealloc( DumpHandlerOff )
unregistersymbol( DumpHandlerThread )
dealloc( DumpHandlerThread )
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>188</ID>
              <Description>"GNames &amp; GObjects Dumper (ASCII) - altered"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

alloc( DumpHandlerThread, 1024, BatmanAK.exe )
registersymbol( DumpHandlerThread )
label( DumpHandlerThread_loop )
CreateThread( DumpHandlerThread )
alloc( DumpHandlerOff, 4, BatmanAK.exe )
registersymbol( DumpHandlerOff )
label( ExitDumpHandler )

label( szWrite )
label( szNamesFile )
label( szObjectsFile )
label( szNamesFormat )
label( szNamesFormatW )
label( szObjectsFormat )
label( szObjectsFormatW )
label( szInvalid )
label( szNull )
label( szFunctionName )

label( DumpNames )
label( DumpNames_loop )
label( DumpNames_exit )

label( DumpObjects )
label( DumpObjects_loop )
label( DumpNames_continue )
label( DumpObjects_exit )

label( GetName )
label( GetName_invalid )

/*

label( GetFullName )
label( GetFullName_0 )
label( GetFullName_NULL )

*/

label( x )
label( y )

DumpHandlerOff:
dd 0

DumpHandlerThread+700:
szWrite:
db 'w+',0
szNamesFile:
db 'NamesDump.txt',0
szObjectsFile:
db 'ObjectsDump.txt',0
szNamesFormat:
db 'Name[%06i] %s',0A,0
szNamesFormatW:
db 'Name[%06i] %S',0A,0,0
szObjectsFormat:
db 'UObject[%06i] %-50s 0x%llX',0A,0
szObjectsFormatW:
db 'UObject[%06i] %-50S 0x%llX',0A,0,0
szInvalid:
db 'INVALID NAME INDEX',0
szNull:
db '(null)',0
szFunctionName:
dd 0

DumpHandlerThread:
sub rsp,28
DumpHandlerThread_loop:
mov rcx,A
call Sleep
cmp [DumpHandlerOff],1
je ExitDumpHandler
  mov rcx,6F //VK_NUMPAD /
  call GetAsyncKeyState
  test ax,ax
  jne @f
    jmp DumpHandlerThread_loop
  @@:
  //call DumpNames
  call DumpObjects
  mov rcx,C8
  call Sleep
  jmp DumpHandlerThread_loop

// ***************
// ** DumpNames **
// ***************

DumpNames:
mov [rsp+10],rbx
push rdi
sub rsp,30
and qword ptr [rsp+30],0
lea r8,[szWrite]                    //w+
lea rdx,[szNamesFile]               // "NameDump.txt"
lea rcx,[rsp+30]
call msvcrt.fopen_s
mov rax,GNames
xor edi,edi
cmp [rax+8],edi
jbe DumpNames_exit
  xor ebx,ebx
DumpNames_loop:
  mov r9,[rax]
  lea r9,[r9+rdi*8]
  cmp qword ptr [r9],0
  je short DumpNames_continue
    mov r9,[r9]
    mov edx,[r9]
    test dl,1
    je short @f
      lea r9,[r9+C]
      mov rcx,[rsp+30]
      lea rdx,[szNamesFormatW]         // "Name[%06i] %S"
      jmp short y
    @@:
    test dl,2
    je short @f
       lea r9,[r9+C]
       mov r9,[r9]
       jmp short x
    @@:
    lea r9,[r9+C]
    x:
    mov rcx,[rsp+30]
    lea rdx,[szNamesFormat]         // "Name[%06i] %s"
    y:
    mov r8d,edi
    call msvcrt.fprintf
    mov rax,GNames
  DumpNames_continue:
  inc edi
  add rbx,8
  cmp edi,[rax+8]
  jb DumpNames_loop
DumpNames_exit:
mov rcx,[rsp+30]
call msvcrt.fclose
mov rbx,[rsp+38]
add rsp,30
pop rdi
ret

db CC CC CC CC

// *****************
// ** DumpObjects **
// *****************

DumpObjects:
mov rax,rsp
mov [rax+10],rbx
mov [rax+18],rsi
push rdi
sub rsp,30
and qword ptr [rax+8],0
lea r8,[szWrite]                    // "w+"
lea rdx,[szObjectsFile]             // "ObjectDump.txt"
lea rcx,[rax+8]
call msvcr100.fopen_s
mov rax,GObjects
xor esi,esi
cmp [Max_GObjects],esi
jbe DumpObjects_exit
  xor edi,edi
  DumpObjects_loop:
  mov rbx,rax
  cmp qword ptr [rbx+rdi],0
  je short @f
    mov rbx,[rbx+rdi]
    mov rcx,rbx
    call GetName
    mov rcx,[rsp+40]
    lea rdx,[szObjectsFormat]       // "UObject[%06i] %-50s 0x%X"
    mov r9,rax
    mov r8d,esi
    mov [rsp+20],rbx
    call msvcr100.fprintf
    mov rax,GObjects
  @@:
  inc esi
  add rdi,8
  cmp esi,[Max_GObjects]
  jb DumpObjects_loop
DumpObjects_exit:
mov rcx,[rsp+40]
call msvcr100.fclose
mov rbx,[rsp+48]
mov rsi,[rsp+50]
add rsp,30
pop rdi
ret

db CC CC CC CC

// *************
// ** GetName **
// *************

GetName:
mov rax,GNames
mov r8d,[rcx+3C]
mov r9d,[rax+8]
cmp r8d,r9d
ja short GetName_invalid
  mov rax,[rax]
  mov rax,[rax+r8*8]
  mov edx,[rax]
  test dl,1
  je short @f
    lea rax,[rax+C]                 // W
    ret
  @@:
  test dl,2
  je short @f
    mov rax,[rax+C]
    ret
  @@:
  lea rax,[rax+C]
  ret
GetName_invalid:
mov rax,szInvalid
ret

db CC CC

/*

//*********************************
//********   GetFullName   ********
//*********************************

GetFullName:
mov eax,[edi+28]                   // Class
test eax,eax
je GetFullName_NULL
  mov ecx,[edi+1C]                   // Outer
  test ecx,ecx
  je GetFullName_NULL
    cmp [ecx+1C],0                     // Outer-&gt;Outer
    je GetFullName_0
      mov ebx,szFunctionName
      mov ecx,GNames                     // GNames pointer
      mov eax,[eax+20]                   // FName_Index
      mov edx,[ecx]
      mov eax,[edx+eax*4]
      add eax,10                         // Class-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov dl,[eax]
        mov [ebx],dl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],20              // space character
      inc ebx
      mov ecx,[edi+1C]                   // Outer
      mov edx,[ecx+1C]                   // Outer-&gt;Outer
      mov eax,[edx+20]                   // FName_Index
      mov ecx,GNames                     // GNames pointer
      mov edx,[ecx]
      mov eax,[edx+eax*4]
      add eax,10                         // Outer-&gt;Outer-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov dl,[eax]
        mov [ebx],dl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],2E              // . character
      inc ebx
      mov ecx,[edi+1C]                   // Outer
      mov edx,[ecx+20]                   // FName_Index
      mov eax,GNames                     // GNames pointer
      mov ecx,[eax]
      mov edx,[ecx+edx*4]
      add edx,10                         // Outer-&gt;GetName
      @@:
      cmp byte ptr [edx],0
      je short @f
        mov al,[edx]
        mov [ebx],al
        inc ebx
        inc edx
        jmp short @b
      @@:
      mov byte ptr [ebx],2E              // . character
      inc ebx
      mov ecx,GNames                     // GNames pointer
      mov edx,[ecx]
      mov eax,[edi+20]                   // this - FName_Index
      mov eax,[edx+eax*4]
      add eax,10                         // this-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov dl,[eax]
        mov [ebx],dl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],0
      mov eax,szFunctionName
      ret
      GetFullName_0:
      mov ebx,szFunctionName
      mov edx,GNames                     // GNames pointer
      mov ecx,[eax+20]                   // FName_Index
      mov eax,[edx]
      mov ecx,[eax+ecx*4]
      add ecx,10                         // Class-&gt;GetName
      @@:
      cmp byte ptr [ecx],0
      je short @f
        mov al,[ecx]
        mov [ebx],al
        inc ebx
        inc ecx
        jmp short @b
      @@:
      mov byte ptr [ebx],20              // space character
      inc ebx
      mov edx,[edi+1C]                   // Outer
      mov eax,[edx+20]                   // FName_Index
      mov ecx,GNames                     // GNames pointer
      mov edx,[ecx]
      mov eax,[edx+eax*4]
      add eax,10                         // Outer-&gt;GetName
      @@:
      cmp byte ptr [eax],0
      je short @f
        mov cl,[eax]
        mov [ebx],cl
        inc ebx
        inc eax
        jmp short @b
      @@:
      mov byte ptr [ebx],2E              // . character
      inc ebx
      mov edx,GNames                     // GNames pointer
      mov eax,[edx]
      mov ecx,[edi+20]                   // this - FName_Index
      mov ecx,[eax+ecx*4]
      add ecx,10                         // this-&gt;GetName
      @@:
      cmp byte ptr [ecx],0
      je short @f
        mov al,[ecx]
        mov [ebx],al
        inc ebx
        inc ecx
        jmp short @b
      @@:
      mov byte ptr [ebx],0
      mov eax,szFunctionName
      ret
GetFullName_NULL:
mov eax,szNull
ret

db CC CC

*/

ExitDumpHandler:
add rsp,28
mov [DumpHandlerOff],2
ret

[DISABLE]

{$lua}

if( syntaxcheck == false ) then --actual execution
  local starttime = getTickCount()

if readInteger( "DumpHandlerOff" ) == 0 then --could be 2 already
  writeInteger( "DumpHandlerOff", 1 ) --tell the thread to kill itself
end

while( getTickCount() &lt; starttime + 1000 ) and ( readInteger( "DumpHandlerOff" ) ~= 2 ) do --wait till it has finished
  sleep( 20 )
end

if( getTickCount() &gt; starttime + 1000 ) then --could happen when the window is shown
  showMessage( 'Disabling the thread failed!' )
  error( 'Thread disabling failed!' )
end
  sleep( 1 )
end

{$asm}

unregistersymbol( DumpHandlerOff )
dealloc( DumpHandlerOff )
unregistersymbol( DumpHandlerThread )
dealloc( DumpHandlerThread )
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>179</ID>
              <Description>"Set Hook &amp; Emulate RCheatManager UObject"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

alloc( pCave, 1024, BatmanAK.exe )
alloc( pObject, 64, BatmanAK.exe )
registersymbol( pObject )
label( back )

label( pRPlayerControllerCombat )
registersymbol( pRPlayerControllerCombat )
label( szRCheatManager )
label( szDefault_RCheatManager )
label( szNull_0 )
label( szInvalid_0 )
label( szSpace_0 )
label( szDot_0 )
label( szFunctionName_0 )

label( pCave_loop )
label( pCave_next )
label( pCave_continue )
label( pCave_exit )

label( GetName_0 )
label( GetName_0_invalid )

label( GetFullName_0 )
label( GetFullName_0_null )
label( GetFullName_0_continue )
label( GetFullName_0_exit )

pCave+500:
pRPlayerControllerCombat:
dq 0
db 0,0
szRCheatManager:
db 'Class BmGame.RCheatManager',0
pCave+5C0:
szDefault_RCheatManager:
db 'RCheatManager BmGame.Default__RCheatManager',0
szNull_0:
db '(null)',0,0
szInvalid_0:
db 'INVALID NAME INDEX',0,0
szSpace_0:
db 20,0,0
szDot_0:
db 2E,0,0
szFunctionName_0:
dd 0

pObject+8:
db 60 80 08 00 20 00 00 00

pCave:
mov [r12+5C],rax // original code
mov [pObject+34],rax
mov [pRPlayerControllerCombat],rax
// hook_start
push rdi
sub rsp,20
mov rax,GObjects
xor edi,edi
cmp [MaxGObjects],edi
jna pCave_exit
  xor ebx,ebx
  pCave_loop:
  mov rcx,rax
  cmp qword ptr [rbx+rcx],0
  je pCave_continue
    mov rcx,[rbx+rcx]
    call GetFullName_0
    lea rdx,[szRCheatManager]          // "Class BmGame.RCheatManager"
    mov rcx,rax
    call msvcrt.strcmp
    test eax,eax
    jne short @f
      mov rax,GObjects
      mov rax,[rax+rbx]
      mov [pObject+44],rax
	  jmp pCave_next
	@@:
    mov rax,GObjects
    mov rcx,rax
    mov rcx,[rbx+rcx]
    call GetFullName_0
    lea rdx,[szDefault_RCheatManager]  // "RCheatManager BmGame.Default__RCheatManager"
    mov rcx,rax
    lea rcx,[szFunctionName_0]
    call msvcrt.strcmp
	jne short @f
      mov rax,GObjects
      mov rax,[rax+rbx]
      mov rax,[rax]
	  mov [pObject],rax
	pCave_next:
    mov rax,GObjects
  pCave_continue:
  inc edi
  add rbx,8
  cmp edi,[MaxGObjects]
  jb pCave_loop
mov rax,[pRPlayerControllerCombat]
mov rcx,pObject
mov [rax+4D0],rcx
mov rbx,[rsp+30]
add rsp,20
pop rdi
// hook end
pCave_exit:
jmp back

db CC CC CC CC

// *************
// ** GetName **
// *************

GetName_0:
mov rax,GNames
mov r8d,[rcx+3C]                    // FName_Index
mov r9d,[rax+8]
cmp r8d,r9d
ja short GetName_0_invalid
  mov rax,[rax]
  mov rax,[rax+r8*8]
  mov edx,[rax]
  test dl,1
  je short @f
    lea rax,[rax+C]                 // if UNICODE
    ret
  @@:
  test dl,2
  je short @f
    mov rax,[rax+C]
    ret
  @@:
  lea rax,[rax+C]
  ret
GetName_0_invalid:
lea rax,[szInvalid_0]               // "INVALID NAME INDEX"
ret

db CC CC CC CC

//*********************************
//********   GetFullName   ********
//*********************************

GetFullName_0:
mov [rsp+8],rbx
push rdi
sub rsp,20
mov rbx,rcx
mov rcx,[rcx+44]
test rcx,rcx
je GetFullName_0_null
  mov rax,[rbx+34]
  test rax,rax
  je GetFullName_0_null
    cmp qword ptr [rax+34],0
    je short @f
      call GetName_0
      lea rdi,[szFunctionName_0]
      mov rdx,rax
      mov rcx,rdi
      call msvcrt.strcpy
      lea rdx,[szSpace_0]           // " "
      mov rcx,rdi
      call msvcrt.strcat
      mov rcx,[rbx+34]
      mov rcx,[rcx+34]
      call GetName_0
      mov rcx,rdi
      mov rdx,rax
      call msvcrt.strcat
      lea rdx,[szDot_0]             // "."
      jmp GetFullName_0_continue
    @@:
    call GetName_0
    lea rdi,[szFunctionName_0]
    mov rdx,rax
    mov rcx,rdi
    call msvcrt.strcpy
    lea rdx,[szSpace_0]             // " "
	GetFullName_0_continue:
    mov rcx,rdi
    call msvcrt.strcat
    mov rcx,[rbx+34]
    call GetName_0
    mov rcx,rdi
    mov rdx,rax
    call msvcrt.strcat
    lea rdx,[szDot_0]               // "."
    mov rcx,rdi
    call msvcrt.strcat
    mov rcx,rbx
    call GetName_0
    mov rcx,rdi
    mov rdx,rax
    call msvcrt.strcat
    mov rax,rdi
    jmp short GetFullName_0_exit
GetFullName_0_null:
lea rax,[szNull_0]                  // "(null)"
GetFullName_0_exit:
mov rbx,[rsp+30]
add rsp,20
pop rdi
ret

db CC CC CC CC

// BatmanAK.exe+4D5689E - 49 89 44 24 5C        - mov [r12+5C],rax
// BatmanAK.exe+4D568A3 - 48 89 75 BF           - mov [rbp-41],rsi

BatmanAK.exe+4D5689E:
jmp pCave
back:

[DISABLE]

[pRPlayerControllerCombat]+4D0:
dq 0

BatmanAK.exe+4D5689E:
mov [r12+5C],rax

unregistersymbol( pRPlayerControllerCombat )
unregistersymbol( pObject )
dealloc( pObject )
dealloc( pCave )
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>191</ID>
          <Description>"LocalPlayer"</Description>
          <ShowAsHex>1</ShowAsHex>
          <VariableType>8 Bytes</VariableType>
          <Address>pLocalPlayer</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>192</ID>
          <Description>"RPlayerControllerCombat"</Description>
          <ShowAsHex>1</ShowAsHex>
          <VariableType>8 Bytes</VariableType>
          <Address>pRPlayerControllerCombat</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>195</ID>
          <Description>"RPlayerControllerCombat_a"</Description>
          <ShowAsHex>1</ShowAsHex>
          <VariableType>8 Bytes</VariableType>
          <Address>pRPlayerControllerCombat_a</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>UpgradePtsAndXP</Name>
      <Address>01664900</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>Toggler</Name>
      <Address>08890500</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bPlayersOnly</Name>
      <Address>08890508</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bGhost</Name>
      <Address>0889050C</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bHUD</Name>
      <Address>08890514</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>p0</Name>
      <Address>1DDB0400</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>p1</Name>
      <Address>1DDB0404</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>p2</Name>
      <Address>1DDB0408</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>EPhysicsChange_Hook</Name>
      <Address>1DDB00A5</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bFly</Name>
      <Address>1DDB040C</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bAmmo</Name>
      <Address>1DDB0414</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bGod</Name>
      <Address>1DDB0410</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>bCombo</Name>
      <Address>1DDB0418</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>KillComboReset_Cave</Name>
      <Address>1DDB00CE</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>dwEPhysicsHook</Name>
      <Address>007A7144</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>dwStopEPhysicsChange</Name>
      <Address>007AE829</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>KillComboReset</Name>
      <Address>00435664</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>GetIndex</Name>
      <Address>0048B1F0</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>SetIndex</Name>
      <Address>004408F0</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>TheWorld</Name>
      <Address>01664900</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>KeyHandlerOff</Name>
      <Address>0BB30500</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>GetObject</Name>
      <Address>0BB30151</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>GetFullName</Name>
      <Address>0BB301D9</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>FindObject</Name>
      <Address>0BB30174</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>OutputDebug</Name>
      <Address>0BB30324</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>ProcessEvent</Name>
      <Address>002CE330</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>Max_GObjects</Name>
      <Address>143A82168</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>GObjects</Name>
      <Address>143484E24</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>MaxGObjects</Name>
      <Address>143A82168</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>GNames</Name>
      <Address>143A98AF8</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>pLocalPlayer</Name>
      <Address>13FFF0026</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>pRPlayerControllerCombat</Name>
      <Address>13FFF002E</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>pRPlayerControllerCombat_a</Name>
      <Address>13FFE0500</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
</CheatTable>
