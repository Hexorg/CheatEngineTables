<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="16">
  <CheatEntries>
    <CheatEntry>
      <ID>256</ID>
      <Description>"README  (double-click "&lt;script&gt;") ----------&gt;"</Description>
      <Color>FF00FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{
Pixel Pirates is written in .NET so it is not compiled until you are running the game,
so you must perform the proper actions before enabling certain scripts:

  SCRIPT: Raise Attribute - self explanatory
  SCRIPT: Learning - read a book
  SCRIPT: Inventory - equip a passive item
  SCRIPT: Ship Parts - place a ship part
  SCRIPT: Damage - attack something or be attacked
  SCRIPT: Hunger - start a game, happens every tick
  SCRIPT: Morale - start a game, happens every tick
  SCRIPT: Shop - visit a shop

You must enable the "Globals" cheat table entry to be able to use any scripts.  Enable
the scripts you can and then enable the cheats you want.

Cheats:
  F1: God Mode - Do not take damage (at least from pirates/animals)
  F2: One Hit Kill - Non-crew die in one hit
  F3: Hunger - Never go hungry
  F4: Morale - Always have full morale

In-Game Cheats:
  Ship Parts - hold LSHIFT to keep inventory from decreasing, hold LCONTROL
          to give you 99 of the part instead of decreasing
  Inventory - hold LSHIFT to keep passive equipment (books, diapers,
          grindstones, etc) from decreasing, hold LCONTROL to give you 99 of
          the item instead of decreasing.  For books, either key will also
          keep your TP from decreasing.
  Raise Attributes - Holding LSHIFT will keep you from losing TP


Editable Values:
  Gold - You need to enter a shop after enabling the Shop script to get a valid pointer
  Crew Stats: Crew member is selected when viewing them.  Changed values
          won't be immediately visible, you have to up an ability or
          switch crew members to see the new value.

Colors:
  Blue: script
  Light Gray: used for testing
  Purple: readme
}

[ENABLE]
[DISABLE]
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>4</ID>
      <Description>"+ Globals"</Description>
      <Options moHideChildren="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
globalalloc(globals,$100000)

[DISABLE]

{
0000: pCharLastViewedScreen - last character viewed on screen
0004: pGoldParent - parent gold structure (pointer to gold structure at +58)
0008: pGoldBase - gold structure (gold is 32 bit integer at +38)
000C: pCharLastViewedBase - base of last viewed char (CHAR pointer at +38)

1000: fHunger - flag to keep you from getting hungry
1004: fMorale - flag to keep morale high
1008: fGodMode - flag to keep captain/pirate from losing hp (anything with Salary)
100C: fOneHitKill - flag to make sure damage is at least enough to kill anything not a captain or pirate (anything with no salary)

2000: hunger counter
2004: morale counter
2008: god counter
200C: ohk counter


Character:
  0010: Pointer-&gt; Type?
        0008: String length
        000C: Unicode string ("Hero" for captain, '-' for pirates and lobsters)
  0014: Pointer-&gt; Class?
        0008: String length
        000C: Unicode string ("Fast" for captain, '-' for pirates and lobsters)
  0038: Pointer-&gt;String (voice7, voice15, monkey0)
  0088: HP (float)
  008C: MAX HP (float)
  0090: Hunger (float)
  0094: MAX Hunger (float)
  0098: Morale (float)
  009C: Max Morale (float)
  00C8: TP (int)
  00D0: Level (float)
  00D4: XP (float)
  00DC: STR (float)
  00E0: VIT (float)
  00E4: INT (float)
  00E8: AGI (float)
  00EC: DEX (float)
  00F0: LUCK (float)
  -- others, not sure what they are --
  00A0: ? lowering value ?
  00A4: ? max of 00A0 value ?
  00A8: Another float value
  -- possible player/friend/enemy --
  0044: float 0 0 (float set only for captain)
  0054: float 0 0 (float set only for captain)
  0058: float 0 0 (float set only for captain)
  0064: 0 0 float (float set only for enemies) +
  0068: 0 0 $100 (possible flag set for enemy) -
  0074: 5 1 0 (possible friend index set for pirates and captain?) +
  0084: 0 0 2 (possible index set for enemies?) +
  00A8: float float 0 (float set for captain and pirates?) +
  00AC: float float 0 (float set for captain and pirates?) +
  00C8: TP TP 0 (integer TP points, enemies shouldn't have, requires leaving unspent TP)
  00D8: Salary Salary 0 (float salary, enemies shouldn't have, might be 0 for friends rarely?)
  0114: 6 0 0 (int set only for captain? changed to 7)
  0128: 5 5 0 (int set only for pirates and captain?)
  012c: 40 28 0 (int set only for pirates and captain?)
  0130: 6 8 0 (int set only for pirates and captain?)
  0134: 11 11 0 (int set only for pirates and captain?)
  0138: 0 7 0 (int set only for pirates?)
  0140: 10 5 13 (Captain, pirate, monkey)
  0144: 2 2 1 (2 for pirates and captain, 1 for monkeys)
  0148: 71 0 0 (int, same as salary, but only for captain?)
  016C-0198: 12 floats set only for captain and pirates - probably 3d matrix?)

  01C8: 1 0 0 (int set o nly for captain)


}
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>33</ID>
          <Description>"SCRIPT: Raise Attribute (LSHIFT for no TP use)"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Stores new TP after spending one upping an attribute
}

[ENABLE]


aobscan(TEST_LOWER_TP,49 89 88 C8 00 00 00 83) // should be unique
alloc(newmem,$1000)

label(code)
label(skip)
label(return)

newmem:

code:
  // check for left shift pressed prevent using AP when upping a skill attribute
  pushad
  push 000000A0 // VK_LSHIFT http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jnz skip
  mov [eax+000000C8],ecx // original code
skip:
  jmp return

TEST_LOWER_TP+01:
  jmp code
  nop
return:
registersymbol(TEST_LOWER_TP)

[DISABLE]

TEST_LOWER_TP+01:
  db 89 88 C8 00 00 00

unregistersymbol(TEST_LOWER_TP)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 0A8FE214

0A8FE1F1: 8D 44 88 10     - lea eax,[eax+ecx*4+10]
0A8FE1F5: 8B 18           - mov ebx,[eax]
0A8FE1F7: 8B C3           - mov eax,ebx
0A8FE1F9: 8B 40 38        - mov eax,[eax+38]
0A8FE1FC: 8B 80 C8000000  - mov eax,[eax+000000C8]
0A8FE202: 85 C0           - test eax,eax
0A8FE204: 0F8E CA010000   - jng 0A8FE3D4
0A8FE20A: 8B 43 38        - mov eax,[ebx+38]
0A8FE20D: 8B 88 C8000000  - mov ecx,[eax+000000C8]
0A8FE213: 49              - dec ecx
// ---------- INJECTING HERE ----------
0A8FE214: 89 88 C8000000  - mov [eax+000000C8],ecx
// ---------- DONE INJECTING  ----------
0A8FE21A: 83 EC 08        - sub esp,08
0A8FE21D: 68 70FEDC25     - push 25DCFE70
0A8FE222: 57              - push edi
0A8FE223: E8 383D21FB     - call 05B11F60
0A8FE228: 83 C4 10        - add esp,10
0A8FE22B: 85 C0           - test eax,eax
0A8FE22D: 74 18           - je 0A8FE247
0A8FE22F: 8B 43 38        - mov eax,[ebx+38]
0A8FE232: D9 80 E8000000  - fld dword ptr [eax+000000E8]
0A8FE238: D9E8            - fld1
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>247</ID>
          <Description>"SCRIPT: Learning (LSHIFT or LCONTROL for no TP loss)"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Lowers TP when reading a book
}

[ENABLE]

aobscan(TEST_AP_BOOK,89 88 C8 00 00 00 33) // should be unique
alloc(newmem,$1000)

label(code)
label(keepTP)
label(skip)
label(return)

newmem:

code:
  // check for left shift pressed prevent using TP when reading a book
  pushad
  push 000000A0 // VK_LSHIFT http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jnz keepTP

  // check for left control pressed prevent using TP when reading a book
  pushad
  push 000000A2 // VK_LCONTROL http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jz skip

keepTP:
  mov ecx,[eax+000000C8] // load existing TP

skip:
  mov [eax+000000C8],ecx // original code
  jmp return

TEST_AP_BOOK:
  jmp code
  nop
return:
registersymbol(TEST_AP_BOOK)

[DISABLE]

TEST_AP_BOOK:
  db 89 88 C8 00 00 00

unregistersymbol(TEST_AP_BOOK)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 263969F2

263969CE: FF B5 3CFFFFFF     - push [ebp-000000C4]
263969D4: 50                 - push eax
263969D5: 39 00              - cmp [eax],eax
263969D7: E8 F467CBDF        - call 0604D1D0
263969DC: 83 C4 10           - add esp,10
263969DF: 8B D0              - mov edx,eax
263969E1: 8B 85 38FFFFFF     - mov eax,[ebp-000000C8]
263969E7: 8B 8D 34FFFFFF     - mov ecx,[ebp-000000CC]
263969ED: 8B 52 1C           - mov edx,[edx+1C]
263969F0: 2B CA              - sub ecx,edx
// ---------- INJECTING HERE ----------
263969F2: 89 88 C8000000     - mov [eax+000000C8],ecx
// ---------- DONE INJECTING  ----------
263969F8: 33 F6              - xor esi,esi
263969FA: 33 DB              - xor ebx,ebx
263969FC: E9 93000000        - jmp 26396A94
26396A01: 8D A4 24 00000000  - lea esp,[esp+00000000]
26396A08: 8B 05 98BE7505     - mov eax,[0575BE98]
26396A0E: 8B 40 2C           - mov eax,[eax+2C]
26396A11: 83 EC 08           - sub esp,08
26396A14: 53                 - push ebx
26396A15: 50                 - push eax
26396A16: 39 00              - cmp [eax],eax
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>245</ID>
          <Description>"SCRIPT: Inventory (LSHIFT to not use, LCONTROL to get 99)"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Decrements inventory when using books at least
}

[ENABLE]

// NOTE: very long AOB because there's a virtual duplicate earlier in memory,
// but it looks like it is unlinked, i.e. the jg near the end has a meaningless
// offset of 0 and there's a call earlier to address 00000000
aobscan(TEST_INVENTORY_DECREASE,8B 50 10 4A 89 50 10 8b 05 * * * * 8b 40 58 8b 40 20 39 0 8b 40 08 39 48 0c 0f 86 * * * * 8d 44 88 10 8b 00 8b 40 10 85 c0 0f 8f 5c 0 0 0) // should be unique
alloc(newmem,$1000)

label(code)
label(cheatSetTo99)
label(cheatDoNotUse)
label(skip)
label(return)

newmem:

code:
  // check for left control pressed to set count to 99
  pushad
  push 000000A2 // VK_LCONTROL http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jnz cheatSetTo99

  // check for left shift pressed to prevent using inventory
  pushad
  push 000000A0 // VK_LSHIFT http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jnz cheatDoNotUse
  jmp skip

cheatSetTo99:
  mov edx,#99
  mov [eax+10],edx
  jmp return

cheatDoNotUse:
  mov edx,[eax+10]
  jmp return // skip decrement

skip:
  // original code
  mov edx,[eax+10]
  dec edx
  mov [eax+10],edx
  jmp return

TEST_INVENTORY_DECREASE:
  jmp code
  nop
  nop
return:
registersymbol(TEST_INVENTORY_DECREASE)

[DISABLE]

TEST_INVENTORY_DECREASE:
  db 8B 50 10 4A 89 50 10

unregistersymbol(TEST_INVENTORY_DECREASE)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 2639639C

26396379: 8B 05 98BE7505     - mov eax,[0575BE98] // static with item list?
2639637F: 8B 40 58           - mov eax,[eax+58]
26396382: 8B 40 20           - mov eax,[eax+20]
26396385: 39 00              - cmp [eax],eax
26396387: 8B 40 08           - mov eax,[eax+08]
2639638A: 8B 4D CC           - mov ecx,[ebp-34] // index of item?
2639638D: 39 48 0C           - cmp [eax+0C],ecx // make sure we have enough of the item?
26396390: 0F86 33030000      - jbe 263966C9
26396396: 8D 44 88 10        - lea eax,[eax+ecx*4+10] // load address of pointer to item structure
2639639A: 8B 00              - mov eax,[eax] // load pointer
// ---------- INJECTING HERE ----------
2639639C: 8B 50 10           - mov edx,[eax+10] // load current quantity
2639639F: 4A                 - dec edx // decrease quantity
263963A0: 89 50 10           - mov [eax+10],edx // store new quantity
// ---------- DONE INJECTING  ----------
263963A3: 8B 05 98BE7505     - mov eax,[0575BE98]
263963A9: 8B 40 58           - mov eax,[eax+58]
263963AC: 8B 40 20           - mov eax,[eax+20]
263963AF: 39 00              - cmp [eax],eax
263963B1: 8B 40 08           - mov eax,[eax+08]
263963B4: 39 48 0C           - cmp [eax+0C],ecx
263963B7: 0F86 05030000      - jbe 263966C2
263963BD: 8D 44 88 10        - lea eax,[eax+ecx*4+10]
263963C1: 8B 00              - mov eax,[eax]
263963C3: 8B 40 10           - mov eax,[eax+10]
263963C6: 85 C0              - test eax,eax
263963C8: 0F8F 5C000000      - jg 2639642A
263963CE: 8B 05 98BE7505     - mov eax,[0575BE98] : [0BB9EDB0]
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>253</ID>
          <Description>"SCRIPT: Ship Parts (LSHIFT to not use, LCONTROL to get 99)"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-22
  Author : Jason

  This script does blah blah blah
}

[ENABLE]

aobscan(TEST_SHIP_INVENTORY,8B 51 10 2B 55 10) // should be unique
alloc(newmem,$1000)

label(code)
label(cheatSetTo99)
label(cheatDoNotUse)
label(skip)
label(return)

newmem:

code:
  // check for left control pressed to set count to 99
  pushad
  push 000000A2 // VK_LCONTROL http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jnz cheatSetTo99

  // check for left shift pressed to prevent using inventory
  pushad
  push 000000A0 // VK_LSHIFT http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  popad
  jnz cheatDoNotUse
  jmp skip

cheatSetTo99:
  mov edx,#99
  mov [ecx+10],edx
  jmp return

cheatDoNotUse:
  mov edx,[ecx+10]
  jmp return // skip decrement

skip:
  // original code
  mov edx,[ecx+10]
  sub edx,[ebp+10]
  jmp return

TEST_SHIP_INVENTORY:
  jmp code
  nop
return:
registersymbol(TEST_SHIP_INVENTORY)

[DISABLE]

TEST_SHIP_INVENTORY:
  db 8B 51 10 2B 55 10

unregistersymbol(TEST_SHIP_INVENTORY)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 263A11A6

263A1183: 0F84 6A000000   - je 263A11F3
263A1189: 8B 45 08        - mov eax,[ebp+08]
263A118C: 8B 48 58        - mov ecx,[eax+58]
263A118F: 8B 49 20        - mov ecx,[ecx+20]
263A1192: 39 09           - cmp [ecx],ecx
263A1194: 8B 49 08        - mov ecx,[ecx+08]
263A1197: 39 59 0C        - cmp [ecx+0C],ebx
263A119A: 0F86 7D000000   - jbe 263A121D
263A11A0: 8D 4C 99 10     - lea ecx,[ecx+ebx*4+10]
263A11A4: 8B 09           - mov ecx,[ecx]
// ---------- INJECTING HERE ----------
263A11A6: 8B 51 10        - mov edx,[ecx+10]
263A11A9: 2B 55 10        - sub edx,[ebp+10]
// ---------- DONE INJECTING  ----------
263A11AC: 89 51 10        - mov [ecx+10],edx
263A11AF: 8B 40 58        - mov eax,[eax+58]
263A11B2: 8B 40 20        - mov eax,[eax+20]
263A11B5: 39 00           - cmp [eax],eax
263A11B7: 8B 40 08        - mov eax,[eax+08]
263A11BA: 39 58 0C        - cmp [eax+0C],ebx
263A11BD: 0F86 4E000000   - jbe 263A1211
263A11C3: 8D 44 98 10     - lea eax,[eax+ebx*4+10]
263A11C7: 8B 00           - mov eax,[eax]
263A11C9: 8B 40 10        - mov eax,[eax+10]
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>238</ID>
          <Description>"SCRIPT: Damage (needed for God and One Hit Kill)"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Where HP is stored after subtracting damage
}

[ENABLE]

aobscan(TEST_HP_LOSS,D9 98 88 00 00 00 8B 46 38 8B C8) // should be unique
alloc(newmem,$1000)

label(code)
label(isFriend)
label(done)
label(return)

newmem:

code:
  // if they have salary, they are a friend
  cmp dword ptr [eax+000000D8], 0
  jne isFriend

  // if enemy, see if we are one-hit-killing them
  cmp dword ptr [globals+100C],1
  jne done
  inc dword ptr [globals+200C]
  fstp st(0) // throw away value to set health to
  fldz // set health to zero
  jmp done

isFriend:
  // see if we have enabled god mode
  cmp dword ptr [globals+1008],1
  jne done
  inc dword ptr [globals+2008]
  fstp st(0) // throw away old value to set health to
  fld dword ptr [eax+0000008C] // load max HP

done:
  fstp dword ptr [eax+00000088]
  jmp return

TEST_HP_LOSS:
  jmp code
  nop
return:
registersymbol(TEST_HP_LOSS)

[DISABLE]

TEST_HP_LOSS:
  db D9 98 88 00 00 00

unregistersymbol(TEST_HP_LOSS)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 0A8D1A1C
26338C71 - E8 BA0FFDFF           - call 26309C30
26338C76 - 83 C4 10              - add esp,10
26338C79 - 85 C0                 - test eax,eax
26338C7B - 7E 21                 - jle 26338C9E
26338C7D - 8B 46 38              - mov eax,[esi+38]
26338C80 - D9 80 88000000        - fld dword ptr [eax+00000088]
26338C86 - 8B 47 38              - mov eax,[edi+38]
26338C89 - D9 80 88000000        - fld dword ptr [eax+00000088]
26338C8F - DFF1                  - fcomip st(0),st(1)
26338C91 - DDD8                  - fstp st(0)
26338C93 - 7A 09                 - jp 26338C9E
26338C95 - 73 07                 - jae 26338C9E
26338C97 - 83 85 C8F3FFFF 03     - add dword ptr [ebp-00000C38],03
26338C9E - 8B 47 38              - mov eax,[edi+38]
26338CA1 - 83 EC 08              - sub esp,08
26338CA4 - 68 10D90925           - push 2509D910 : [056981BC]
26338CA9 - 50                    - push eax
26338CAA - 39 00                 - cmp [eax],eax
26338CAC - E8 7F0FFDFF           - call 26309C30
26338CB1 - 83 C4 10              - add esp,10
26338CB4 - 85 C0                 - test eax,eax
26338CB6 - 7E 22                 - jle 26338CDA
26338CB8 - 8B 46 38              - mov eax,[esi+38]
26338CBB - D9 80 88000000        - fld dword ptr [eax+00000088]
26338CC1 - 8B 47 38              - mov eax,[edi+38]
26338CC4 - D9 80 88000000        - fld dword ptr [eax+00000088]
26338CCA - DFF1                  - fcomip st(0),st(1)
26338CCC - DDD8                  - fstp st(0)
26338CCE - 76 0A                 - jna 26338CDA
26338CD0 - C7 85 C8F3FFFF E7030000 - mov [ebp-00000C38],000003E7
26338CDA - 8B 46 38              - mov eax,[esi+38]
26338CDD - 83 EC 08              - sub esp,08
26338CE0 - 68 40F90925           - push 2509F940 : [056981BC]
26338CE5 - 50                    - push eax
26338CE6 - 39 00                 - cmp [eax],eax
26338CE8 - E8 430FFDFF           - call 26309C30
26338CED - 83 C4 10              - add esp,10
26338CF0 - 85 C0                 - test eax,eax
26338CF2 - 7E 15                 - jle 26338D09
26338CF4 - 8B 8D C8F3FFFF        - mov ecx,[ebp-00000C38]
26338CFA - 8B C1                 - mov eax,ecx
26338CFC - C1 E8 1F              - shr eax,1F
26338CFF - 03 C1                 - add eax,ecx
26338D01 - D1 F8                 - sar eax,1
26338D03 - 89 85 C8F3FFFF        - mov [ebp-00000C38],eax
26338D09 - B8 01000000           - mov eax,00000001
26338D0E - 83 BD C8F3FFFF 00     - cmp dword ptr [ebp-00000C38],00
26338D15 - 8B 8D C8F3FFFF        - mov ecx,[ebp-00000C38]
// address change from different version
0A8D19FB: 0F4E C8                 - cmovle ecx,eax
0A8D19FE: 89 8D C8F3FFFF          - mov [ebp-00000C38],ecx
0A8D1A04: 8B 46 38                - mov eax,[esi+38] // load char pointer
0A8D1A07: D9 80 88000000          - fld dword ptr [eax+00000088] // load health
0A8D1A0D: 51                      - push ecx
0A8D1A0E: DB 04 24                - fild dword ptr [esp]
0A8D1A11: D9 1C 24                - fstp dword ptr [esp]
0A8D1A14: D9 04 24                - fld dword ptr [esp]
0A8D1A17: 83 C4 04                - add esp,04
0A8D1A1A: DEE9                    - fsubp st(1),st(0) -- subtract damage
// ---------- INJECTING HERE ----------
0A8D1A1C: D9 98 88000000          - fstp dword ptr [eax+00000088] -- store new health
// ---------- DONE INJECTING  ----------
0A8D1A22: 8B 46 38                - mov eax,[esi+38] -- reload char pointer?
0A8D1A25: 8B C8                   - mov ecx,eax
0A8D1A27: D9 81 88000000          - fld dword ptr [ecx+00000088] // load new health
0A8D1A2D: DD 9D C8FCFFFF          - fstp qword ptr [ebp-00000338] // store on stack
0A8D1A33: F2 0F10 85 C8FCFFFF     - movsd xmm0,[ebp-00000338]
0A8D1A3B: F2 0F2C C8              - cvttsd2si ecx,xmm0
0A8D1A3F: 51                      - push ecx
0A8D1A40: DB 04 24                - fild dword ptr [esp]
0A8D1A43: D9 1C 24                - fstp dword ptr [esp]
0A8D1A46: D9 04 24                - fld dword ptr [esp]
// address change because new game run
26338D69 - 83 C4 04              - add esp,04
26338D6C - D9 98 88000000        - fstp dword ptr [eax+00000088]
26338D72 - 83 EC 08              - sub esp,08
26338D75 - 56                    - push esi
26338D76 - 53                    - push ebx
26338D77 - E8 F4120000           - call 2633A070
26338D7C - 83 C4 10              - add esp,10
26338D7F - 8B 46 2C              - mov eax,[esi+2C]
26338D82 - 83 EC 08              - sub esp,08
26338D85 - 68 C0C00925           - push 2509C0C0 : [056981BC]
26338D8A - 50                    - push eax
26338D8B - 39 00                 - cmp [eax],eax
26338D8D - E8 BE85CCDF           - call 06001350
26338D92 - 83 C4 10              - add esp,10
26338D95 - 85 C0                 - test eax,eax
26338D97 - 0F85 63000000         - jne 26338E00
26338D9D - 8B 05 98BE7505        - mov eax,[0575BE98] : [0BB9EDB0]
26338DA3 - 89 85 54F3FFFF        - mov [ebp-00000CAC],eax
26338DA9 - 8B 46 30              - mov eax,[esi+30]
26338DAC - 83 EC 0C              - sub esp,0C
26338DAF - 50                    - push eax

}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>243</ID>
          <Description>"SCRIPT: Hunger"</Description>
          <Options moHideChildren="1"/>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Stores new hunger after subtracting
}

[ENABLE]

aobscan(TEST_HUNGER2,DE E9 D9 98 90 00 00 00 8B) // should be unique
alloc(newmem,$1000)

label(code)
label(skip)
label(return)

newmem:

code:
  cmp [globals+1000],1
  jne skip
  // cheat loads max hunger to store
  inc dword ptr [globals+2000]
  fstp st(0) // throw away what we were going to store
  fld dword ptr [eax+00000094]
skip:
  fstp dword ptr [eax+00000090]
  jmp return

TEST_HUNGER2+02:
  jmp code
  nop
return:
registersymbol(TEST_HUNGER2)

[DISABLE]

TEST_HUNGER2+02:
  db D9 98 90 00 00 00

unregistersymbol(TEST_HUNGER2)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 06087FB8

06087F8B: E8 E0C1F7FF     - call 06004170
06087F90: 8B 85 14F9FFFF  - mov eax,[ebp-000006EC]
06087F96: D9 05 504E280F  - fld dword ptr [0F284E50]
06087F9C: DEC1            - faddp
06087F9E: D9 98 AC000000  - fstp dword ptr [eax+000000AC]
06087FA4: 8B 47 0C        - mov eax,[edi+0C]
06087FA7: 8B 40 38        - mov eax,[eax+38]
06087FAA: D9 80 90000000  - fld dword ptr [eax+00000090]
06087FB0: D9 87 B4000000  - fld dword ptr [edi+000000B4]
06087FB6: DEE9            - fsubp st(1),st(0)
// ---------- INJECTING HERE ----------
06087FB8: D9 98 90000000  - fstp dword ptr [eax+00000090]
// ---------- DONE INJECTING  ----------
06087FBE: 8B 47 0C        - mov eax,[edi+0C]
06087FC1: 8B 40 38        - mov eax,[eax+38]
06087FC4: D9 80 90000000  - fld dword ptr [eax+00000090]
06087FCA: D9EE            - fldz
06087FCC: DFF1            - fcomip st(0),st(1)
06087FCE: DDD8            - fstp st(0)
06087FD0: 0F86 F3010000   - jbe 060881C9
06087FD6: 8B 47 0C        - mov eax,[edi+0C]
06087FD9: 8B 40 38        - mov eax,[eax+38]
06087FDC: D9 40 5C        - fld dword ptr [eax+5C]
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>27</ID>
          <Description>"SCRIPT: Morale"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  This stores new morale after subtracting it each tick
}

[ENABLE]


aobscan(TEST_MORALE,E9 D9 98 98 00 00 00) // should be unique
alloc(newmem,$1000)

label(code)
label(skip)
label(return)

newmem:

code:
  cmp dword ptr [globals+1004],1
  jne skip
  // cheat loads max hunger instead
  inc dword ptr [globals+2004]
  fstp st(0)
  fld dword ptr [eax+0000009C]
skip:
  fstp dword ptr [eax+00000098]
  jmp return

TEST_MORALE+01:
  jmp code
  nop
return:
registersymbol(TEST_MORALE)

[DISABLE]

TEST_MORALE+01:
  db D9 98 98 00 00 00

unregistersymbol(TEST_MORALE)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 05BA8733

05BA8706: E8 65BAF7FF             - call 05B24170
05BA870B: 8B 85 14F9FFFF          - mov eax,[ebp-000006EC]
05BA8711: D9 05 C0AF2424          - fld dword ptr [2424AFC0]
05BA8717: DEC1                    - faddp
05BA8719: D9 98 A8000000          - fstp dword ptr [eax+000000A8]
05BA871F: 8B 47 0C                - mov eax,[edi+0C]
05BA8722: 8B 40 38                - mov eax,[eax+38]
05BA8725: D9 80 98000000          - fld dword ptr [eax+00000098]
05BA872B: D9 87 B8000000          - fld dword ptr [edi+000000B8]
05BA8731: DEE9                    - fsubp st(1),st(0)
// ---------- INJECTING HERE ----------
05BA8733: D9 98 98000000          - fstp dword ptr [eax+00000098]
// ---------- DONE INJECTING  ----------
05BA8739: 8B 47 0C                - mov eax,[edi+0C]
05BA873C: 8B 40 38                - mov eax,[eax+38]
05BA873F: D9 80 98000000          - fld dword ptr [eax+00000098]
05BA8745: D9EE                    - fldz
05BA8747: DFF1                    - fcomip st(0),st(1)
05BA8749: DDD8                    - fstp st(0)
05BA874B: 0F86 EA000000           - jbe 05BA883B
05BA8751: 8B 47 0C                - mov eax,[edi+0C]
05BA8754: 8B 40 38                - mov eax,[eax+38]
05BA8757: C7 80 84000000 02000000 - mov [eax+00000084],00000002
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>3</ID>
          <Description>"SCRIPT: Shop"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Loads gold when entering shop for each item, to compare price.
}

[ENABLE]

aobscan(TEST_GOLD_SHOP,8B 40 58 8B 40 38 8B 8D * * * * 3B C1 0F 8D 94) // should be unique
alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:
  mov [globals+0004],eax
  mov eax,[eax+58]
  mov [globals+0008],eax
  mov eax,[eax+38]
  jmp return

TEST_GOLD_SHOP:
  jmp code
  nop
return:
registersymbol(TEST_GOLD_SHOP)

[DISABLE]

TEST_GOLD_SHOP:
  db 8B 40 58 8B 40 38

unregistersymbol(TEST_GOLD_SHOP)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 0A90214C

0A90211F: 8B 85 E0FEFFFF  - mov eax,[ebp-00000120]
0A902125: 8B 40 70        - mov eax,[eax+70]
0A902128: 89 85 D8FEFFFF  - mov [ebp-00000128],eax
0A90212E: 8B 85 D8FEFFFF  - mov eax,[ebp-00000128]
0A902134: 83 EC 0C        - sub esp,0C
0A902137: 50              - push eax
0A902138: E8 03E826FB     - call 05B70940
0A90213D: 83 C4 10        - add esp,10
0A902140: 89 85 24FFFFFF  - mov [ebp-000000DC],eax
0A902146: 8B 05 98BE2805  - mov eax,[0528BE98]
// ---------- INJECTING HERE ----------
0A90214C: 8B 40 58        - mov eax,[eax+58] // load base pointer?
0A90214F: 8B 40 38        - mov eax,[eax+38] // load gold
// ---------- DONE INJECTING  ----------
0A902152: 8B 8D 24FFFFFF  - mov ecx,[ebp-000000DC]
0A902158: 3B C1           - cmp eax,ecx
0A90215A: 0F8D 94010000   - jnl 0A9022F4
0A902160: 8B 85 58FFFFFF  - mov eax,[ebp-000000A8]
0A902166: 83 EC 0C        - sub esp,0C
0A902169: 50              - push eax
0A90216A: 39 00           - cmp [eax],eax
0A90216C: E8 E7BC22FB     - call 05B2DE58
0A902171: 83 C4 10        - add esp,10
0A902174: 83 EC 08        - sub esp,08
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>32</ID>
          <Description>"+ SCRIPT: View Crew"</Description>
          <Color>FF0000</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  When viewing a crew member, this shows their level
}

[ENABLE]


aobscan(TEST_VIEW_CREW_LEVEL,8B 85 * F8 FF FF 8B 48 38 D9 81 D0 00 00 00 8B 48 38 D9 81 10 01 00 00 8B 40 38 D9 80 D0 00 00 00) // WARNING: is not unique, but first in my list uses it
alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:
  mov [globals+0000],ecx
  mov [globals+000C],eax
  fld dword ptr [ecx+000000D0]
  jmp return

TEST_VIEW_CREW_LEVEL+9:
  jmp code
  nop
return:
registersymbol(TEST_VIEW_CREW_LEVEL)

[DISABLE]

TEST_VIEW_CREW_LEVEL+9:
  db D9 81 D0 00 00 00

unregistersymbol(TEST_VIEW_CREW_LEVEL)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 0A8E3155

0A8E312D: 8B 8D ECFAFFFF  - mov ecx,[ebp-00000514]
0A8E3133: 89 4C 24 04     - mov [esp+04],ecx
0A8E3137: 8B 8D F0FAFFFF  - mov ecx,[ebp-00000510] // need to include
0A8E313D: 89 4C 24 08     - mov [esp+08],ecx
0A8E3141: 50              - push eax
0A8E3142: 39 00           - cmp [eax],eax
0A8E3144: E8 BFAB24FB     - call 05B2DD08
0A8E3149: 83 C4 10        - add esp,10
0A8E314C: 8B 85 A8F8FFFF  - mov eax,[ebp-00000758] // need to include this offset, damn it
0A8E3152: 8B 48 38        - mov ecx,[eax+38]
// ---------- INJECTING HERE ----------
0A8E3155: D9 81 D0000000  - fld dword ptr [ecx+000000D0]
// ---------- DONE INJECTING  ----------
0A8E315B: 8B 48 38        - mov ecx,[eax+38]
0A8E315E: D9 81 10010000  - fld dword ptr [ecx+00000110]
0A8E3164: 8B 40 38        - mov eax,[eax+38]
0A8E3167: D9 80 D0000000  - fld dword ptr [eax+000000D0]
0A8E316D: D9 05 109A4524  - fld dword ptr [24459A10]
0A8E3173: DEC9            - fmulp st(1),st(0)
0A8E3175: DEC1            - faddp
0A8E3177: DEC9            - fmulp st(1),st(0)
0A8E3179: D9 9D 74FFFFFF  - fstp dword ptr [ebp-0000008C]
0A8E317F: 83 EC 0C        - sub esp,0C
}
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>16</ID>
              <Description>"TP"</Description>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>C8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>31</ID>
              <Description>"Level"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>D0</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>254</ID>
              <Description>"XP"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>D4</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>30</ID>
              <Description>"STR"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>DC</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>24</ID>
              <Description>"VIT"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>E0</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>23</ID>
              <Description>"INT"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>E4</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>22</ID>
              <Description>"AGI"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>E8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>21</ID>
              <Description>"DEX"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>EC</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>19</ID>
              <Description>"LUCK"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>F0</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>255</ID>
          <Description>"+ Cheats"</Description>
          <Color>80000008</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>240</ID>
              <Description>"F1: God Mode  (requires SCRIPT: Damage)"</Description>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// enable/disable flag
[ENABLE]
globals+1008:
  dd 1

[DISABLE]
globals+1008:
  dd 0

</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Toggle Activation</Action>
                  <Keys>
                    <Key>112</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>241</ID>
              <Description>"F2: One Hit Kill (requires SCRIPT: Damage)"</Description>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// enable/disable flag
[ENABLE]
globals+100C:
  dd 1

[DISABLE]
globals+100C:
  dd 0

</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Toggle Activation</Action>
                  <Keys>
                    <Key>113</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>239</ID>
              <Description>"F3: Hunger (requires SCRIPT: Hunger)"</Description>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// enable/disable flag
[ENABLE]
globals+1000:
  dd 1

[DISABLE]
globals+1000:
  dd 0

</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Toggle Activation</Action>
                  <Keys>
                    <Key>114</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>242</ID>
              <Description>"F4: Morale (requires SCRIPT:  Morale)"</Description>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// enable/disable flag
[ENABLE]
globals+1004:
  dd 1

[DISABLE]
globals+1004:
  dd 0

</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Toggle Activation</Action>
                  <Keys>
                    <Key>115</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>8</ID>
              <Description>"Gold (requires SCRIPT: Shop), edit value ------&gt;"</Description>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>globals+0008</Address>
              <Offsets>
                <Offset>38</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>207</ID>
      <Description>"+ UtilCopyData "</Description>
      <Options moHideChildren="1"/>
      <Color>C0C0C0</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>GLOBALALLOC(UtilCopyData,$10000) //64k

{ You MUST call pushad, pushfd, then push an address, 0 if you don't care,
  then push the address of a memory area to use with config (TEST below).
  The second property in teh struct below (memory area to store addresses)
  is the most important, it contains a list of addresses and locations for
  the stored data.  So use the memory viewer to check on how many addresses
  you're picking up, or you can just use the structure dissector with addresses
  like these: [TEST+1004], [TEST+100C], [TEST+1014], [TEST+101C], etc.

globalalloc(TEST,$100000) // 1mb
TEST:
  dd TEST+3000 // address to start storing addresses
  dd TEST+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 100 // bytes of stack to store
  dd 200 // bytes of data to store at pushed address
  dd 0 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record first is size of individual record

// second option, memory area to store addresses, will store 8 bytes for each,
//        first 4 are the passed address, second 4 are a pointer to the stored
//        data.  This example has 500 bytes of stack, 800 bytes of address,
//        200 bytes for FXSave data, plus the standard 100 bytes for header
//        giving a total size of 1000 (hex), which means the first values
//        will be stored at TEST+2000, the second at TEST+3000, the third at
//        TEST+4000, etc.  There is room for E0 of them in e0000 bytes specified
//        so make sure TEST+1000 has enough room for E0*8 or 700 bytes

// this is code that will do the copying, the stack will be as the ESP looked
// from the pushad command

//-----------------------------------------------------------------------------
//- Test UtilCopyData
  pushad
  pushfd
  push eax // unique value to copy values on, eax already has good memory
  push TEST
  call UtilCopyData // handles removing parameters from stack
  popfd
  popad
//-----------------------------------------------------------------------------



// result format:
0000: Unique Value (argument on the stack)
0004: Count (how many times this value has been copied)
0008: PTR-&gt;Stack
000C: PTR-&gt;Stack_EBP (EBP, if in range)
0010: PTR-&gt;Memory
0014: PTR-&gt;FXSave
0018: PTR-&gt;XMM (to 009C)
001C: PTR-&gt;FPU (to 00BC)
001C-0098: RESERVED
009C: XMM0 as single float
..
00B8: XMM7 as single float
00BC: ST(0) as a single float
..
00D8: ST(7) as a single float
00DC: Flags
00E0: Registers: EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAX
0100: Original Stack
....: Memory
....: FXSAVE


}

{================================================================================
 = 1) In MemoryBrowser, right-click and set display type to 4 byte hex and
 =    change so you see 3, 6, 9 or 12 columns.  Goto address "AddressList",
 =	      Column 0: Address
 =        Column 1: TickCount
 =        Column 2: Count of this address
 = 2) Import AddressList structure if you haven't
 =    address to multiples of 256 past StackData, i.e. address would be
 =    simply "StackData" for the first address, or "StackData+500" for the
 =    sixth address.  First 4 bytes are flags, next 32 are registers (edi, esi,
 =    ebp, esp, ebx, edx, ecx, eax), then 220 bytes of stack
 ================================================================================
}
//-----------------------------------------------------------------------------
// Enable sets everything up when cheat is checked
//-----------------------------------------------------------------------------
[ENABLE]

define(C_Address,0)
define(C_AddressList,4)
define(C_TotalSizeToUse,8)
define(C_StackSize,c)
define(C_MemSize,10)
define(C_FXSaveFlag,14)
define(C_Initialized,18)
define(C_TotalSize,1c) // calculated on init
define(C_MaxOffset,20) // initialized to mem size - total size
{
  stack: EBP+this is original stack
  0000: return
  0004: PTR-&gt;Config
  0008: UniqueValue
  000C: flags
  0010: EDI
  0014: ESI
  0018: EBP
  001C: ESP
  0020: EBX
  0024: EDX
  0028: ECX
  002C: EAX
  0030: original stack
}

// values I care about (added 28) for three new pushes at the start
define(_ReturnValue,ebp+24)
define(_Config,ebp+2c)
define(_UniqueValue,ebp+30)
define(_Flags,ebp+34)
define(_EBP,ebp+40)
define(_ESP,ebp+44)
define(_FoundPointer,ebp-4)
define(_FoundIndex,ebp-8)

label(UtilCopyData_Enabled)
label(UtilCopyData_Count)
registersymbol(UtilCopyData_Enabled)
registersymbol(UtilCopyData_Count)

UtilCopyData:
  label(AlreadyInitialized)
  label(Exit)

  push 00000000 // will be ebp+24
  pushfd
  pushad

  inc [UtilCopyData_Count]

  cld // clear direction flag so we always move going upwards

  mov ebp, esp // is already stored in pushad from caller, no need to store again
  sub esp, 20 // local variables

  // enabled?
  cmp [UtilCopyData_Enabled], 00000001
  jne Exit

  // initialized?
  mov esi, [_Config]
  cmp [esi+C_Initialized], 1
  je AlreadyInitialized

  // need to initialize, calculate total size, 100 for header, stack size, mem size, FXSAVE
  mov eax, 00000100 // header
  add eax, [esi+C_StackSize] // stack size
  add eax, [esi+C_MemSize]
  cmp [esi+C_FXSaveFlag], 1
  label(INOFX)
  jne INOFX
  add eax,200 // 512 bytes for fxsave
INOFX:
  mov [esi+C_TotalSize], eax // save total size

  // clear storage memory
  xor eax, eax // zero to store
  mov edi, [esi+C_Address]
  mov ecx, [esi+C_TotalSizeToUse]
  shr ecx, 2 // storing dwords, so divide count by 4
  rep stosd

  // calc max offset to not reach past memory limit
  mov eax, [esi+C_TotalSizeToUse]
  sub eax, [esi+C_TotalSize]
  mov [esi+C_MaxOffset], eax

  mov [esi+C_Initialized], 1 // say we already initialized it

AlreadyInitialized:
  // if 0, shorthand way to exit without storing anything and keep rest of calling code identical
  mov eax, [_UniqueValue]
  test eax, eax
  jz Exit

  mov edi, [esi+C_Address] // start of data
  mov edx, 0 // offset into data
  mov ecx, 0 // index (for storing info later)

  // make sure we're not past the end
  label(Continue)
  label(Found)
Continue:
  cmp edx, [esi+C_MaxOffset]
  ja Exit
  mov ebx, [edi+edx]

  cmp ebx, eax // is address found?
  je Found

  test ebx, ebx // is it zero, empty?
  jz Found

  inc ecx
  add edx, [esi+C_TotalSize] // move on to next one
  jmp Continue

Found:
  lea edi, [edi+edx]
  mov [_FoundPointer], edi // store as local variable for later use
  mov [_ReturnValue], edi // store as return value
  mov [_FoundIndex], ecx // store as local variable for later use

  mov [edi], eax // 0000: Unique Value (argument from stack)
  inc [edi+4] // 0004: Count (how many times this value has been copied)
  mov ebx, edi
  add ebx, 100
  mov [edi+8], ebx // 0008: PTR-&gt;Stack

  // store PTR-&gt;Stack and PTR-&gt;Stack_EBP
  xor edx, edx // default will store 0, meaning EBP is outside our saved stack
  mov ecx, [_EBP] // from pushad earlier
  sub ecx, [_ESP]
  cmp ecx, [esi+C_StackSize] // does old EBP point into stack data we are saving?
  label(EBPNotInStackData)
  ja EBPNotInStackData
  mov edx, ecx
  add edx, ebx // ebx is still PTR-&gt;Stack
EBPNotInStackData:
  mov [edi+C], edx // 000C: PTR-&gt;Stack (EBP)

  // save stack data, edi and esi will need to be reloaded, ESI is [_Config], EDI is [_FoundPointer]
  add edi, 000000dc // now points to flags
  mov ecx, [esi+C_StackSize]
  add ecx, 24 // 24 extra bytes for pushad/pushfd
  lea esi, [_Flags] // address of flags from pushad/pushfd of caller
  shr ecx, 2
  rep movsd

  // save memory data
  label(NoMemory)
  mov ecx, [_Config]
  mov ecx, [ecx+C_MemSize]
  test ecx, ecx
  jz NoMemory

  mov edx, [_FoundPointer]
  mov [edx+10], edi
  mov esi, [_UniqueValue]
  shr ecx, 2
  rep movsd
NoMemory:

  // ok, now store UniqueValue/Address if specified
  mov esi, [_Config]
  mov eax, [esi+C_MemSize]
  mov edi, [esi+C_AddressList]
  test edi, edi
  label(NoAddressList)
  jz NoAddressList
  // yes we should store
  mov eax, [_FoundIndex]
  lea ebx, [edi+eax*8] // 8 bytes per address
  mov eax, [_UniqueValue]
  mov [ebx], eax // store passed unique value
  mov eax, [_FoundPointer]
  mov [ebx+4], eax // store address where we stored stuff

NoAddressList:
//-----------------------------------------------------------------------------
// Now handle floating point data
//-----------------------------------------------------------------------------
// http://asm.inightmare.org/opcodelst/index.php?op=FXSAVE
// http://www.website.masmforum.com/tutorials/fptute/fpuchap4.htm

  label(NoFXSAVE)
  mov esi, [_Config]
  cmp [esi+C_FXSaveFlag], 1
  jne NoFXSAVE
  mov edi,[_FoundPointer] // start of saved data for the passed address
  mov edx,edi
  add edi,[esi+C_TotalSize] // now at end of ALL including FXSAVE
  sub edi,200 // now where FXSAVE should go, but...
  and edi,FFFFFFF0 // MUST be 16-byte aligned or will error.  no extra room, might over-write end of memory or stack
  mov [edx+14],edi // Ptr-&gt;FXSave
  fxsave [edi]
  lea esi,[edi+20] // ST0 starts at +20, each register is 10 bytes of data, but takes up 16 bytes

  label(fpuloop)
  lea edi,[edx+bc] // start storing floats at start of data + BC
  mov [edx+1c],edi // structure pointer to FPU float values
  mov ecx,8 // ST0-ST7
fpuloop:
  mov eax,[esi+8]  // sign+exponent
  shl eax,10       // shift top bits to the end
  and eax,c0000000 // only top 2 bits (sign and top exponent bit)
  mov [edi],eax    // store top 2 bits (bits 30 and 31)

  mov eax,[esi+8]  // sign+exponent
  and eax,0000007f // bottom 7 bits of exponent
  shl eax,17       // shift to bits 23-29
  or [edi],eax     // merge with sign and top bit

  mov eax,[esi+4]  // most-significant bits of mantissa
  and eax,7fffff00 // 23 bits, REAL4 has most-significant bit assumed on, REAL10 does not
  shr eax,8        // move bits to the end
  or [edi],eax     // merge with existing result
  add edi,4
  add esi,10
  loop fpuloop

  mov ecx,8 // XMM0-XMM7
  label(xmmloop)
  lea edi,[edx+9c]
  mov [edx+18],edi // store pointer to XMM registers
  mov esi,[edx+14] // address of FXSAVE data
  add esi,a0       // first XMM register
xmmloop:
  movsd
  add esi,c // 16 bytes for each xmm register
  loop xmmloop

NoFXSAVE:
{
// result format:
0000: Unique Value (argument on the stack)
0004: Count (how many times this value has been copied)
0008: PTR-&gt;Stack
000C: PTR-&gt;Stack_EBP (EBP, if in range of copied stack data)
0010: PTR-&gt;Memory
0014: PTR-&gt;FXSave
0018: PTR-&gt;XMM (to 009C)
001C: PTR-&gt;FPU (to 00BC)
001C-0098: RESERVED
009C: XMM0 as single float
..
00B8: XMM7 as single float
00BC: ST(0) as a single float
..
00D8: ST(7) as a single float
00DC: Flags
00E0: Registers: EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAX
0100: Original Stack
....: Memory
....: FXSAVE
}


Exit:
  add esp, 20 // local variables gone

  popad
  popfd
  pop eax // return value

  ret 8

UtilCopyData+fff8: // end of our memory
UtilCopyData_Count:
  dd 0
UtilCopyData_Enabled:
  dd 1



//-----------------------------------------------------------------------------
// disable will just set flag to 0
//-----------------------------------------------------------------------------
[DISABLE]
UtilCopyData_Enabled:
  dd 0

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>209</ID>
          <Description>"UtilCopyData_Count"</Description>
          <Color>80000008</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>UtilCopyData_Count</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>210</ID>
          <Description>"UtilCopyData_Enabled"</Description>
          <Color>80000008</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>UtilCopyData_Enabled</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>236</ID>
          <Description>"TEST: HP Loss"</Description>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Where HP is stored after subtracting damage
}

[ENABLE]

aobscan(TEST_HP_LOSS,D9 98 88 00 00 00 8B 46 38 8B C8) // should be unique
alloc(newmem,$1000)

globalalloc(TEST_HP,$100000) // 1mb
TEST_HP:
  dd TEST_HP+3000 // address to start storing data
  dd TEST_HP+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 200 // bytes of stack to store
  dd 300 // bytes of data to store at pushed address
  dd 1 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
TEST_HP+1000: // zero address area to start
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

label(code)
label(return)

newmem:

code:
  //---------------------------------------------------------------------------
  // Call UtilCopyData
  pushad
  pushfd
  push eax
  push TEST_HP
  call UtilCopyData
  popfd
  popad
  //---------------------------------------------------------------------------

  fstp dword ptr [eax+00000088]
  jmp return

TEST_HP_LOSS:
  jmp code
  nop
return:
registersymbol(TEST_HP_LOSS)

[DISABLE]

TEST_HP_LOSS:
  db D9 98 88 00 00 00

unregistersymbol(TEST_HP_LOSS)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 0A8D1A1C

0A8D19FB: 0F4E C8                 - cmovle ecx,eax
0A8D19FE: 89 8D C8F3FFFF          - mov [ebp-00000C38],ecx
0A8D1A04: 8B 46 38                - mov eax,[esi+38]
0A8D1A07: D9 80 88000000          - fld dword ptr [eax+00000088]
0A8D1A0D: 51                      - push ecx
0A8D1A0E: DB 04 24                - fild dword ptr [esp]
0A8D1A11: D9 1C 24                - fstp dword ptr [esp]
0A8D1A14: D9 04 24                - fld dword ptr [esp]
0A8D1A17: 83 C4 04                - add esp,04
0A8D1A1A: DEE9                    - fsubp st(1),st(0)
// ---------- INJECTING HERE ----------
0A8D1A1C: D9 98 88000000          - fstp dword ptr [eax+00000088]
// ---------- DONE INJECTING  ----------
0A8D1A22: 8B 46 38                - mov eax,[esi+38]
0A8D1A25: 8B C8                   - mov ecx,eax
0A8D1A27: D9 81 88000000          - fld dword ptr [ecx+00000088]
0A8D1A2D: DD 9D C8FCFFFF          - fstp qword ptr [ebp-00000338]
0A8D1A33: F2 0F10 85 C8FCFFFF     - movsd xmm0,[ebp-00000338]
0A8D1A3B: F2 0F2C C8              - cvttsd2si ecx,xmm0
0A8D1A3F: 51                      - push ecx
0A8D1A40: DB 04 24                - fild dword ptr [esp]
0A8D1A43: D9 1C 24                - fstp dword ptr [esp]
0A8D1A46: D9 04 24                - fld dword ptr [esp]
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>237</ID>
          <Description>"+ Samples"</Description>
          <Options moHideChildren="1"/>
          <Color>80000008</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>216</ID>
              <Description>"TEST: AP"</Description>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{ Game   : Shadowrun.exe
  Version:
  Date   : 2014-05-03
  Author : Jason

  INJECT_AP1, INJECT_AP2 - both execute loading AP when moving the cursor around

  HOLD LCONTROL and LSHIFT down (left control and shift) while moving the
  mouse to get at least 5 AP

  EBX is a pointer, same one for friends, same one for enemies
      0014, 0020, 0028, 002c, 0030, 004c, 0050, 0054, 0094, 00A0, 00A4, 00B4
            are all null for enemies, pointer for player

  (string pointers have length at 0008, unicode bytes at 000C)
  Memory (EAX)
     08: Pointer - different for each entity, (AP at +34?   max ap?)
     58: String - Name (i.e. Verno for me, Paco for friend, Stevie J, Krund, Thistle for baddies
     5C: String - Body? Story/Paco for friend, ElfMale for me, Core/HumanMale for one, Gangers/OrkMale, Gangers/ElfFemale
     60: String - Model? npc_humanmale, pc_elfmale_o???, backer_human, generic_stat
     98: AP (int)
     9C: Health
     C0: Pointer - 30 is null for non-player non-friends, 003C is null for non-player, 0044 is null for non-player
     C4: Pointer - 0010 is same pointer for player and friend, 0014 is same pointer for player and friend
                 0010: "Player.xml", "Guard - Seek And Destroy AttitudeCautious.xml"
                 0014: "Player", "Guard - Seek And Destroy"
                      Maybe this is who controls and we can reliably go off 'Player'?
     DC: String - Faction?  ("shadowrunners" for me and friend, "gangers" for bad guys, 'hellhound')
     E0: Pointer - same for friend team, same for enemies (0100 bytes) - might be valuable
XXXXXE8: 0 for enemies, pointer for friend team (AP USE ONLY?, opposite this last time, pointer for player and friend, pointer for enemy)
XXXXXF8: 0 for enemies, pointer for friend team (NOT TRUE, opposite this last time, pointer for player and friend, pointer for enemy)
XXXXXFC: 0 for enemies, pointer for friend team (NOT TRUE, sometimes 0 for friend and player), last time opposite, 0 for player and friend, pointer for enemies
XXXXX108: pointer for friend, 0 for player and enemies (AP USE ONLY?, 0 for friend and pointer for 1 enemy once)
     120: 0 for player, pointer for enemies
     124: 0 for player, pointer for enemies
     128: 0 for player, pointer for enemies
     12C: 0 for player, pointer for enemies
     134: 0 for player, pointer for enemies
     1B4: 0 for player, 1 for enemies
     1F8: 0100 for player, 0 for enemies
     210: 0 for player, 0100 for enemies
     230: Seems to be flag bytes, 00010000 for player/friend, 01000000 for enemies, but I think player was 00010100 once




     [ESP+14], [ESP+18], and [ESP+1C] seem to all be 0 when switching characters
     [ESP+20], [ESP+24], and [ESP+28] seem to all be 0 for the previous character selected
     ECX and EDX can be null (0) for non-player team
     ESI seems to be pointer (EAX) for player team, but 2(ap?) for others
}

[ENABLE]

globalalloc(TEST_AP,$100000) // 1mb
TEST_AP:
  dd TEST_AP+3000 // address to start storing data
  dd TEST_AP+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 200 // bytes of stack to store
  dd 300 // bytes of data to store at pushed address
  dd 1 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
TEST_AP+1000: // zero address area to start
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

aobscan(INJECT_AP1,8B 80 98 00 00 00 85 C0 7E) // should be unique
alloc(newmem,$1000)

label(code)
label(skip)
label(return)

newmem:

code:
//-----------------------------------------------------------------------------
// Here is the code you will inject, push registers, push flags, push stack,
// push memory address, and finally push pointer to structure with settings,
// then call UtilCopyData.  Afterwards pop flags and registers and you are
// back where you started
//
label(skiputilcopydata)
  push 00000000 // room for our count, will make stack offsets off by 4
  pushad
  pushfd

  cmp eax,esi // test1: values should be the same
  jne skiputilcopydata

  test ecx,ecx // test2: non-null ecx and edx
  jz skiputilcopydata
  test edx,edx
  jz skiputilcopydata

  xor ecx,ecx // will have count
//  cmp dword ptr [eax+e8],1
//  adc ecx,0
//  cmp dword ptr [eax+f8],1
//  adc ecx,0
//  cmp dword ptr [eax+fc],1
//  adc ecx,0
  cmp dword ptr [eax+120],1
  adc ecx,0
  cmp dword ptr [eax+124],1
  adc ecx,0
  cmp dword ptr [eax+128],1
  adc ecx,0
  cmp dword ptr [eax+12c],1
  adc ecx,0
  cmp dword ptr [eax+134],1
  adc ecx,0
  mov [esp+24],ecx

  push eax
  push TEST_AP
  call UtilCopyData

skiputilcopydata:
  popfd
  popad
  add esp,4 // our count
//-----------------------------------------------------------------------------

skip:
  mov eax,[eax+00000098]
  jmp return

INJECT_AP1:
  jmp code
  nop
return:
registersymbol(INJECT_AP1)


[DISABLE]

INJECT_AP1:
  db 8B 80 98 00 00 00

unregistersymbol(INJECT_AP1)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 1A5BC251

1A5BC23C: 8B 78 24        - mov edi,[eax+24]
1A5BC23F: 8B C7           - mov eax,edi
1A5BC241: 8D 65 FC        - lea esp,[ebp-04]
1A5BC244: 5F              - pop edi
1A5BC245: C9              - leave
1A5BC246: C3              - ret
1A5BC247: 00 55 8B        - add [ebp-75],dl
1A5BC24A: EC              - in al,dx
1A5BC24B: 83 EC 08        - sub esp,08
1A5BC24E: 8B 45 08        - mov eax,[ebp+08]
// ---------- INJECTING HERE ----------
1A5BC251: 8B 80 98000000  - mov eax,[eax+00000098]
// ---------- DONE INJECTING  ----------
1A5BC257: 85 C0           - test eax,eax
1A5BC259: 7E 18           - jle 1A5BC273
1A5BC25B: 83 EC 08        - sub esp,08
1A5BC25E: 6A 06           - push 06
1A5BC260: FF 75 08        - push [ebp+08]
1A5BC263: E8 10E80400     - call 1A60AA78
1A5BC268: 83 C4 10        - add esp,10
1A5BC26B: 85 C0           - test eax,eax
1A5BC26D: 74 04           - je 1A5BC273
1A5BC26F: 33 C0           - xor eax,eax
}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>234</ID>
              <Description>"TEST: AP Use"</Description>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{ Game   : Shadowrun.exe
  Version: 
  Date   : 2014-05-04
  Author : Jason

  This stores the new AP value after being used.
}

globalalloc(TEST_APUSE,$100000) // 1mb
TEST_APUSE:
  dd TEST_APUSE+3000 // address to start storing data
  dd TEST_APUSE+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 200 // bytes of stack to store
  dd 300 // bytes of data to store at pushed address
  dd 1 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
TEST_APUSE+1000: // zero address area to start
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

[ENABLE]

aobscan(INJECT_APUSE,89 88 98 00 00 00 C9) // should be unique
alloc(newmem,$1000)

label(code)
label(isEnemy)
label(isFriend)
label(done)
label(return)

newmem:

code:
//-----------------------------------------------------------------------------
  pushad
  pushfd

  push eax // to use pointer later
  push eax // argument
  push TEST_APUSE
  call UtilCopyData

  label(ucd_notfound)
  pop esi
  test eax,eax
  jz ucd_notfound
  // 0020: 120 is 0 for player
  // 0024: 124 is 0 for player
  // 0028: 128 is 0 for player
  // 002C: 12C is 0 for player
  // 0030: 134 is 0 for player
  // XXXX: 1B4 is 0 for player (invalid)
  // 0038: 1F8 is 100 for  player
  // 003C: 210 is 0 for player
  // XXXX: 230: 0001XXXX for player (always set) - maybe flag for active team?
  // XXXX: 230: 0100XXXX for enemy (always clear)
  // 0034: globals_IsFriend result

  cmp dword ptr [esi+120],1
  adc [eax+20],0

  cmp dword ptr [esi+124],1
  adc [eax+24],0

  cmp dword ptr [esi+128],1
  adc [eax+28],0

  cmp dword ptr [esi+12c],1
  adc [eax+2c],0

  cmp dword ptr [esi+134],1
  adc [eax+30],0

  cmp dword ptr [esi+1b4],1 // DOESN'T WORK
  adc [eax+34],0

{  label(s38)
  cmp dword ptr [esi+1f8],0100
  jne s38
  inc dword ptr [eax+38]
  s38:}
  mov ebx,eax
  push esi
  call globals_IsFriend
  mov [ebx+38],eax
  mov eax,ebx

  cmp dword ptr [esi+210],1
  adc [eax+3c],0


{  label(s230_1) // DOESN'T WORK - set for all - maybe if on active team?
  mov ebx,[esi+230]
  and ebx,FFFF0000
  cmp ebx,00010000
  jne s230_1
  inc dword ptr [eax+40]
  s230_1:

  label(s230_2) // DOESN'T WORK, clear for all
  mov ebx,[esi+230]
  and ebx,FFFF0000
  cmp ebx,01000000
  jne s230_2
  inc dword ptr [eax+44]
  s230_2:}


ucd_notfound:

  popfd
  popad
//-----------------------------------------------------------------------------
  pushad

  xor ecx,ecx
  cmp dword ptr [eax+120],1
  adc ecx,0
  cmp dword ptr [eax+124],1
  adc ecx,0
  cmp dword ptr [eax+128],1
  adc ecx,0
  cmp dword ptr [eax+12c],1
  adc ecx,0
  cmp dword ptr [eax+134],1
  adc ecx,0
  cmp ecx,4 // should be 5 for player and friend, 0 for enemy
  jae isFriend
  cmp ecx,1
  jbe isEnemy
  // not sure what it is, just do default
  popad
  jmp done

isFriend:
  label(giveFriendlyAP)
  label(skipGiveFriendlyAP)
  cmp dword ptr [globals+0004],1 // bAlwaysFriendlyAP
  je giveFriendlyAP
  cmp dword ptr [globals+0008],1 // bShiftGivesFriendlyAP
  jne skipGiveFriendlyAP

  // check for left shift pressed to give ap
  push 000000A0 // VK_LSHIFT http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
  call GetAsyncKeyState
  test eax,8000
  jz skipGiveFriendlyAP

giveFriendlyAP:
  popad
  mov ecx,[eax+00000098]
  cmp ecx,#10
  ja done
  mov ecx,#10
  jmp done

skipGiveFriendlyAP:
  popad
  jmp done

isEnemy:
  label(skip_bNoEnemyAP)
  cmp dword ptr [globals+0000],1 // bNoEnemyAP
  jne skip_bNoEnemyAP
  popad
  xor ecx,ecx
  jmp done
skip_bNoEnemyAP:
  popad
  jmp done

done:
  mov [eax+00000098],ecx
  jmp return

INJECT_APUSE:
  jmp code
  nop
return:
registersymbol(INJECT_APUSE)

[DISABLE]

INJECT_APUSE:
  db 89 88 98 00 00 00

unregistersymbol(INJECT_APUSE)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 1D0520C2

1D0520A8: C3               - ret 
1D0520A9: 00 00            - add [eax],al
1D0520AB: 00 00            - add [eax],al
1D0520AD: 00 00            - add [eax],al
1D0520AF: 00 55 8B         - add [ebp-75],dl
1D0520B2: EC               - in al,dx
1D0520B3: 83 EC 08         - sub esp,08
1D0520B6: 8B 45 08         - mov eax,[ebp+08]
1D0520B9: 8B 88 98000000   - mov ecx,[eax+00000098]
1D0520BF: 03 4D 0C         - add ecx,[ebp+0C]
// ---------- INJECTING HERE ----------
1D0520C2: 89 88 98000000   - mov [eax+00000098],ecx
// ---------- DONE INJECTING  ----------
1D0520C8: C9               - leave 
1D0520C9: C3               - ret 
1D0520CA: 00 00            - add [eax],al
1D0520CC: 00 00            - add [eax],al
1D0520CE: 00 00            - add [eax],al
1D0520D0: 55               - push ebp
1D0520D1: 8B EC            - mov ebp,esp
1D0520D3: 56               - push esi
1D0520D4: 83 EC 04         - sub esp,04
1D0520D7: 83 7D 10 00      - cmp dword ptr [ebp+10],00
}
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>215</ID>
              <Description>"TEST: Sample"</Description>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{ Game   : &lt;NONE&gt;
  Version:
  Date   : 2014-05-03
  Author : Jason

  This sample code used to test the floating point section of UtilCopyData.
  Enabling or disabling it will create a thread to run the code and call
  UtilCopyData and you can use the structure dissector to see what it is
  like.
}

[ENABLE]

globalalloc(TEST_SAMPLE,$100000) // 1mb
TEST_SAMPLE:
  dd TEST_SAMPLE+3000 // address to start storing data
  dd TEST_SAMPLE+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 100 // bytes of stack to store
  dd 300 // bytes of data to store at pushed address
  dd 1 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

alloc(newmem,$1000)

label(code)

newmem:
  dd (float)100
  dd (float)111
  dd (float)122
  dd (float)133
  dd (float)144
  dd (float)155
  dd (float)166
  dd (float)177

code:
  pushad

  fld [newmem+1c] // 177 will go in ST(7)
  fld [newmem+18] // 166 will go in ST(6)
  fld [newmem+14] // 155 will go in ST(5)
  fld [newmem+10] // 144 will go in ST(4)
  fld [newmem+0c] // 133 will go in ST(3)
  fld [newmem+08] // 122 will go in ST(2)
  fld [newmem+04] // 111 will go in ST(1)
  fld [newmem+00] // 100 will go in ST(0)

  movss xmm0,[newmem+00] // 100 will go in xmm0
  movss xmm1,[newmem+04] // 111 will go in xmm1
  movss xmm2,[newmem+08] // 122 will go in xmm2
  movss xmm3,[newmem+0c] // 133 will go in xmm3
  movss xmm4,[newmem+10] // 144 will go in xmm4
  movss xmm5,[newmem+14] // 155 will go in xmm5
  movss xmm6,[newmem+18] // 166 will go in xmm6
  movss xmm7,[newmem+1c] // 177 will go in xmm7

  mov eax,11111111
  mov ebx,22222222
  mov ecx,33333333
  mov edx,44444444
  mov esi,55555555
  mov edi,66666666
  mov ebp,77777777

  // so we have something to look at on the stack
  sub esp,80 // room
  push eax
  push ebx
  push ecx
  push edx
  push esi
  push edi
  push ebp
  pushfd
  sub esp,80 // room
  stc // set carry flag

//-----------------------------------------------------------------------------
// Here is the code you will inject, push registers, push flags, push stack,
// push memory address, and finally push pointer to structure with settings,
// then call UtilCopyData.  Afterwards pop flags and registers and you are
// back where you started
//
  pushad
  pushfd

  push newmem // memory is what we have here, data and code
  push TEST_SAMPLE //
  call UtilCopyData

  popfd
  popad
//-----------------------------------------------------------------------------

  add esp,120 // 80+80 we subtracted and 7 registers + flags we pushed
  popad
  ret

CREATETHREAD(code)

[DISABLE]


</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>41</ID>
              <Description>"TEST: ManaUse"</Description>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{ Game   : Reckoning.exe
  Version: 
  Date   : 2014-04-19
  Author : Jason

  This is what changes mana when you use it
}

[ENABLE]

aobscanmodule(INJECT_ManaUse,Reckoning.exe,89 8D 84 00 00 00 EB) // should be unique

globalalloc(TEST_MANAUSE,$100000) // 1mb
TEST:
  dd TEST_MANAUSE+3000 // address to start storing data
  dd TEST_MANAUSE+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 300 // bytes of stack to store
  dd 400 // bytes of data to store at pushed address
  dd 0 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0


alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:

//-----------------------------------------------------------------------------
  pushad
  pushfd
  push ebp
  push TEST
  call UtilCopyData
  popfd
  popad
//-----------------------------------------------------------------------------

  mov [ebp+00000084],ecx
  jmp return

INJECT_ManaUse:
  jmp code
  nop
return:
registersymbol(INJECT_ManaUse)

[DISABLE]

INJECT_ManaUse:
  db 89 8D 84 00 00 00

unregistersymbol(INJECT_ManaUse)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: "Reckoning.exe"+39AFC1

"Reckoning.exe"+39AFA9: 5E                      - pop esi
"Reckoning.exe"+39AFAA: 5D                      - pop ebp
"Reckoning.exe"+39AFAB: 83 C4 0C                - add esp,0C
"Reckoning.exe"+39AFAE: C2 0400                 - ret 0004
"Reckoning.exe"+39AFB1: 8B 8D 84000000          - mov ecx,[ebp+00000084]
"Reckoning.exe"+39AFB7: 8B D0                   - mov edx,eax
"Reckoning.exe"+39AFB9: F7 DA                   - neg edx
"Reckoning.exe"+39AFBB: 3B CA                   - cmp ecx,edx
"Reckoning.exe"+39AFBD: 76 0A                   - jna Reckoning.exe+39AFC9
"Reckoning.exe"+39AFBF: 03 C8                   - add ecx,eax
// ---------- INJECTING HERE ----------
"Reckoning.exe"+39AFC1: 89 8D 84000000          - mov [ebp+00000084],ecx
// ---------- DONE INJECTING  ----------
"Reckoning.exe"+39AFC7: EB 0A                   - jmp Reckoning.exe+39AFD3
"Reckoning.exe"+39AFC9: C7 85 84000000 00000000 - mov [ebp+00000084],00000000
"Reckoning.exe"+39AFD3: 8B 45 7C                - mov eax,[ebp+7C]
"Reckoning.exe"+39AFD6: 33 C9                   - xor ecx,ecx
"Reckoning.exe"+39AFD8: 85 C0                   - test eax,eax
"Reckoning.exe"+39AFDA: 0F9C C1                 - setl cl
"Reckoning.exe"+39AFDD: 49                      - dec ecx
"Reckoning.exe"+39AFDE: 23 C8                   - and ecx,eax
"Reckoning.exe"+39AFE0: 39 8D 84000000          - cmp [ebp+00000084],ecx
"Reckoning.exe"+39AFE6: 73 10                   - jae Reckoning.exe+39AFF8
}
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>214</ID>
              <Description>"TEST: Backpack Size"</Description>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{ Game   : Reckoning.exe
  Version: Steam
  Date   : 2014-04-20
  Author : Jason

  This code accesses A LOT of addresses, including one that is the maximum
  number of items you can carry :)
}

[ENABLE]

aobscanmodule(INJECT_TEST_BACKPACKSIZE,Reckoning.exe,8B 51 0C 8B F9) // should be unique

globalalloc(TEST_BP,$100000) // 1mb
TEST_BP:
  dd TEST_BP+3000 // address to start storing data
  dd TEST_BP+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 300 // bytes of stack to store
  dd 400 // bytes of data to store at pushed address
  dd 0 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

alloc(newmem,$1000)

label(code)
label(skip)
label(doIt)
label(return)

newmem:
  label(matchSize)
  registersymbol(matchSize)
  matchSize:
    dd #500

  label(pBackpackBase)
  registersymbol(pBackpackBase)
  pBackpackBase:
    dd 0


code:

//-----------------------------------------------------------------------------
  pushad
  pushfd
  mov eax,[matchSize]
  test eax,eax
  jz doIt
  cmp eax,[ecx+0C]
  jne skip
doIt:

  // test1: [ESP+14] should return to 473F17
  mov eax,[ESP+38] // add 24 for pushad (20) and pushfd (04)
  cmp eax,00473F17
  jne skip

  // tes2: [ESP+2C] should be 0
  mov eax,[ESP+50] // add 24 for pushad (20) and pushfd (04)
  test eax,eax
  jnz skip

  // [esp+4C] seems to be 1000 (3E8) for backpack, 0 1 or pointer for others
  mov eax,[esp+70]
  cmp eax,#1000
  jne skip
  // only 2 left, backpack (500) and something that is 300, don't know what, [ESP+44] solves it

  // [esp+44] seems to be 40 for backpack 16 for others
  mov eax,[esp+68]
  cmp eax,#40
  jne skip

  // eax looks to be 3 for backpack, 9 for others
  // [esp+34] seems to be 5 for backpack, 2 for others
  // [esp+48] seems to be 3 for backpack, 0 1 or 5 for others

  mov [pBackpackBase],ecx
  push ecx
  push TEST_BP
  call UtilCopyData
skip:
  popfd
  popad
//-----------------------------------------------------------------------------

  mov edx,[ecx+0C]
  mov edi,ecx
  jmp return

INJECT_TEST_BACKPACKSIZE:
  jmp code
return:
registersymbol(INJECT_TEST_BACKPACKSIZE)

[DISABLE]

INJECT_TEST_BACKPACKSIZE:
  db 8B 51 0C 8B F9

unregistersymbol(INJECT_TEST_BACKPACKSIZE)
unregistersymbol(matchSize)
unregistersymbol(pBackpackBase)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: "Reckoning.exe"+4F651B

"Reckoning.exe"+4F6501: 8B 55 0C           - mov edx,[ebp+0C]
"Reckoning.exe"+4F6504: 8B CA              - mov ecx,edx
"Reckoning.exe"+4F6506: C1 E9 03           - shr ecx,03
"Reckoning.exe"+4F6509: 33 CA              - xor ecx,edx
"Reckoning.exe"+4F650B: C1 E9 05           - shr ecx,05
"Reckoning.exe"+4F650E: 33 CA              - xor ecx,edx
"Reckoning.exe"+4F6510: 23 48 10           - and ecx,[eax+10]
"Reckoning.exe"+4F6513: C1 E1 04           - shl ecx,04
"Reckoning.exe"+4F6516: 03 CE              - add ecx,esi
"Reckoning.exe"+4F6518: 8B 41 08           - mov eax,[ecx+08]
// ---------- INJECTING HERE ----------
"Reckoning.exe"+4F651B: 8B 51 0C           - mov edx,[ecx+0C]
"Reckoning.exe"+4F651E: 8B F9              - mov edi,ecx
// ---------- DONE INJECTING  ----------
"Reckoning.exe"+4F6520: 2B FE              - sub edi,esi
"Reckoning.exe"+4F6522: C1 FF 04           - sar edi,04
"Reckoning.exe"+4F6525: 8D 3C BD 04000000  - lea edi,[edi*4+00000004]
"Reckoning.exe"+4F652C: 8B DE              - mov ebx,esi
"Reckoning.exe"+4F652E: 2B DF              - sub ebx,edi
"Reckoning.exe"+4F6530: 8B 3B              - mov edi,[ebx]
"Reckoning.exe"+4F6532: 8B 19              - mov ebx,[ecx]
"Reckoning.exe"+4F6534: 3B 5D 08           - cmp ebx,[ebp+08]
"Reckoning.exe"+4F6537: 75 08              - jne Reckoning.exe+4F6541
"Reckoning.exe"+4F6539: 8B 49 04           - mov ecx,[ecx+04]


For backpack, [ESP+14] is 473F17
Reckoning.exe+73EE0 - 8B 44 24 1C           - mov eax,[esp+1C]
Reckoning.exe+73EE4 - 8B 54 24 34           - mov edx,[esp+34]
Reckoning.exe+73EE8 - C1 EB 08              - shr ebx,08
Reckoning.exe+73EEB - 83 C1 04              - add ecx,04
Reckoning.exe+73EEE - 81 E3 FFFF0100        - and ebx,0001FFFF : [00000000]
Reckoning.exe+73EF4 - 8D 1C D8              - lea ebx,[eax+ebx*8]
Reckoning.exe+73EF7 - 8B 03                 - mov eax,[ebx]
Reckoning.exe+73EF9 - 89 4C 24 10           - mov [esp+10],ecx
Reckoning.exe+73EFD - 8B 4B 04              - mov ecx,[ebx+04]
Reckoning.exe+73F00 - 8B 5A 0C              - mov ebx,[edx+0C]
Reckoning.exe+73F03 - 51                    - push ecx
Reckoning.exe+73F04 - 89 44 24 7C           - mov [esp+7C],eax
Reckoning.exe+73F08 - 50                    - push eax
Reckoning.exe+73F09 - 8B C3                 - mov eax,ebx
Reckoning.exe+73F0B - 89 8C 24 84000000     - mov [esp+00000084],ecx
Reckoning.exe+73F12 - E8 D9254800           - call Reckoning.exe+4F64F0
Reckoning.exe+73F17 - 89 44 24 28           - mov [esp+28],eax-----------------------return with backpack size
Reckoning.exe+73F1B - 89 54 24 2C           - mov [esp+2C],edx
Reckoning.exe+73F1F - A8 0F                 - test al,0F
Reckoning.exe+73F21 - 74 1F                 - je Reckoning.exe+73F42
Reckoning.exe+73F23 - 8B 4B 0C              - mov ecx,[ebx+0C]
Reckoning.exe+73F26 - 89 0F                 - mov [edi],ecx
Reckoning.exe+73F28 - 8B 4C 24 34           - mov ecx,[esp+34]
Reckoning.exe+73F2C - 8B 49 0C              - mov ecx,[ecx+0C]
Reckoning.exe+73F2F - 89 4F 04              - mov [edi+04],ecx
Reckoning.exe+73F32 - 89 47 08              - mov [edi+08],eax
Reckoning.exe+73F35 - 89 57 0C              - mov [edi+0C],edx
Reckoning.exe+73F38 - 89 06                 - mov [esi],eax
Reckoning.exe+73F3A - 89 56 04              - mov [esi+04],edx
Reckoning.exe+73F3D - E9 4BE9FFFF           - jmp Reckoning.exe+7288D
Reckoning.exe+73F42 - C7 47 04 00000000     - mov [edi+04],00000000
Reckoning.exe+73F49 - 8B 43 08              - mov eax,[ebx+08]
Reckoning.exe+73F4C - 85 C0                 - test eax,eax
Reckoning.exe+73F4E - 74 15                 - je Reckoning.exe+73F65
Reckoning.exe+73F50 - 8B 7D 08              - mov edi,[ebp+08]
Reckoning.exe+73F53 - 57                    - push edi
Reckoning.exe+73F54 - B9 01000000           - mov ecx,00000001
Reckoning.exe+73F59 - E8 32A14800           - call Reckoning.exe+4FE090
Reckoning.exe+73F5E - 83 C4 04              - add esp,04
Reckoning.exe+73F61 - A8 0F                 - test al,0F
Reckoning.exe+73F63 - 75 0B                 - jne Reckoning.exe+73F70

}
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>235</ID>
              <Description>"TEST: UpgradePoints"</Description>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{ Game   : Reckoning.exe
  Version: Steam
  Date   : 2014-04-19
  Author : Jason

  When upgrading skills and abilities, this reads the skill points remaining.
  DANGEROUS!  It seems to also be called for other things, I don't know what.
  When backing out of the levelling up process it is called several times for
  instance.  The cheat should only be enabled when looking at the skill
  and ability level up screens.

  Also used to load XP.
}

[ENABLE]

aobscanmodule(INJECT_READ_SKILL_POINTS_REMAINING,Reckoning.exe,8B 50 18 89 53 18) // should be unique

globalalloc(TEST_UP,$100000) // 1mb
TEST_UP:
  dd TEST_UP+3000 // address to start storing data
  dd TEST_UP+1000 // memory area to store addresses, make sure there is enough room by dividing total memory by total size and multiplying by 4, set to 0 to not store
  dd d0000 // total memory size to use, our allocated size minus the start data offset
  dd 400 // bytes of stack to store
  dd 300 // bytes of data to store at pushed address
  dd 0 // flag to store FXSave data or not
  dd 0 // initialized?  first call will fill remaining data, so reserve 100 bytes
  dd 0 // initialization data will be stored here and on to TEST+100, so don't use it!  first is size of individual record
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
  dd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

alloc(newmem,$1000)

label(code)
label(doIt)
label(skip)
label(return)

newmem:
  label(matchUP)
  registersymbol(matchUP)
  matchUP:
    dd #1

  label(pUPBase)
  registersymbol(pUPBase)
  pUPBase:
    dd 0

code:
//-----------------------------------------------------------------------------
  pushad
  pushfd
  mov ebx,[matchUP]
  test ebx,ebx
  jz doIt
  cmp ebx,[eax+18]
  jne skip

doIt:
  // test 1: [esp+c8] is pointer
  mov ebx,[esp+ec] // +24 for pushad/pushfd
  cmp ebx,400000
  jb skip

  // test 2: [esp+f4] is pointer
  mov ebx,[esp+118]
  cmp ebx,400000
  jb skip

  // test 3: [eax+4] is pointer
  cmp dword ptr [eax+4],400000
  jb skip

  // test 4: [eax+14] is C0000000 (-2.0)
  cmp dword ptr [eax+14],c0000000
  jne skip

  mov [pUPBase],eax
  push eax
  push TEST_UP
  call UtilCopyData


skip:
  popfd
  popad
//-----------------------------------------------------------------------------

  mov edx,[eax+18]
  mov [ebx+18],edx
  jmp return

INJECT_READ_SKILL_POINTS_REMAINING:
  jmp code
  nop
return:
registersymbol(INJECT_READ_SKILL_POINTS_REMAINING)

[DISABLE]

INJECT_READ_SKILL_POINTS_REMAINING:
  db 8B 50 18 89 53 18

unregistersymbol(INJECT_READ_SKILL_POINTS_REMAINING)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: "Reckoning.exe"+8C76E

"Reckoning.exe"+8C754: 85 C9           - test ecx,ecx
"Reckoning.exe"+8C756: 75 16           - jne Reckoning.exe+8C76E
"Reckoning.exe"+8C758: 8D 70 08        - lea esi,[eax+08]
"Reckoning.exe"+8C75B: 8D 43 08        - lea eax,[ebx+08]
"Reckoning.exe"+8C75E: E8 1D3E4500     - call Reckoning.exe+4E0580
"Reckoning.exe"+8C763: 5F              - pop edi
"Reckoning.exe"+8C764: 5E              - pop esi
"Reckoning.exe"+8C765: B8 01000000     - mov eax,00000001
"Reckoning.exe"+8C76A: 5B              - pop ebx
"Reckoning.exe"+8C76B: C2 0400         - ret 0004
// ---------- INJECTING HERE ----------
"Reckoning.exe"+8C76E: 8B 50 18        - mov edx,[eax+18]
"Reckoning.exe"+8C771: 89 53 18        - mov [ebx+18],edx
// ---------- DONE INJECTING  ----------
"Reckoning.exe"+8C774: 8B 40 1C        - mov eax,[eax+1C]
"Reckoning.exe"+8C777: 5F              - pop edi
"Reckoning.exe"+8C778: 89 43 1C        - mov [ebx+1C],eax
"Reckoning.exe"+8C77B: 5E              - pop esi
"Reckoning.exe"+8C77C: B8 01000000     - mov eax,00000001
"Reckoning.exe"+8C781: 5B              - pop ebx
"Reckoning.exe"+8C782: C2 0400         - ret 0004
"Reckoning.exe"+8C785: CC              - int 3 
"Reckoning.exe"+8C786: CC              - int 3 
"Reckoning.exe"+8C787: CC              - int 3 
}
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>251</ID>
      <Description>"+ Pixel Piracy Tests"</Description>
      <Options moHideChildren="1"/>
      <Color>C0C0C0</Color>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>25</ID>
          <Description>"TEST: Hunger"</Description>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  Stores new hunger every frame
}

[ENABLE]

aobscan(TEST_HUNGER,D9 98 90 00 00 00 E9) // should be unique
alloc(newmem,$1000)

label(code)
label(skip)
label(return)

newmem:

code:
  cmp [globals+1000],1
  jne skip
  // cheat loads max hunger to store
  inc dword ptr [globals+2000]
  fstp st(0) // throw away what we were going to store
  fld dword ptr [eax+00000094]
skip:
  fstp dword ptr [eax+00000090]
  jmp return

TEST_HUNGER:
  jmp code
  nop
return:
registersymbol(TEST_HUNGER)

[DISABLE]

TEST_HUNGER:
  db D9 98 90 00 00 00

unregistersymbol(TEST_HUNGER)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 05BA7FC1

05BA7FA0: 50              - push eax
05BA7FA1: E8 BA9FF6FF     - call 05B11F60
05BA7FA6: 83 C4 10        - add esp,10
05BA7FA9: 85 C0           - test eax,eax
05BA7FAB: 74 1F           - je 05BA7FCC
05BA7FAD: 8B 47 0C        - mov eax,[edi+0C]
05BA7FB0: 8B 40 38        - mov eax,[eax+38]
05BA7FB3: D9 80 90000000  - fld dword ptr [eax+00000090]
05BA7FB9: D9 05 D8AE2424  - fld dword ptr [2424AED8]
05BA7FBF: DEE9            - fsubp st(1),st(0)
// ---------- INJECTING HERE ----------
05BA7FC1: D9 98 90000000  - fstp dword ptr [eax+00000090]
// ---------- DONE INJECTING  ----------
05BA7FC7: E9 DA000000     - jmp 05BA80A6
05BA7FCC: D9 05 E0AE2424  - fld dword ptr [2424AEE0]
05BA7FD2: D9 9F B4000000  - fstp dword ptr [edi+000000B4]
05BA7FD8: 8B 05 E0BD2805  - mov eax,[0528BDE0]
05BA7FDE: 8B 40 38        - mov eax,[eax+38]
05BA7FE1: 83 EC 08        - sub esp,08
05BA7FE4: 68 D0D87513     - push 1375D8D0
05BA7FE9: 50              - push eax
05BA7FEA: 39 00           - cmp [eax],eax
05BA7FEC: E8 2F3C0000     - call 05BABC20
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>1</ID>
          <Description>"TEST: HP (Char Screen)"</Description>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{ Game   : PixelPiracy.exe
  Version:
  Date   : 2014-06-21
  Author : Jason

  HP read when viewing character under Crew
}

[ENABLE]

aobscan(TEST_HP_CHAR,09 00 00 8D 44 88 10 8B 00 8B 40 38 D9 80 88 00 00 00) // should be unique
alloc(newmem,$1000)

label(code)
label(return)

newmem:

code:
  mov [globals+0000],eax
  fld dword ptr [eax+00000088]
  jmp return

TEST_HP_CHAR+0C:
  jmp code
  nop
return:
registersymbol(TEST_HP_CHAR)

[DISABLE]

TEST_HP_CHAR+0C:
  db D9 80 88 00 00 00

unregistersymbol(TEST_HP_CHAR)
dealloc(newmem)

{
// ORIGINAL CODE - INJECTION POINT: 0A8E1BB1

0A8E1B8F: 83 C4 10        - add esp,10
0A8E1B92: 8B C8           - mov ecx,eax
0A8E1B94: 8B 85 24FEFFFF  - mov eax,[ebp-000001DC]
0A8E1B9A: 39 00           - cmp [eax],eax
0A8E1B9C: 8B 40 08        - mov eax,[eax+08]
0A8E1B9F: 39 48 0C        - cmp [eax+0C],ecx
0A8E1BA2: 0F86 ED090000   - jbe 0A8E2595
0A8E1BA8: 8D 44 88 10     - lea eax,[eax+ecx*4+10]
0A8E1BAC: 8B 00           - mov eax,[eax]
0A8E1BAE: 8B 40 38        - mov eax,[eax+38]
// ---------- INJECTING HERE ----------
0A8E1BB1: D9 80 88000000  - fld dword ptr [eax+00000088]
// ---------- DONE INJECTING  ----------
0A8E1BB7: DD 9D 28FEFFFF  - fstp qword ptr [ebp-000001D8]
0A8E1BBD: 8B 05 98BE2805  - mov eax,[0528BE98]
0A8E1BC3: 8B 40 58        - mov eax,[eax+58]
0A8E1BC6: 8B 40 18        - mov eax,[eax+18]
0A8E1BC9: 89 85 34FEFFFF  - mov [ebp-000001CC],eax
0A8E1BCF: 83 EC 08        - sub esp,08
0A8E1BD2: FF B5 B8FEFFFF  - push [ebp-00000148]
0A8E1BD8: 57              - push edi
0A8E1BD9: 39 3F           - cmp [edi],edi
0A8E1BDB: E8 0865FBFF     - call 0A8980E8
}
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>6</ID>
          <Description>"pGoldParent (pGoldBase at +58)"</Description>
          <ShowAsHex>1</ShowAsHex>
          <Color>80000008</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>globals+0004</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>7</ID>
          <Description>"pGoldBase (gold is int at +38)"</Description>
          <ShowAsHex>1</ShowAsHex>
          <Color>80000008</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>globals+0008</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>5</ID>
          <Description>"pLastViewedCharacter"</Description>
          <ShowAsHex>1</ShowAsHex>
          <Color>80000008</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>globals+0000</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>250</ID>
          <Description>"pLastViewedCharacterBase"</Description>
          <ShowAsHex>1</ShowAsHex>
          <Color>80000008</Color>
          <VariableType>4 Bytes</VariableType>
          <Address>globals+000C</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>9</ID>
          <Description>"Stats"</Description>
          <Options moHideChildren="1"/>
          <Color>80000008</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>12</ID>
              <Description>"HP"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>88</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>13</ID>
                  <Description>"HP (MAX)"</Description>
                  <Color>80000008</Color>
                  <VariableType>Float</VariableType>
                  <Address>globals+0000</Address>
                  <Offsets>
                    <Offset>8C</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>17</ID>
              <Description>"Hunger"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>90</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>18</ID>
                  <Description>"Hunger (MAX)"</Description>
                  <Color>80000008</Color>
                  <VariableType>Float</VariableType>
                  <Address>globals+0000</Address>
                  <Offsets>
                    <Offset>94</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>14</ID>
              <Description>"Morale"</Description>
              <Color>80000008</Color>
              <VariableType>Float</VariableType>
              <Address>globals+0000</Address>
              <Offsets>
                <Offset>98</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>15</ID>
                  <Description>"Morale (MAX)"</Description>
                  <Color>80000008</Color>
                  <VariableType>Float</VariableType>
                  <Address>globals+0000</Address>
                  <Offsets>
                    <Offset>9C</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>globals</Name>
      <Address>0BA70000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>UtilCopyData</Name>
      <Address>0B600000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>TEST_HP</Name>
      <Address>0C8F0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>UtilCopyData_Enabled</Name>
      <Address>0B60FFFC</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>UtilCopyData_Count</Name>
      <Address>0B60FFF8</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>TEST_AP</Name>
      <Address>0D000000</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <Comments>Pixel Pirates is written in .NET so it is not compiled until you are running the game,
so you must perform the proper actions before enabling certain scripts:

  SCRIPT: Raise Attribute - self explanatory
  SCRIPT: Learning - read a book
  SCRIPT: Inventory - equip a passive item
  SCRIPT: Ship Parts - place a ship part
  SCRIPT: Damage - attack something or be attacked
  SCRIPT: Hunger - start a game, happens every tick
  SCRIPT: Morale - start a game, happens every tick
  SCRIPT: Shop - visit a shop

You must enable the "Globals" cheat table entry to be able to use any scripts.  Enable
the scripts you can and then enable the cheats you want.

Cheats:
  F1: God Mode - Do not take damage (at least from pirates/animals)
  F2: One Hit Kill - Non-crew die in one hit
  F3: Hunger - Never go hungry
  F4: Morale - Always have full morale

Editable Values:
  Gold - You need to enter a shop after enabling the Shop script to get a valid pointer
  Crew Stats: Crew member is selected when viewing them

Colors:
  Blue: script
  Light Gray: used for testing
  Purple: readme
</Comments>
</CheatTable>
