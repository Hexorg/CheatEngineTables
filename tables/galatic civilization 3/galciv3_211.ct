<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="18">
  <CheatEntries>
    <CheatEntry>
      <ID>26</ID>
      <Description>"INIT LUA"</Description>
      <Options moHideChildren="1"/>
      <LastState Activated="1"/>
      <Color>80000008</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
loadlibrary(luaclient-x86_64.dll)
luacall(openLuaServer('CELUASERVER'))
luacall(initialize())
globalalloc(luainit, 128)
globalalloc(LuaFunctionCall, 128)
label(luainit_exit)
globalalloc(luaserverinitialized, 8)
globalalloc(luaservername, 12)

luaservername:
db 'CELUASERVER',0

luainit:
sub rsp,8 //local scratchspace (and alignment)
cmp [luaserverinitialized],0
jne luainit_exit
sub rsp,20 //allocate 32 bytes scratchspace for CELUA_Initialize
mov rcx,luaservername
call CELUA_Initialize //this function is defined in the luaclient dll
add rsp,20
mov [luaserverinitialized],eax
luainit_exit:
add rsp,8  //undo local scratchspace 
ret

LuaFunctionCall:
sub rsp,8 //private scratchspace for this function
push rcx //save address with function
push rdx //save integer val
sub rsp,20 //allocate 32 bytes of "shadow space" for the callee (not needed here, but good practice) 
call luainit
add rsp,20
pop rdx //restore value
pop rcx //restore address of function

sub rsp,20
call CELUA_ExecuteFunction //this function is defined in the luaclient dll
add rsp,20
add rsp,8 //undo scratchpace (alignment fix) you can also combine it into add rsp,28
ret
//luacall call example:
//Make sure rsp is aligned on a 16-byte boundary when calling this function
//mov rcx, addresstostringwithfunction //(The lua function will have access to the variable passed by name "parameter")
//mov rdx, integervariableyouwishtopasstolua
//call LuaFunctionCall
//When done RAX will contain the result of the lua function

globalalloc(pBase, 8)
alloc(newmem, 256)
label(lBasePointerHook)
label(skip)
label(rt)
registersymbol(lBasePointerHook)
aobscan(_a1, 48 69 C0 78 01 00 00 8B 84 08 A4 28 02 00)

pBase:
dq 0

newmem:
db 48 69 C0 78 01 00 00
push rbx

mov rbx,[rax+rcx+330]
test rbx,rbx
je skip
cmp dword ptr [rbx+08],0
jne skip

lea rbx,[rax+rcx]
mov [pBase],rbx

skip:
pop rbx
db 8B 84 08 A4 28 02 00
jmp rt

_a1:
lBasePointerHook:
jmp newmem
rt:

[DISABLE]

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>27</ID>
          <Description>"Planets"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,256)
alloc(func,64)
label(l3)
label(rt)
registersymbol(l3)
aobscan(_a1,48 69 C0 1C 01 00 00 8B 84 08 BC 23 00 00)  // hooks into morale accessor
LuaCall(resetPlanets(0, 0, 0))

func:
db 'registerPlanet(parameter)',0

newmem:
push rsp
push [rsp]
and rsp,-0x10 // align
db 48 69 C0 1C 01 00 00
push rcx
push rdx
push rax
push rax // align
lea rdx,[rax+rcx]
mov rcx,func
call LuaFunctionCall
pop rax
pop rax
pop rdx
pop rcx
db 8B 84 08 BC 23 00 00
mov rsp,[rsp+8] // restore
jmp rt

_a1:
l3:
jmp newmem
rt:

[DISABLE]
l3:
db 48 69 C0 1C 01 00 00 8B 84 08 BC 23 00 00
unregistersymbol(l3)
dealloc(newmem)
dealloc(func)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>236</ID>
              <Description>"Rush Planet Production"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
LuaCall(rushCityProduction(0))

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>237</ID>
              <Description>"Rush All Planet Production"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
LuaCall(rushCityProduction(1))

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>78</ID>
              <Description>"Reset Planets"</Description>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>80000008</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
            <CheatEntry>
              <ID>170</ID>
              <Description>"-------------------------------------------------------------------------------------------------------"</Description>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>FB0013</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>294</ID>
          <Description>"Tile Improvements"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// HOW TO USE: enable this script then select (freeze) one of the improvements
// you want (enable Show script just under this), open a planet screen then
// hold F12 while selecting tiles to override the improvement with your chosen
// one

[ENABLE]
globalalloc(pSelectedTile, 8)
alloc(newmem, 512)
alloc(newmem2, 512)
alloc(func, 64)
label(l6)
label(_l6)
label(rt)
label(rt2)
label(skip)
label(skip2)
registersymbol(l6)
registersymbol(_l6)
aobscan(_a1, FF 90 70 01 00 00 48 8B 8F 40 03 00 00 48 8B 87 48 03 00 00 48 2B C1 48 C1 F8 03 48 83 F8 25) // hooks into tile improvement accessor on click (a bit before, just before the jump to it)
aobscan(_a2, 48 6B C0 0B 49 03 C7 48 6B C0 38 48 8B 4C 08 30)   // hooks into bonus tile id accessor

pSelectedTile:
dq 0

func:
db 'registerTileImprovement(parameter)',0

newmem:
db 48 8B 8F 40 03 00 00 48 8B 87 48 03 00 00
// backup volatile registers
push rax
push rcx
push rdx
push r8
push r9
push r10
push r11
sub rsp,20
mov rcx,7B         // F12
call GetAsyncKeyState
test ax,8000
je skip
mov rax,[pSelectedTile]
mov [r14],rax
skip:
add rsp,20
pop r11
pop r10
pop r9
pop r8
pop rdx
pop rcx
pop rax
jmp rt

newmem2:
db 48 6B C0 0B 49 03 C7 48 6B C0 38 48 8B 4C 08 30
// backup volatile registers
push rax
push rcx
push rdx
push r8
push r9
push r10
push r11

push rsp
push [rsp]
and rsp,-0x10 // align
sub rsp,20

// test whether pointer to tile data is valid
test rcx,rcx
je skip2

mov rdx,rcx
mov rcx,func
call LuaFunctionCall

skip2:
add rsp,20
mov rsp,[rsp+8] // restore

pop r11
pop r10
pop r9
pop r8
pop rdx
pop rcx
pop rax
jmp rt2

_a1+6:
l6:
jmp newmem
rt:

_a2:
_l6:
jmp newmem2
nop
nop
rt2:

[DISABLE]
l6:
db 48 8B 8F 40 03 00 00 48 8B 87 48 03 00 00
_l6:
db 48 6B C0 0B 49 03 C7 48 6B C0 38 48 8B 4C 08 30
unregistersymbol(l6)
unregistersymbol(_l6)
unregistersymbol(pSelectedTile)
dealloc(newmem)
dealloc(newmem2)
dealloc(func)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>473</ID>
              <Description>"Show"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>80000008</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>337</ID>
          <Description>"Buildings List"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// HOW TO USE: enable this script, open a planet in game and hover over a
// building in the list, then enable Show script just under this. Select one of
// your planets in planets list and change Current Production ID to the value
// of any of the buildings. Make sure you're actually building something before
// doing it and that it's a building (not a shipyard or any of the passives).

[ENABLE]
globalalloc(pBuildingList, 8)
globalalloc(nBuildings, 4)
alloc(newmem, 256)
alloc(func, 64)
label(l7)
label(rt)
registersymbol(l7)
aobscan(_a1, 41 8B 96 8C 00 00 00 48 89 6C 24 30 89 44 24 38 48 8D 4C 24 30 0F 28 44 24 30 66 0F 7F 44 24 30)

pBuildingList:
dq 0

nBuildings:
dd 0

func:
db 'findBuildings(parameter)',0

newmem:
db 41 8B 96 8C 00 00 00 48 89 6C 24 30 89 44 24 38

// rbp has pointer to building list
// eax has number of buildings
mov [pBuildingList],rbp
mov [nBuildings],eax

// assume stack is aligned here
// backup volatile registers
push rax
push rcx
push rdx
push r8
push r9
push r10
push r11
push r11 // for alignment
mov rcx,func
call LuaFunctionCall
pop r11
pop r11
pop r10
pop r9
pop r8
pop rdx
pop rcx
pop rax
jmp rt


_a1:
l7:
jmp newmem
nop
nop
rt:


[DISABLE]
l7:
db 41 8B 96 8C 00 00 00 48 89 6C 24 30 89 44 24 38
unregistersymbol(l7)
unregistersymbol(pBuildingList)
unregistersymbol(nBuildings)
dealloc(newmem)
dealloc(func)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>338</ID>
              <Description>"Show"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>80000008</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>230</ID>
          <Description>"Shipyards"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,256)
alloc(func,64)
label(l4)
label(rt)
registersymbol(l4)
aobscan(_a1, 48 69 C9 D0 00 00 00 42 89 84 11 44 18 00 00 F3 C3)  // hooks into movement points assigner
LuaCall(resetShipyards(0, 0, 0))

func:
db 'registerShipyard(parameter)',0

newmem:
push rsp
push [rsp]
and rsp,-0x10 // align
db 48 69 C9 D0 00 00 00
push rcx
push rdx
push rax
push r10
lea rdx,[rcx+r10]
mov rcx,func
call LuaFunctionCall
pop r10
pop rax
pop rdx
pop rcx
db 42 89 84 11 44 18 00 00
mov rsp,[rsp+8] // restore
jmp rt

_a1:
l4:
jmp newmem
nop
rt:

[DISABLE]
l4:
db 48 69 C9 D0 00 00 00 42 89 84 11 44 18 00 00
unregistersymbol(l4)
dealloc(newmem)
dealloc(func)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>238</ID>
              <Description>"Rush Shipyard Production"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
LuaCall(rushShipyardProduction(0))

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>239</ID>
              <Description>"Rush All Shipyard Production"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
LuaCall(rushShipyardProduction(1))

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>232</ID>
              <Description>"Reset Shipyards"</Description>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>80000008</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
            <CheatEntry>
              <ID>233</ID>
              <Description>"-------------------------------------------------------------------------------------------------------"</Description>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>FB0013</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>240</ID>
          <Description>"Starbases"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,256)
alloc(func,64)
label(l5)
label(rt)
registersymbol(l5)
aobscan(_a1, 48 69 C0 CC 00 00 00 8B 84 10 28 2B 00 00)  // hooks into current hp accessor
LuaCall(resetStarbases(0, 0, 0))

func:
db 'registerStarbase(parameter)',0

newmem:
push rsp
push [rsp]
and rsp,-0x10 // align
db 48 69 C0 CC 00 00 00
push rcx
push rdx
push rax
push r10
lea rdx,[rax+rdx]
mov rcx,func
call LuaFunctionCall
pop r10
pop rax
pop rdx
pop rcx
db 8B 84 10 28 2B 00 00
mov rsp,[rsp+8] // restore
jmp rt

_a1:
l5:
jmp newmem
rt:

[DISABLE]
l5:
db 48 69 C0 CC 00 00 00 8B 84 10 28 2B 00 00
unregistersymbol(l5)
dealloc(newmem)
dealloc(func)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>241</ID>
              <Description>"Upgrade Starbases"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// The idea is to enable this then enable Freeze Upgrades then spend your time
// upgrading starbases. When done, disable Freeze Upgrades.

[ENABLE]
LuaCall(upgradeStarbases())

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>292</ID>
              <Description>"Freeze Upgrades"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>// this will also freeze enemy's upgrades so be sure to disable it when
// you don't need it anymore

[ENABLE]
LuaCall(freezeStarbaseUpgrades())

[DISABLE]
LuaCall(unfreezeStarbaseUpgrades())
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>243</ID>
              <Description>"Reset Starbases"</Description>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>80000008</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
            <CheatEntry>
              <ID>293</ID>
              <Description>"-------------------------------------------------------------------------------------------------------"</Description>
              <LastState Value="" Activated="0" RealAddress="00000000"/>
              <Color>FB0013</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>9</ID>
          <Description>"Maphack"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// move units
[ENABLE]
alloc(newmem,512)
globalalloc(revealSize, 4)
label(l1)
label(skip)
label(rt)
registersymbol(l1)
aobscan(_a1, 48 69 C0 2C 01 00 00 8B 84 08 3C 03 00 00)

revealSize:
dd #4096

newmem:
db 48 69 C0 2C 01 00 00
cmp [rax+rcx+C0],0
db 8B 84 08 3C 03 00 00
jne skip
mov eax,[revealSize]
imul rax,rax,#1000
skip:
jmp rt

_a1:
l1:
jmp newmem
rt:

[DISABLE]
l1:
db 48 69 C0 2C 01 00 00 8B 84 08 3C 03 00 00
unregistersymbol(l1)
unregistersymbol(revealSize)
dealloc(newmem)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>10</ID>
              <Description>"Reveal Size"</Description>
              <LastState Value="4096" Activated="0" RealAddress="03922260"/>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>revealSize</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>472</ID>
          <Description>"General Stuff"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" Activated="0" RealAddress="00000000"/>
          <Color>80000008</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>64</ID>
              <Description>"Credits"</Description>
              <LastState Value="1893235" Activated="0" RealAddress="36C02C4C"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pBase</Address>
              <Offsets>
                <Offset>228AC</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>60</ID>
              <Description>"Techs Researched"</Description>
              <LastState Value="54" Activated="0" RealAddress="36BFDC70"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pBase</Address>
              <Offsets>
                <Offset>1D8D0</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>61</ID>
              <Description>"Benevolent Points"</Description>
              <LastState Value="0" Activated="0" RealAddress="36C02C40"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pBase</Address>
              <Offsets>
                <Offset>228A0</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>62</ID>
              <Description>"Pragmatic Points"</Description>
              <LastState Value="5000" Activated="0" RealAddress="36C02C44"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pBase</Address>
              <Offsets>
                <Offset>228A4</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>63</ID>
              <Description>"Malevolent Points"</Description>
              <LastState Value="0" Activated="0" RealAddress="36C02C48"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pBase</Address>
              <Offsets>
                <Offset>228A8</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>17</ID>
          <Description>"Selected Unit"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
alloc(newmem,256)
globalalloc(pUnit, 8)
label(l2)
label(rt)
registersymbol(l2)
aobscan(_a1, 48 69 C0 2C 01 00 00 8B 84 08 0C 04 00 00)

pUnit:
dq 0

newmem:
db 48 69 C0 2C 01 00 00
push rbx
lea rbx,[rax+rcx]
mov [pUnit],rbx
pop rbx
db 8B 84 08 0C 04 00 00
jmp rt

_a1:
l2:
jmp newmem
rt:

[DISABLE]
l2:
db 48 69 C0 2C 01 00 00 8B 84 08 0C 04 00 00
unregistersymbol(l2)
unregistersymbol(pUnit)
dealloc(newmem)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>19</ID>
              <Description>"Name"</Description>
              <LastState Activated="0" RealAddress="00000020"/>
              <Color>80000008</Color>
              <VariableType>String</VariableType>
              <Length>35</Length>
              <Unicode>1</Unicode>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>pUnit</Address>
              <Offsets>
                <Offset>20</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>18</ID>
              <Description>"Address"</Description>
              <LastState Value="0000000000000000" Activated="0" RealAddress="03922270"/>
              <ShowAsHex>1</ShowAsHex>
              <Color>80000008</Color>
              <VariableType>8 Bytes</VariableType>
              <Address>pUnit</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>22</ID>
              <Description>"Moves Left"</Description>
              <LastState Value="??" Activated="0" RealAddress="00000418"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pUnit</Address>
              <Offsets>
                <Offset>418</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>21</ID>
              <Description>"Current HP"</Description>
              <LastState Value="??" Activated="0" RealAddress="0000040C"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pUnit</Address>
              <Offsets>
                <Offset>40C</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>20</ID>
              <Description>"Population"</Description>
              <LastState Value="??" Activated="0" RealAddress="0000041C"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pUnit</Address>
              <Offsets>
                <Offset>41C</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>47</ID>
          <Description>"Research Script"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>// Open your research screen after enabling this to be 100% safe.

[ENABLE]
globalalloc(researchFunc, 512)
alloc(hookResearchClassPointer, 128)
globalalloc(pResearch, 8)
globalalloc(researchAll, 4)
globalalloc(researchAmount, 4)
label(lResearchCall)
label(lHookResearchClassPointer)
label(rt)
label(loopatron)
label(noloopatron)
label(noloopatron2)
registersymbol(lHookResearchClassPointer)
registersymbol(lResearchCall)
aobscan(_a1, 40 53 56 41 56 48 83 EC 30 41 8B 00 4D 8B F0 48 8B F2 89 02 48 83 79 08 00)
aobscan(_a2, 49 8B 85 10 02 00 00 48 C1 E0 05 49 8D 95 18 02 00 00)


pResearch:
dq 0

researchAll:
dd 0

researchAmount:
dd #100000000

researchFunc:
// save registers for whatever reason
push rax
push rcx
push rdx
push r8
push r9
push r14
push r15
push rsp
push [rsp]
and rsp,-0x10 // align
sub rsp,200
mov r14,2  // start at research id 2 (1 is already done by default, 0 is nothing)
mov r15,2
cmp [pResearch],0
je noloopatron2  // early quit if research pointer is invalid
loopatron:
mov eax,[researchAmount]
mov [rsp+100],rax
mov [rsp+50],0          // some param
mov rcx,[pResearch]     // research class pointer
lea rdx,[rsp+50]
lea r8,[rsp+100]
cmp [researchAll],0
je noloopatron          // jump after research all loop if it's not on
mov rax,r14
shl rax,5
mov eax,[rcx+rax+22C]
cmp rax,1               // if it's researched already, don't bother again
mov r15d,[rcx+210]      // still store number of research nodes so it keeps looping
je noloopatron2
mov dword ptr [rcx+8],1          // set researching flag
mov dword ptr [rcx+10],r14d      // set research node id
noloopatron:
call lResearchCall
noloopatron2:
inc r14
cmp r14,r15
jb loopatron
add rsp,200
mov rsp,[rsp+8] // restore
pop r15
pop r14
pop r9
pop r8
pop rdx
pop rcx
pop rax
ret

hookResearchClassPointer:
db 49 8B 85 10 02 00 00 48 C1 E0 05 49 8D 95 18 02 00 00
mov [pResearch],r13
jmp rt

_a1:
lResearchCall:

_a2:
lHookResearchClassPointer:
jmp hookResearchClassPointer
nop
nop
nop
nop
rt:

[DISABLE]
lHookResearchClassPointer:
db 49 8B 85 10 02 00 00 48 C1 E0 05 49 8D 95 18 02 00 00
dealloc(hookResearchClassPointer)
unregistersymbol(lHookResearchClassPointer)
unregistersymbol(lResearchCall)
unregistersymbol(researchFunc)
unregistersymbol(researchAll)
unregistersymbol(researchAmount)
unregistersymbol(pResearch)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>49</ID>
              <Description>"Research Amount"</Description>
              <LastState Value="100000000" Activated="0" RealAddress="039224A0"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>researchAmount</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>54</ID>
              <Description>"Research Current"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
globalalloc(researchCurrentFunc, 256)
createthread(researchCurrentFunc)

researchCurrentFunc:
mov dword ptr [researchAll],0
call researchFunc
ret

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>55</ID>
              <Description>"Research All"</Description>
              <LastState Activated="0"/>
              <Color>80000008</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
globalalloc(researchCurrentFunc, 256)
createthread(researchCurrentFunc)

researchCurrentFunc:
mov dword ptr [researchAll],1
call researchFunc
ret

[DISABLE]
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>65</ID>
          <Description>"Free Trading"</Description>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
label(lFreeTrade)
registersymbol(lFreeTrade)
aobscan(_a1, 8B 84 CF 28 C3 18 01 39 84 D7 28 C3 18 01 0F 9E C3)

_a1+E:
lFreeTrade:
db B3 01 90

[DISABLE]
lFreeTrade:
db 0F 9E C3
unregistersymbol(lFreeTrade)

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>56</ID>
          <Description>"Infinite Designer Budget"</Description>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
label(lDesignerBudgetCheck)
label(lShipyardBudgetCheck)
registersymbol(lDesignerBudgetCheck)
registersymbol(lShipyardBudgetCheck)
aobscan(_a1, 03 D1 41 3B D0 41 0F 4F DF 8B C3 48 8B 8D 70 0B 00 00 48 33 CC) // designer window
aobscan(_a2, 7E 08 C7 03 02 00 00 00) // shipyard budget check

_a1+5:
lDesignerBudgetCheck:
db 90 90 90 90

_a2:
lShipyardBudgetCheck:
db EB

[DISABLE]
lDesignerBudgetCheck:
db 41 0F 4F DF
lShipyardBudgetCheck:
db 7E
unregistersymbol(lDesignerBudgetCheck)
unregistersymbol(lShipyardBudgetCheck)
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>66</ID>
          <Description>"Menu Stuff"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="0"/>
          <Color>80000008</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
globalalloc(pMenuStuff, 8)
globalalloc(pMenuDataStuff, 8)
alloc(newmem, 256)
label(lMenuStuff)
label(rt)
registersymbol(lMenuStuff)
aobscan(_a1, 8B 80 C4 03 00 00 89 87 78 19 00 00 48 8D 55 C8)

pMenuStuff:
dq 0

pMenuDataStuff:
dq 0

newmem:
mov [pMenuStuff],rdi
mov [pMenuDataStuff],rax
db 8B 80 C4 03 00 00 89 87 78 19 00 00 48 8D 55 C8
jmp rt

_a1:
lMenuStuff:
jmp newmem
nop
nop
rt:


[DISABLE]
lMenuStuff:
db 8B 80 C4 03 00 00 89 87 78 19 00 00 48 8D 55 C8
unregistersymbol(pMenuStuff)
unregistersymbol(pMenuDataStuff)
unregistersymbol(lMenuStuff)
dealloc(newmem)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>67</ID>
              <Description>"Trait Points"</Description>
              <LastState Value="??" Activated="0" RealAddress="000003C4"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pMenuDataStuff</Address>
              <Offsets>
                <Offset>3C4</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>68</ID>
              <Description>"Racial Ability Points"</Description>
              <LastState Value="??" Activated="0" RealAddress="000003C8"/>
              <ShowAsSigned>1</ShowAsSigned>
              <Color>80000008</Color>
              <VariableType>4 Bytes</VariableType>
              <Address>pMenuDataStuff</Address>
              <Offsets>
                <Offset>3C8</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>testage</Name>
      <Address>09020000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>luainit</Name>
      <Address>03922100</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>LuaFunctionCall</Name>
      <Address>03922180</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>luaservername</Name>
      <Address>03922210</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>luaserverinitialized</Name>
      <Address>03922200</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>gopowa</Name>
      <Address>07330120</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>researchCallPointer</Name>
      <Address>066E0140</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>researchCurrentFunc</Name>
      <Address>07142460</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>traitPoints</Name>
      <Address>064A04A0</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>getLocalizedTileName</Name>
      <Address>06E50130</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>tileNameDump</Name>
      <Address>06E50230</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>getLocalizedName</Name>
      <Address>03920000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>localizedNameDump</Name>
      <Address>03920100</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>pBase</Name>
      <Address>03922220</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>lBasePointerHook</Name>
      <Address>13FE838D1</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>pUnit</Name>
      <Address>03922270</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <LuaScript>strings_add(getAutoAttachList(), "GalCiv3.exe")
errorOnLookupFailure(false)

map = {}
shipyardMap = {}
starbaseMap = {}
tileImprovementsMap = {}
buildingMap = {}
cleanedUp = false
localizeFunc = 0

-- base stuff
basePropertiesOffsets = {
	["Owner ID"] = {0x330, 0x08},
}

-- city stuff

-- controls order
cityProperties = {
	"Name",
	"Influence Growth",
	"Vision Radius",
	"Morale",
	"Approval",
	"Population",
	"Current Production",
	"Current Production ID",
}

-- values for properties
cityPropertiesOffsets = {
	["Name"] = {0x1A8, 0x190},
	["Owner ID"] = {0x1A8, 0x248},
	["Influence Growth"] = {0x2368},
	["Vision Radius"] = {0x23A4},
	["Morale"] = {0x23BC},
	["Approval"] = {0x23C0},
	["Population"] = {0x23CC},
	["Current Production"] = {0x238},
	["Current Production ID"] = {0x234},
	["Tiles"] = {0x1A8, 0x58E8},
}

cityPropertiesTypes = {
	["Name"] = {vtString, 40, true},
	["Current Production ID"] = {vtDword, "false", "true"},
}

cityProductionQueueSizeOffset = 0x228
cityProductionRushOffset = 0x244
cityTileSize = 0x38
cityTileAvailabilityOffset = 0x38
cityTileBuildingOffset = 0x40

cityTileDataStringIDOffset = 0x14
cityTileDataIDOffset = 0x48
cityTileDataSize = 0x50

cityBuildingSize = 0x100
cityBuildingIDOffset = 0x08
cityBuildingStringIDOffset = 0x14


-- shipyard stuff
shipyardProperties = {
	"Name",
	"Moves Left",
	"Current Production",
}

shipyardPropertiesOffsets = {
	["Name"] = {0x78, 0x190},
	["Moves Left"] = {0x1844},
	["Current Production"] = {0x6D0},
	["Owner ID"] = {0x78, 0x248},
	["Production Queue Size"] = {0x6C0},
	["Production Rush Flag"] = {0x6D4},
}

shipyardPropertiesTypes = {
	["Name"] = {vtString, 40, true},
}

-- starbase stuff
starbaseProperties = {
	"Name",
	"Current HP",
	"Construction Points",
}

starbasePropertiesOffsets = {
	["Name"] = {0x4D0, 0x190},
	["Current HP"] = {0x2B28},
	["Max HP"] = {0x2A78},
	["Construction Points"] = {0x580},
	["Construction Points2"] = {0x2B14},
	["Owner ID"] = {0x4D0, 0x248},
}

starbasePropertiesTypes = {
	["Name"] = {vtString, 40, true},
}

function Dec2Hex(nValue)
	if( nValue == nil ) then
		return
	end
	if type(nValue) == "table" then
		for i,v in ipairs(nValue) do
			nValue[i] = Dec2Hex(v)
		end
		nValue = reverseTable(nValue)
		nValue = table.concat(nValue, "")
		return nValue
	elseif type(nValue) == "string" then
		nValue = tonumber(nValue)
		nHexVal = string.format("%02X", nValue)
	elseif nValue &lt; 0 then
		nValue = nValue - 0xFFFFFFFF00000000
		nHexVal = string.format("%08X", nValue)
	else
		nHexVal = string.format("%02X", nValue)
	end
	sHexVal = nHexVal..""
	return sHexVal
end

function reverseTable(t)
	if type(t) ~= "table" then
		return
	end
	t2 = {}
	for i=1,#t do
		t2[#t+1-i] = t[i]
	end
	return t2
end

function readNestedPointer(base, offsets)
	if (base == nil) then
		return 0
	end

	if (type(base) == "string") then
		base = tonumber(base, 16)
	end

	for i = 1, #offsets - 1 do
		base = readQword(base + offsets[i])
		if (base == nil) then
			return 0
		end
	end
	return base + offsets[#offsets]
end

function assignTypeForMR(mr, typeData)
	defaultType = vtDword
	defaultSigned = "true"

	if (typeData == nil) then
		mr.Type = defaultType
		setProperty(mr, "ShowAsSigned", defaultSigned)
		return
	end

	mr.Type = typeData[1]

	if (mr.Type == vtString) then
		if (typeData[2] ~= nil) then
			mr.String.Size = typeData[2]
		else
			mr.String.Size = 20
		end
		if (typeData[3] ~= nil) then
			mr.String.Unicode = typeData[3]
		end
	elseif (mr.Type == vtByteArray) then
		if (typeData[2] ~= nil) then
			mr.Aob.Size = typeData[2]
		else
			mr.Aob.Size = 10
		end
	else
		if (typeData[2] ~= nil) then
			setProperty(mr, "ShowAsSigned", typeData[2])
		end

		if (typeData[3] ~= nil) then
			setProperty(mr, "ShowAsHex", typeData[3])
		end
	end
end

function createPlayerGroupMR(name, parent)
	mr = nil
	for i = 0, parent.Count - 1 do
		if parent[i].getDescription() == tostring(name) then
			mr = parent.Child[i]
			break
		end
	end
	if mr == nil then
		mr = al.createMemoryRecord()
		mr.setDescription(name)
		mr.Type = 11
		setProperty(mr, "Options", "[moHideChildren]")
		mr.appendToEntry(parent)
	end
	return mr
end

function unfreeze(mr)
	if (type(mr) == "number") then
		mr = readString(mr, 100, false)
	end
	al = getAddressList()
	mr = al.getMemoryRecordByDescription(mr)
	memoryrecord_unfreeze(mr)
end

function findLocalizeFunction()
	if (localizeFunc ~= 0) then
		return
	end
	ms = createMemScan()
	ms.firstScan(soExactValue, vtByteArray, 0, "48 8B C4 56 57 41 54 41 56 41 57 48 83 EC 70 48 C7 40 B8 FE FF FF FF 48 89 58 08 48 89 68 18 44 8B F9", 0, 0, 0xFFFFFFFFFFFFFFFF, "-W-C+X", fsmAligned, "1", true, false, false, false)
	ms.waitTillDone()
	createFoundList(ms)
	ms.FoundList.initialize()
	if (ms.FoundList.Count ~= 1) then
		print("Found more than zero or more addresses for localize function!")
		localizeFunc = 0
		return
	end
	localizeFunc = ms.FoundList.Address[0]
	ms.FoundList.deinitialize()
end

function initialize()
	-- reserve some memory
	autoAssemble([[
globalalloc(getLocalizedName, 256)
globalalloc(localizedNameDump, 0x2000)
	]])
	localizeFunc = 0
end

function registerPlanet(address)
	address = Dec2Hex(address)
	if (map[address] ~= nil) then
		return
	end
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Planets")

	newMr = al.createMemoryRecord()
	newMr.setDescription(readString(Dec2Hex(readNestedPointer(address, cityPropertiesOffsets["Name"])), 40, true) .. " " .. address)
	newMr.Type = 11
	setProperty(newMr, "Options", "[moHideChildren]")

	for i = 1, #cityProperties do
		k, v = cityProperties[i], cityPropertiesOffsets[cityProperties[i]]
		newMr1 = al.createMemoryRecord()
		newMr1.setDescription(k)
		newMr1.Address = Dec2Hex(readNestedPointer(address, v))
		assignTypeForMR(newMr1, cityPropertiesTypes[k])
		newMr1.appendToEntry(newMr)
	end

	newMr1 = al.createMemoryRecord()
	newMr1.setDescription("Unlock Tiles")
	newMr1.Type = 11
	memoryrecord_setScript(newMr1,
	[[
		LuaCall(unlockPlanetTiles(0x]] .. address .. [[))
	]])
	memoryrecord_onActivate(newMr1, runScriptWithoutEnabling)
	newMr1.appendToEntry(newMr)

	newMr1 = al.createMemoryRecord()
	newMr1.setDescription("Lock Tiles")
	newMr1.Type = 11
	memoryrecord_setScript(newMr1,
	[[
		LuaCall(lockPlanetTiles(0x]] .. address .. [[))
	]])
	memoryrecord_onActivate(newMr1, runScriptWithoutEnabling)
	newMr1.appendToEntry(newMr)

	isPlayer = readInteger(readNestedPointer(address, cityPropertiesOffsets["Owner ID"])) == 0
	grpName = "Enemy"
	if (isPlayer) then
		grpName = "Player"
	end
	grp = createPlayerGroupMR(grpName, mr)
	newMr.appendToEntry(grp)

	map[address] = newMr
end

function unlockPlanetTiles(address)
	tiles = readNestedPointer(address, cityPropertiesOffsets["Tiles"])
	pointer = 0
	i = 0
	while (i &lt; 66) do
		tileAvail = tiles + i * cityTileSize + cityTileAvailabilityOffset
		i = i + 1
		if pointer == 0 then
			pointer = readQword(tileAvail)
			if pointer ~= 0 then
				i = 0
			end
		else
			writeQword(tileAvail, pointer)
		end
	end
end

function lockPlanetTiles(address)
	tiles = readNestedPointer(address, cityPropertiesOffsets["Tiles"])
	i = 0
	while (i &lt; 66) do
		tileAvail = tiles + i * cityTileSize + cityTileAvailabilityOffset
		tileBuild = tiles + i * cityTileSize + cityTileBuildingOffset
		i = i + 1
		pointer = readQword(tileAvail)
		bPointer = readQword(tileBuild)
		if pointer ~= 0 and bPointer == 0 then
			writeQword(tileAvail, 0)
		end
	end
end

function registerTileImprovement(address)
	if (#tileImprovementsMap &gt; 0) then
		return
	end

	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Tile Improvements")
	mr = mr.Child[0]

	findLocalizeFunction()

	startIndex = 0
	endIndex = 0
	currentIndex = 0
	goingBack = true
	while (true) do
		prevID = readInteger(address + currentIndex * cityTileDataSize + cityTileDataIDOffset)
		if (goingBack) then
			startIndex = currentIndex
			currentIndex = currentIndex - 1
		else
			currentIndex = currentIndex + 1
			endIndex = currentIndex
		end
		currentID = readInteger(address + currentIndex * cityTileDataSize + cityTileDataIDOffset)
		if (math.abs(currentID - prevID) ~= 1) then
			if (not goingBack) then
				endIndex = currentIndex - 1
				break
			end
			startIndex = currentIndex + 1
			currentIndex = 0
			goingBack = false
		end
	end

	currentIndex = 0
	for i = startIndex, endIndex do
		tileImprovementsMap[currentIndex] = {}
		tileImprovementsMap[currentIndex][0] = address + cityTileDataSize * i
		tileStringID = tileImprovementsMap[currentIndex][0] + cityTileDataStringIDOffset
		tileNameAddr = getAddress('localizedNameDump') + currentIndex * 8
		writeQword(tileNameAddr, 0)
		autoAssemble(string.format(getLocalizedName, Dec2Hex(readInteger(tileStringID)), localizeFunc, currentIndex * 8))
		c = os.clock()
		while (readQword(tileNameAddr) == 0 and os.clock() - c &lt; 0.5) do
			-- wait but don't wait too long
		end
		newMr = al.createMemoryRecord()
		name = readString(readQword(tileNameAddr), 60, true)
		if (name == nil) then
			name = ""
		end
		newMr.setDescription(name .. " " .. Dec2Hex(tileImprovementsMap[currentIndex][0]))
		newMr.Type = 11
		newMr.Script = [[
[ENABLE]
LuaCall(selectTileImprovement(]] .. currentIndex .. [[))
[DISABLE]
			]]
		newMr.OnDeactivate = deselectTileImprovement
		newMr.appendToEntry(mr)
		tileImprovementsMap[currentIndex][1] = newMr
		currentIndex = currentIndex + 1
	end
end

function selectTileImprovement(id)
	for k, v in pairs(tileImprovementsMap) do
		if v[1].Active == true then
			v[1].Active = false
		end
	end
	writeQword(getAddress('pSelectedTile'), tileImprovementsMap[id][0])
end

function deselectTileImprovement(mr, before, currenstate)
	writeBytes(getAddress('pSelectedTile'), 0, 0, 0, 0, 0, 0, 0, 0)
	return true
end

function clearTileImprovements(mr, before, currentstate)
	tileImprovementsMap = {}
	deselectTileImprovement(0, 0, 0)
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Tile Improvements")
	mr = mr.Child[0]

	while (mr.Count &gt; 0) do
		memoryrecord_delete(mr.Child[0])
	end
	return true
end

function findBuildings(x)
	if (#buildingMap &gt; 0) then
		return
	end

	clearBuildingsList(0, 0, 0)

	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Buildings List")
	mr = mr.Child[0]

	findLocalizeFunction()

	buildingList = readQword(getAddress('pBuildingList'))
	buildingCount = readInteger(getAddress('nBuildings'))

	if (buildingList == 0 or buildingCount == 0) then
		mr.Active = false
		return
	end

	for i = 0, buildingCount - 1 do
		buildingMap[i] = {}
		buildingMap[i][0] = buildingList + i * cityBuildingSize
		buildingStringID = buildingMap[i][0] + cityBuildingStringIDOffset
		buildingNameAddr = getAddress('localizedNameDump') + i * 8
		writeQword(buildingNameAddr, 0)
		autoAssemble(string.format(getLocalizedName, Dec2Hex(readInteger(buildingStringID)), localizeFunc, i * 8))
		c = os.clock()
		while (readQword(buildingNameAddr) == 0 and os.clock() - c &lt; 0.2) do
			-- wait but don't wait too long
		end
		newMr = al.createMemoryRecord()
		newMr.setDescription(readString(readQword(buildingNameAddr), 60, true))-- .. " " .. Dec2Hex(buildingMap[i][0]))
		newMr.Type = vtDword
		newMr.Address = Dec2Hex(buildingMap[i][0] + cityBuildingIDOffset)
		setProperty(newMr, "ShowAsHex", "true")
		newMr.appendToEntry(mr)
		buildingMap[i][1] = newMr
	end
end

function clearBuildingsList(mr, before, currentstate)
	buildingMap = {}
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Buildings List")
	mr = mr.Child[0]

	while (mr.Count &gt; 0) do
		memoryrecord_delete(mr.Child[0])
	end
	return true
end

function resetPlanets(mr, before, currentstate)
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Planets")
	index = 4
	while (mr.Count &gt; index) do
		memoryrecord_delete(mr.Child[index])
	end
	map = {}
end

function rushCityProduction(all)
	for k, v in pairs(map) do
		isPlayer = readInteger(readNestedPointer(k, cityPropertiesOffsets["Owner ID"])) == 0
		if (isPlayer) then
			nProduction = readInteger(tonumber(k, 16) + cityProductionQueueSizeOffset)
			if (all == 0) then
				nProduction = math.min(1, nProduction)
			end
			for i = 0, nProduction - 1 do
				writeInteger(Dec2Hex(tonumber(k, 16) + cityProductionRushOffset + i * 0x20), 1)
				writeInteger(Dec2Hex(tonumber(k, 16) + cityProductionRushOffset + 0x04 + i * 0x20), 1)
			end
		end
	end
end

function registerShipyard(address)
	address = Dec2Hex(address)
	if (shipyardMap[address] ~= nil) then
		return
	end
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Shipyards")

	newMr = al.createMemoryRecord()
	newMr.setDescription(readString(Dec2Hex(readNestedPointer(address, shipyardPropertiesOffsets["Name"])), 20, true) .. " " .. address)
	newMr.Type = 11
	setProperty(newMr, "Options", "[moHideChildren]")

	for i = 1, #shipyardProperties do
		k, v = shipyardProperties[i], shipyardPropertiesOffsets[shipyardProperties[i]]
		newMr1 = al.createMemoryRecord()
		newMr1.setDescription(k)
		newMr1.Address = Dec2Hex(readNestedPointer(address, v))
		assignTypeForMR(newMr1, shipyardPropertiesTypes[k])
		newMr1.appendToEntry(newMr)
	end

	isPlayer = readInteger(readNestedPointer(address, shipyardPropertiesOffsets["Owner ID"])) == 0
	grpName = "Enemy"
	if (isPlayer) then
		grpName = "Player"
	end
	grp = createPlayerGroupMR(grpName, mr)
	newMr.appendToEntry(grp)

	shipyardMap[address] = newMr
end

function resetShipyards(mr, before, currentstate)
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Shipyards")
	index = 4
	while (mr.Count &gt; index) do
		memoryrecord_delete(mr.Child[index])
	end
	shipyardMap = {}
end

function rushShipyardProduction(all)
	for k, v in pairs(shipyardMap) do
		isPlayer = readInteger(readNestedPointer(k, shipyardPropertiesOffsets["Owner ID"])) == 0
		if (isPlayer) then
			nProduction = readInteger(readNestedPointer(k, shipyardPropertiesOffsets["Production Queue Size"]))
			if (all == 0) then
				nProduction = math.min(1, nProduction)
			end
			for i = 0, nProduction - 1 do
				writeInteger(Dec2Hex(readNestedPointer(k, shipyardPropertiesOffsets["Production Rush Flag"]) + i * 0x20), 1)
			end
		end
	end
end

function registerStarbase(address)
	address = Dec2Hex(address)
	if (starbaseMap[address] ~= nil) then
		return
	end
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Starbases")

	newMr = al.createMemoryRecord()
	name = readString(Dec2Hex(readNestedPointer(address, starbasePropertiesOffsets["Name"])), 20, true)
	if (name == nil) then
		name = ""
	end
	newMr.setDescription(name .. " " .. address)
	newMr.Type = 11
	setProperty(newMr, "Options", "[moHideChildren]")

	for i = 1, #starbaseProperties do
		k, v = starbaseProperties[i], starbasePropertiesOffsets[starbaseProperties[i]]
		newMr1 = al.createMemoryRecord()
		newMr1.setDescription(k)
		newMr1.Address = Dec2Hex(readNestedPointer(address, v))
		assignTypeForMR(newMr1, starbasePropertiesTypes[k])
		newMr1.appendToEntry(newMr)
	end

	isPlayer = readInteger(readNestedPointer(address, starbasePropertiesOffsets["Owner ID"])) == 0
	grpName = "Enemy"
	if (isPlayer) then
		grpName = "Player"
	end
	grp = createPlayerGroupMR(grpName, mr)
	newMr.appendToEntry(grp)

	starbaseMap[address] = newMr
end

function resetStarbases(mr, before, currentstate)
	al = getAddressList()
	mr = al.getMemoryRecordByDescription("Starbases")
	index = 4
	while (mr.Count &gt; index) do
		memoryrecord_delete(mr.Child[index])
	end
	starbaseMap = {}
end

function upgradeStarbases()
	for k, v in pairs(starbaseMap) do
		isPlayer = readInteger(readNestedPointer(k, starbasePropertiesOffsets["Owner ID"])) == 0
		if (isPlayer) then
			writeInteger(Dec2Hex(readNestedPointer(k, starbasePropertiesOffsets["Construction Points"])), 5000)
			writeInteger(Dec2Hex(readNestedPointer(k, starbasePropertiesOffsets["Construction Points2"])), 5000)
		end
	end
end

function freezeStarbaseUpgrades()
	for k, v in pairs(starbaseMap) do
		for i = 0, v.Count - 1 do
			if v.Child[i].getDescription() == "Construction Points" then
				memoryrecord_freeze(v.Child[i])
			end
		end
	end
end

function unfreezeStarbaseUpgrades()
	for k, v in pairs(starbaseMap) do
		for i = 0, v.Count - 1 do
			if v.Child[i].getDescription() == "Construction Points" then
				memoryrecord_unfreeze(v.Child[i])
			end
		end
	end
end

function cleanupOnGameEnd()
	addr = getAddress('pBase')
	if (addr == nil or addr == 0) then
		return
	end

	pointer = readQword(addr)
	if (pointer == nil or pointer == 0) then
		return
	end

	isPlayer = readInteger(readNestedPointer(pointer, basePropertiesOffsets["Owner ID"])) == 0
	if (not isPlayer) then
		return
	end

	x = readInteger(pointer + 0x100)

	if (x == 0) then
		if (not cleanedUp) then
			clearTileImprovements(0, 0, 0)
			clearBuildingsList(0, 0, 0)
			resetPlanets(0, 0, 0)
			resetShipyards(0, 0, 0)
			resetStarbases(0, 0, 0)
			pResearch = getAddress('pResearch')
			if (pResearch ~= 0) then
				writeQword(pResearch, 0)
			end
			cleanedUp = true
		end
	else
		cleanedUp = false
	end
end

function runScriptWithoutEnabling(mr, before, currentstate)
	script = memoryrecord_getScript(mr)
	autoAssemble(script)
	return false
end

memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Rush Planet Production"), runScriptWithoutEnabling)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Rush Shipyard Production"), runScriptWithoutEnabling)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Rush All Planet Production"), runScriptWithoutEnabling)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Rush All Shipyard Production"), runScriptWithoutEnabling)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Upgrade Starbases"), runScriptWithoutEnabling)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Reset Starbases"), resetStarbases)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Reset Shipyards"), resetShipyards)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Reset Planets"), resetPlanets)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Research Current"), runScriptWithoutEnabling)
memoryrecord_onActivate(getAddressList().getMemoryRecordByDescription("Research All"), runScriptWithoutEnabling)
memoryrecord_onDeactivate(getAddressList().getMemoryRecordByDescription("Buildings List"), clearBuildingsList)
memoryrecord_onDeactivate(getAddressList().getMemoryRecordByDescription("Tile Improvements"), clearTileImprovements)

if updateTimer~=nil then object_destroy(updateTimer);updatesTimer=nil;end

updateTimer = createTimer(nil, false)
timer_setInterval(updateTimer, 500)
timer_onTimer(updateTimer, cleanupOnGameEnd)
timer_setEnabled(updateTimer, true)

getLocalizedName = [[
createthread(getLocalizedName)

getLocalizedName:
push rsp
push [rsp]
and rsp,-0x10

push r10
push r11

sub rsp,20
mov ecx,%s
call %s
add rsp,20
mov [localizedNameDump+%08X],rax

pop r11
pop r10

mov rsp,[rsp+8]
ret
]]

</LuaScript>
</CheatTable>
