<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="18">
  <Forms>
    <UDF1 Class="TCEForm" Encoding="Ascii85">=VMeV/5m@Non()Tk=id3;[;OIUGVmWu2]lsLkkiTh$NHD%uXgr$C,8{N*?[sZW0s64%hY$nTM*.h[43)Z-5X}?P?Qd@/f1CA,!;YNC,Vn@@pe/5;m@D1QI-OuN@0LHsd)niaJs(b:Gn0d,z!F(N.sK#]gU)![.e}b,%q8mUP?)I?}I4ER_8qOg+0jJ4k7F%,$kVs.;7[KS]!/D@0VL]qI,sj+d=x8SAQ:hj@[9,lcNxLfD,x]!LDoG]XW:Bf_)e%ha9kdA0!irlM:$qXn$UU1W+^9m+YXbA97EQG*l7xD9)qEH*KW$Kt);wRN!vn?DU7#1d3apmwd$QPifSoG4m+t+EIGw-M:.a-wS^RN2ciHg?!$-bR^k8TPRU$WTtu*hXxEek+d(Sx/S-k}(z=x=zkx]RHl0ZDk9pf.4j@e#ZIiYR[Z^t8J]X^k.C!%y]qmmb}mzdz,!uk}fFY^,k#^eyOBrO%am,2@if#Vqb+:g#C8kWPEo2oyeAmvulM8#1b.uY[1}heyXsOJCKTX!TCy8b/DD_x^VRiGWI@FvE+C4^i#Bbf@-fmP/2kJDW:=Eg.xIvlAR3_IYwTvpsJVymTi4z3(WP[94wgw6:gun$m=p85o!;V-qCM3t[}Yj,)bB.V0fZV-ZD+HJKr!h;S?jP(d3k8s];LyFiJ]jQMK0S2FpVO:XG+Q(x!o2iJ@wc;$ZfMp?eTRt9hN8k?]?kL}X()p7ZadXQW43uSf]D64y;Ao-uB*RgLH;ciGERx?Uhg[J)0;+af{U(;h)B:EkK7M,!s-l346Cr!S6:C7laAbk%=8ggj4-zdfM)1U7YH@57X-U$wQ}7-;DK8*=]j-vHR9C$O,/x5i9UUD!2IZ]j:Vv;h,)vTST(y{zX(Yh{eSy]e(51+%AELd=4x!z_,5Ec%U.Ma-}UnFO}5O.lHUD9zaa^paQ7PmUX/$i?+U5LpgT3nQcBG/)T*[KICmR{xOM$-Pm$cupBbN*_giCZmHrQVfM84aYDXu}}*/qyn].v(/3qhFiju+K99t554#r!]Y;n6dP]ej;4!nnOZq[r,6S%a^I-Q]440?uUg2L^)pVv)=8;,zipHA*(hp1+D]wDNF!:,M#i5O?CDKy!j6nT8[6izG9C=O^MFQYAjC@3U!6QauvyjA0q:_0QSfjycqsVbGT@9kZKTRYJD6V_:1B4_Fu2Z,gUhjHyAYt6PoTfOE0M(bJTz.%Q7VK9mj^e1%w:1crkmx?h4u0u9xt:DmtqBCtRK)k=9=k^%70DaWQW3V)1%A+pR*V?np@l?WxU1p!WsI)AWD*UP1^HSK4%#wCiWp/i(_SHgA0){*tcmUrh/.ey9nC+xEkz_DhxG^m2{JOh]AOS^z1S=SP^!m;yqPdBf{KwxyS)AU8UE6jbj9aJf!V5NgV^}J*^lnmdy@rv_$6VL?lL3=12K+U:spPl6BKI%I.!hZ{2%X+wai!BfZQc,[T7G;:x2]5O:^,N%@!wno-(a)]Igw3mF.!cAFdswE@I[l=L)9gc$HUy4Du:$REIMTL@3P!1OK_3Jw6bPdptMq:ls[IS-@Os1H=ewg(sq5}(v37VQ8p5#=ZC#_VJKHt8J%sY59TmJ4t_(J%YH$FJ03t[U*?R:Wc:M;*b$BLiUC$35#9DkcCG9Unu_+CVJ_)6j)Y64f^,I*L.oVpjv.F6;cp+gWiDsE_e@i:ZO]#;}1-E^+emL+y*Nc2RX:;7}=ZWpm:vKDCS^7psh;J!O:4%jl+f#74=rDId5:@+JVFsXSMufiA_rU^0$nLlIs{y.oV?t1Q0C0^l5cuCet(AB7luB)L{r;Xv)jeKBM^Wr-}Ut1VK4i.zk}Z5.1U^F#)bgv%tso.Zm,cD(Mt=9G^!SPvzEP_{apkeE[0Cj6XAE,-h86S1}9oOsz*$MOGRA^r=(8]Vs*LE0j/0}#ja:wERkkupdAi1t1{wiK%e+lMd}@hx5eWz=n^Gl[cViy5[1QjppVi{Zf-F[E6J%]Fns,k28pN{u5f?Z.1eOurI[:@jFTuu](ARitYO[Gg5FP=hE3[Dp+GL[W?#nFN(0mfQ7jhaHDpa[c5Bsn9++hs07rj3;oMRjO]9Q0en=t8^USO4Y5Hi/EIis(B4GQ0WKnNGuWCi=I?LdL#v^1iT!pl;lMvmVjom5Ay4kSoxLluV}qxnGr)zmx.NjY2%PK;1,V1?s4H_1(iZl^:Et2zlas^tbYl-giBF}zv:q*LP,3336p,@C0#e.O+*N(B:K-gzU0UJhge{g/Hwwbkud+jUd))R%H4(a9HdA9/$uPC@0J=DwIy^TP)GiWcV/E-Qlw$g:.*;qchW)s1dv]y#*/UV3DR05)$CIII$PBi2)%Un@vzg-Uh#vjsWlh?baigf@o9g]Kn7)LchEti1b^Bb3iP;2(^97F:x$]tQeV.H5BhXb0zh_S1$xy3I.{Qx=REstU!Iq/K/r;-7-T!%l$TI_A[0*U7%Rx/J(.,ov4vW;Mg,]1oEP(lv4k^P%r%tw-yH%[pe[NhUx@j$3x3#AS5eg^zw((,olJZ?B/-_qD).X2[3+Bgd[588Rlkc9Kf3D2YPjXGM;w{4td9,U(RdZ6F%Hd.$BX?si8$Z)b.+PMjM@yZWCmmq2:X8b]tQ(CgL{qfFy73wD1/g%=ypa9_8A[fKjHt0$8I9+9iEfae=BjDeq:7+%mp-4mmuOljTQ0B^)/=velH5@H_Ax^5ksg*x*b,td4M26kbfU5$X6b?b(CG)6k%w-HuvwgY)7]7=@d:$-k-[IYR$rZ6}+C4=%^wZoK%nGL:;(6x62Evl]y/BD5O{EHwMiw7FXIWmbVsMt(n5sNwwx5ORtXZqgs%]G;;Kp/SoCYRGdfCPx?Cm;z$k(h5G2$qOXRYLDf6N14:z7%NB-lA5EuGkTyZU/27r)I/Yp:N2nQv[.+}do*5h=LQTbfZ6rt!FXcZa^gl5IE6Pv#CrbrL,NvOkqmX^!dS-/rebzQdQ}Mce@G4jKOf%K-a)^XvyI,kJ[iO$Ox$Rjg8us7Ki,y;Fy%c-uJes9V5cJ;13i_u{$xiRSww.SY^qJ*R-(UwSO5MdD[jI4BkC+%;Cdj]XEAsF6(j[h!Ay-Kzxi7n}MEU02,!tfHghMmb?lwxEP_wEd:Pl8DTk!DTjZhD_Cwy.hND4#dcanTgRoWV+$Z^rhqzD-Yn[+si/A38#,L]udWp!WI)7:AnO30}lT2;EG)/k+]^+UpLsbi:aeR}Ht1.b[-48KnK-@v1p819Enz0Eo?Ow?D}zK1Zqi9r0A[;r}s%]/_d[y-Kn7aMEq.h#aSBdDGl$]SMpv+zH,[u*_TjY]*AXYT2iu0Jz?s)o-6i[(4CP=SoC/=/a7nkETaBBiN_ZQ_gXSghQt-nl-EP,nH0=tng)^TTYa[3p+z[ysO$gXW_oV1HBwZrTF:$bH^M%].ic9Tl(Kce):a4NiS/^W0p[6yHZLlM!r{=Ct4w@1A:_H$fgfAL![=dfEeU-w1vHE,eT+-+}p5;IMS+zS0yApw;q8iDHYsd1o.5$,xE(hWQ?</UDF1>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"AA script for testing"</Description>
      <LastState Activated="0"/>
      <Color>80000008</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(player1,4096)
alloc(player2,4096)
registersymbol(player1)
registersymbol(player2)

player1:
db 'unknown data    '
player1+50:
dd (int)25
dd (int)5
dd (int)1975
player1+90: // exp
dd (int)1500
player1+100: // name
db 'Cyrus'

player2:
db 'unknown data    '
player2+50:
dd (int)25
dd (int)5
dd (int)1975
player2+90: // exp
dd (int)9001
player2+100: // name
db 'Obelix'
 
[DISABLE]
dealloc(player1)
dealloc(player2)


unregistersymbol(player1)
unregistersymbol(player2)
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1</ID>
      <Description>"player1 EXP"</Description>
      <LastState Value="??" Activated="0" RealAddress="00000000"/>
      <Color>80000008</Color>
      <VariableType>4 Bytes</VariableType>
      <Address>player1+90</Address>
    </CheatEntry>
    <CheatEntry>
      <ID>2</ID>
      <Description>"player1 EXP"</Description>
      <LastState Value="??" Activated="0" RealAddress="00000000"/>
      <Color>80000008</Color>
      <VariableType>4 Bytes</VariableType>
      <Address>player2+90</Address>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
  <LuaScript>processname = "CC2014.exe"
if customOpenProcess~=nil then customOpenProcess.destroy() end
customOpenProcess = createTimer(MyForm);
customOpenProcess.Interval = 100;
customOpenProcess.onTimer = function (timer)
  local processExist = ( readInteger(processname)~=nil )
  if not processExist then
    UDF1.CELabel3.Caption='Editor NOT attached to game'
    timer.Interval = 1000;
    openProcess(processname)
  else
    UDF1.CELabel3.Caption='Editor SUCCESFULLY attached to game. ENJOY!'
    timer.Interval = 100;
  end
end



dobCalendar = UDF1.Calendar1
cbFoundPlayers = UDF1.CEComboBox1

-- getTextAndCheckIfNumberCheckBoundaries
-- I use short name
function getControlText(control,b1,b2)
  local number = tonumber(control.Text)
  if number==nil then
    control.Color = 0x9090ff   -- bright Red
    control.Width = control.Width + 1  -- oddly, resizing is better than "repaint"
    control.Width = control.Width - 1  --
    return nil -- not a number, nothing more to do
  else
    control.Color = 0x20000000   -- clDefault
    control.Width = control.Width + 1  -- oddly, .... (see above)
    control.Width = control.Width - 1  --
  end

  if b1 then
    b1,b2 = math.min(b1,b2),math.max(b1,b2)
    if number &lt; b1 or number &gt; b2 then
      control.Color = 0x90ffff   -- bright Yellow
      return nil -- outside boundaries, nothing more to do
    end
  end

  return number+0 -- return number (with +0 we are sure it is type=number)
end

--override CE Lua functions
----------
if oldwriteBytes==nil then oldwriteBytes = writeBytes end
if oldwriteInteger==nil then oldwriteInteger = writeInteger end

function writeBytes(a,v)
  if v~=nil then oldwriteBytes(a,v) end
end

function writeInteger(a,v)
  if v~=nil then oldwriteInteger(a,v) end
end
-- ^^^^^^^
----------


function readShortint(address)
  local value = readInteger(address)
  if value~=nil then
    return bAnd(0xFFFF, value )
  else
    return nil
  end
end

function writeShortint(a,v)
  if v~=nil then
     oldwriteBytes(a, v%256, v/256)
  end
end



-- will fill combobox, items are sorted by key
function fillCombobox(combobox,T)
  combobox.Items.clear()
  tmp = {}
  for k,v in pairs(T) do tmp[#tmp+1] = {k=k,v=v} end
  table.sort(tmp,function (a,b) return a.k &lt; b.k end)
  for _,v in pairs(tmp) do
    combobox.Items.add(v.v)
  end
end


Nationalities = {
  [1]='Australia',
  [2]='England',
  [3]='India',
  [4]='New Zealand',
  [5]='Pakistan',
  [6]='South Africa',
  [7]='Sri Lanka',
  [8]='West Indies',
  [9]='Zimbabwe',
  [10]='Bangladesh',
  [11]='Kenya',
  [12]='Netherlands',
  [13]='Namibia',
  [14]='Canada',
  [15]='Scotland',
  [16]='Ireland',
  [17]='Argentina',
  [18]='Bermuda',
  [19]='Denmark',
  [20]='Fiji',
  [21]='Nigeria',
  [22]='Jersey',
  [23]='Germany',
  [24]='Gibraltar',
  [25]='Hong Kong',
  [26]='Guernsey',
  [27]='Italy',
  [28]='Malaysia',
  [29]='Oman',
  [30]='Nepal',
  [31]='Papau New Guina',
  [32]='Singapore',
  [33]='Uganda',
  [34]='USA',
  [35]='Cayman Islands',
  [36]='UAE',
  [37]='Afghanistan',
  [38]='Tanzania',
  [39]='Kuwait',
  [40]='Norway',
  [41]='Vanuatu',
  [42]='Botswana',
  [43]='Japan',
  [44]='Zambia',
  [45]='Bahrain',
  [46]='Suriname'
}
-- create another key-value table (this time, country name is a key)
NationalitiesMirror = {}
for k,v in pairs(Nationalities) do
  NationalitiesMirror[v]=k
end

fillCombobox(UDF1.cNation1,Nationalities)

Nationalities2 = {
  [1]='Australia',
  [2]='England',
  [3]='India',
  [4]='New Zealand',
  [5]='Pakistan',
  [6]='South Africa',
  [7]='Sri Lanka',
  [8]='West Indies',
  [9]='Zimbabwe',
  [10]='Bangladesh',
  [11]='Kenya',
  [12]='Netherlands',
  [13]='Namibia',
  [14]='Canada',
  [15]='Scotland',
  [16]='Ireland',
  [17]='Argentina',
  [18]='Bermuda',
  [19]='Denmark',
  [20]='Fiji',
  [21]='Nigeria',
  [22]='Jersey',
  [23]='Germany',
  [24]='Gibraltar',
  [25]='Hong Kong',
  [26]='Guernsey',
  [27]='Italy',
  [28]='Malaysia',
  [29]='Oman',
  [30]='Nepal',
  [31]='Papau New Guina',
  [32]='Singapore',
  [33]='Uganda',
  [34]='USA',
  [35]='Cayman Islands',
  [36]='UAE',
  [37]='Afghanistan',
  [38]='Tanzania',
  [39]='Kuwait',
  [40]='Norway',
  [41]='Vanuatu',
  [42]='Botswana',
  [43]='Japan',
  [44]='Zambia',
  [45]='Bahrain',
  [46]='Suriname'
}
-- create another key-value table (this time, country name is a key)
Nationalities2Mirror = {}
for k,v in pairs(Nationalities2) do
  Nationalities2Mirror[v]=k
end

fillCombobox(UDF1.cNation2,Nationalities2)

BatTypes = {
  [0]='Right Hand',
  [1]='Left Hand'
}
-- create another key-value table (this time, country name is a key)
BatTypesMirror = {}
for k,v in pairs(BatTypes) do
  BatTypesMirror[v]=k
end

fillCombobox(UDF1.cBatType,BatTypes)

BowlTypes = {
  [0]='Cant bowl',
  [1]='Fast',
  [2]='Fast Med',
  [3]='Med Fast',
  [4]='Medium',
  [5]='Offspin',
  [6]='Legspin'
}
-- create another key-value table (this time, country name is a key)
BowlTypesMirror = {}
for k,v in pairs(BowlTypes) do
  BowlTypesMirror[v]=k
end

fillCombobox(UDF1.cBowlType,BowlTypes)

FieldTypes = {
  [1]='Slips/Close',
  [2]='Mid Range',
  [3]='Boundary',
}
-- create another key-value table (this time, country name is a key)
FieldTypesMirror = {}
for k,v in pairs(FieldTypes) do
  FieldTypesMirror[v]=k
end

fillCombobox(UDF1.cFieldType,FieldTypes)

WKStatuss = {
  [0]='Cant Keep',
  [1]='Full Time Keeper',
  [2]='Occ Keeper',
}
-- create another key-value table (this time, country name is a key)
WKStatussMirror = {}
for k,v in pairs(WKStatuss) do
  WKStatussMirror[v]=k
end

fillCombobox(UDF1.cWKStatus,WKStatuss)


-- global variables
groupscancommand = nil


offsets = {
           DOB = 0,           -- +0 day, +4 month, +8 year
           Name = 0x-116,
           Surname = 0x-90,
           Nationality = 0xc,
           Nationality2= 0x10,
           BatType=0x9c,
           BatPosFC=0xa0,
           BatPosOD=0xa4,
           BatPosT20=0x128,
           BatPot=0xc8,
           FrFt=0xac,
           BaFt=0xb0,
           OfSh=0xb4,
           OnSh=0xb8,
           PlPa=0xbc,
           PlSp=0xc0,
           Agg=0xc4,
           DefAb=0x7c,
           BowlType=0xd0,
           BowlPot=0xe8,
           Skill=0xd8,
           Consistency=0xdc,
           Variation=0xe0,
           Mov=0xe4,
           FieldType=0xec,
           WKStatus=0xf0,
           FieldPot=0x10c,
           ThAc=0xfc,
           Speed=0x100,
           CatchNear=0x104,
           CatchFar=0x108,
           KeepCatch=0xF0,
           KeepMov=0xf4
           }

addrTable = {}

function num2HEX(num)
  return string.format('%X',num)
end

function easyReading(address)
  local T = {}
  for k,v in pairs(offsets) do
    T[k]=num2HEX(v+address)
  end
  return T
end

function groupScan(command,adjust)
  local MS = createMemScan()
  local FL = createFoundList(MS)
  local results = {} -- will contain found addresses (every address as string)

  --firstScan(scanoption, vartype, roundingtype, input1, input2,
  --          startAddress, stopAddress, protectionflags,
  --          alignmenttype, "alignmentparam",
  --          isHexadecimalInput, isNotABinaryString, isunicodescan, iscasesensitive)

  MS.firstScan(soExactValue, vtGrouped, rtTruncated,command,nil,
                       "00000000","7fffffff","+W*X-C",
                       fsmAligned,"4",
                       false, false, false, false)
  MS.waitTillDone(); FL.initialize()

  if FL.Count~=0 then
    for i=0,FL.Count-1 do
      local addr = ( "0x"..FL.Address[i] )+adjust
      results[#results+1] = addr
    end
  end

  sleep(100); FL.destroy()
  sleep(100); MS.destroy()

  return results
end

-- TCalendar  OnChange Event
function DateChanged(sender)
  local year =  sender.Date:sub( 1,  4) + 0
  local month = sender.Date:sub( 6,  7) + 0
  local day =   sender.Date:sub( 9, 10) + 0

  -- update group scan command
  groupscancommand = "4:"..day.." 4:"..month.." 4:"..year
end

-- TComboBox  OnChange Event
function ChosenPlayer(sender)
  if (sender.ItemIndex &lt; 0) then return end
  refreshClick(nil)
end

dobCalendar.OnChange = DateChanged
cbFoundPlayers.OnChange = ChosenPlayer

function btnFindPlayersByDOBClick(sender)
  addrTable = groupScan(groupscancommand, -offsets.DOB)
  cbFoundPlayers.Items.clear()
  if #addrTable ~= 0 then
      for i,v in ipairs(addrTable) do
      cbFoundPlayers.Items.add('player '..i..'/'..#addrTable)
    end
    cbFoundPlayers.ItemIndex = 0
  end

  refreshClick(nil)
end

function refreshClick(sender)
  if (#addrTable&gt;0) and (cbFoundPlayers.ItemIndex&gt;=0) then

    local address = addrTable[ cbFoundPlayers.ItemIndex + 1 ]
    local er = easyReading(address)

    UDF1.eName.Text =  readString( er.Name )
    UDF1.eSurname.Text =  readString( er.Surname )
    local NA = Nationalities[ readInteger( er.Nationality ) ]
    UDF1.cNation1.Text   = NA
    local NA2 = Nationalities2[ readInteger( er.Nationality2 ) ]
    UDF1.cNation2.Text   = NA2
    local BatT = BatTypes[ readInteger( er.BatType ) ]
    UDF1.cBatType.Text   = BatT
    UDF1.eBatPosFC.Text =  readInteger( er.BatPosFC )
    UDF1.eBatPosOD.Text =  readInteger( er.BatPosOD )
    UDF1.eBatPosT20.Text =  readInteger( er.BatPosT20 )
    UDF1.eBatPot.Text =  readInteger( er.BatPot)
    UDF1.eFrFt.Text =  readInteger( er.FrFt)
    UDF1.eBaFt.Text =  readInteger( er.BaFt)
    UDF1.eOfSh.Text =  readInteger( er.OfSh)
    UDF1.eOnSh.Text =  readInteger( er.OnSh)
    UDF1.ePlPa.Text =  readInteger( er.PlPa)
    UDF1.ePlSp.Text =  readInteger( er.PlSp)
    UDF1.eAgg.Text =  readInteger( er.Agg)
    UDF1.eDefAb.Text =  readInteger( er.DefAb)
    local BowlT = BowlTypes[ readInteger( er.BowlType ) ]
    UDF1.cBowlType.Text   = BowlT
    UDF1.eBowlPot.Text =  readInteger( er.BowlPot)
    UDF1.eSkill.Text =  readInteger( er.Skill)
    UDF1.eConsistency.Text =  readInteger( er.Consistency)
    UDF1.eVariation.Text =  readInteger( er.Variation)
    UDF1.eMov.Text =  readInteger( er.Mov)
    local FieldT = FieldTypes[ readInteger( er.FieldType ) ]
    UDF1.cFieldType.Text   = FieldT
    local WKS = WKStatuss[ readInteger( er.WKStatus ) ]
    UDF1.cWKStatus.Text   = WKS
    UDF1.eFieldPot.Text =  readInteger( er.FieldPot)
    UDF1.eThAc.Text =  readInteger( er.ThAc)
    UDF1.eSpeed.Text =  readInteger( er.Speed)
    UDF1.eCatchNear.Text =  readInteger( er.CatchNear)
    UDF1.eCatchFar.Text =  readInteger( er.CatchFar)
    UDF1.eKeepCatch.Text =  readInteger( er.KeepCatch)
    UDF1.eKeepMov.Text =  readInteger( er.KeepMov)
    else
    UDF1.eName.Text = ''
    UDF1.eSurname.Text = ''
    UDF1.cNation1.ItemIndex=-1
    UDF1.cNation2.ItemIndex=-1
    UDF1.cBatType.ItemIndex=-1
    UDF1.eBatPosFC.Text = ''
    UDF1.eBatPosOD.Text = ''
    UDF1.eBatPosT20.Text = ''
    UDF1.eBatPot.Text = ''
    UDF1.eFrFt.Text = ''
    UDF1.eBaFt.Text = ''
    UDF1.eOfSh.Text = ''
    UDF1.eOnSh.Text = ''
    UDF1.ePlPa.Text = ''
    UDF1.ePlSp.Text = ''
    UDF1.eAgg.Text = ''
    UDF1.eDefAb.Text = ''
    UDF1.cBowlType.ItemIndex=-1
    UDF1.eBowlPot.Text =  ''
    UDF1.eSkill.Text =  ''
    UDF1.eConsistency.Text =  ''
    UDF1.eVariation.Text = ''
    UDF1.eMov.Text =  ''
    UDF1.cFieldType.ItemIndex=-1
    UDF1.cWKStatus.ItemIndex=-1
    UDF1.eFieldPot.Text =  ''
    UDF1.eThAc.Text =  ''
    UDF1.eSpeed.Text =  ''
    UDF1.eCatchNear.Text =  ''
    UDF1.eCatchFar.Text =  ''
    UDF1.eKeepCatch.Text =  ''
    UDF1.eKeepMov.Text =  ''
  end
end


UDF1.show()
cbFoundPlayers.Items.clear()

-- for testing purposes (see "AA script for testing")
dobCalendar.Date = "1990-5-26"; DateChanged(dobCalendar)

refreshClick(nil)

function sSaveClick(sender)
if (#addrTable&gt;0) and (cbFoundPlayers.ItemIndex&gt;=0) then

    local address = addrTable[ cbFoundPlayers.ItemIndex + 1 ]
    local er = easyReading(address)

 writeInteger(er.Nationality,NationalitiesMirror[ UDF1.cNation1.Text ] )
 writeInteger(er.Nationality2,Nationalities2Mirror[ UDF1.cNation2.Text ] )
 writeInteger(er.BatType,BatTypesMirror[ UDF1.cBatType.Text ] )
 writeInteger(er.BowlType,BowlTypesMirror[ UDF1.cBowlType.Text ] )
 writeInteger(er.FieldType,FieldTypesMirror[ UDF1.cFieldType.Text ] )
 writeInteger(er.WKStatus,WKStatussMirror[ UDF1.cWKStatus.Text ] )
 writeInteger(er.BatPosFC, getControlText(UDF1.eBatPosFC,1,11))
 writeInteger(er.BatPosOD, getControlText(UDF1.eBatPosOD,1,11))
 writeInteger(er.BatPosT20, getControlText(UDF1.eBatPosT20,1,11))
 writeInteger(er.BatPot, getControlText(UDF1.eBatPot,0,100))
 writeInteger(er.FrFt, getControlText(UDF1.eFrFt,0,100))
 writeInteger(er.BaFt, getControlText(UDF1.eBaFt,0,100))
 writeInteger(er.OfSh, getControlText(UDF1.eOfSh,0,100))
 writeInteger(er.OnSh, getControlText(UDF1.eOnSh,0,100))
 writeInteger(er.PlPa, getControlText(UDF1.ePlPa,0,100))
 writeInteger(er.PlSp, getControlText(UDF1.ePlSp,0,100))
 writeInteger(er.Agg, getControlText(UDF1.eAgg,0,100))
 writeInteger(er.DefAb, getControlText(UDF1.eDefAb,0,100))
 writeInteger(er.BowlPot, getControlText(UDF1.eBowlPot,0,100))
 writeInteger(er.Skill, getControlText(UDF1.eSkill,0,100))
 writeInteger(er.Consistency, getControlText(UDF1.eConsistency,0,100))
 writeInteger(er.Variation, getControlText(UDF1.eVariation,0,100))
 writeInteger(er.Mov, getControlText(UDF1.eMov,0,100))
 writeInteger(er.FieldPot, getControlText(UDF1.eFieldPot,0,100))
 writeInteger(er.ThAc, getControlText(UDF1.eThAc,0,100))
 writeInteger(er.Speed, getControlText(UDF1.eSpeed,0,100))
 writeInteger(er.CatchNear, getControlText(UDF1.eCatchNear,0,100))
 writeInteger(er.CatchFar, getControlText(UDF1.eCatchFar,0,100))
 writeInteger(er.KeepCatch, getControlText(UDF1.eKeepCatch,0,100))
 writeInteger(er.KeepMov, getControlText(UDF1.eKeepMov,0,100))
end
end
</LuaScript>
</CheatTable>
