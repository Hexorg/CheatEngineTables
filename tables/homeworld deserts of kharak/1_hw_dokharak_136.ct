<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="19">
  <Files>
    <monojunk160117.lua Encoding="Ascii85">y+(MM,eWVUt2?+GVNa:tWKC)Te(o$[LZ@/M@fFf]ohCQa8AbI[/jUr:NNPyRu]kd5TkcOiU[Y?-N:dJ.FCP{Qiv[S*01IH3^?3fj^N;9piX{Taxmaz_UwF4@swAn373.2e[2n1%H=P0@g0WSdr7N}hvul;HE=unnM0{_mrazaPD)i}63MZ3E#2SH(eXNp{uXxsl!J^C=9^h37tK4GUR1RMC6*=(tWP-7]UD@SN[/+jDe[y3-n_!;FPujM]($GHriz+pU/JX,$$.W=GMR*h2x-2S:jk5p%dAV5KjZfcRrOi5,d)C3N,pH/po#=y2w:D9eIj@hwb;02K*BFw=2{:0Rs:9-jLQ7y[wHz2P+WKMaoKx6EYzbUn#{{-qSjBI/xMO,Ey4m$y$QuNrMb/G#ItJal)@Xv_D%p.cS4eMMq%9*7p)tC45_Q4b6mO+r=]6Z{.?$a,@EaoW!,bFSh5[j8N=z9CGR]CHVJyd0yIb:xkCG(*Hsyjh0ZV}$jtCCfcnmUPT}YFS1I,Pdx;/E^teRdHXYh3G5T7mQl73vb6VWY*xDW^pmhEbqMgvp8$/szL$rz{)XkZDj,ibW{Z@le[3O!oydt@Y,eARNdeU[S*vzV5dKM(nUz}scM]U5OnB4!sxF$?KagyH:7PzdtoL6E@m7^ZR)(1@cCeBQ*j5cbDfi9p}:,631PBh$0oN:86/z%+J}$P[p10M.+FL,:U{JB:boRxn]p(0KJVkKfK8l0I(xxdYq*6}lkqNrXWj*hdz,O9v3%#NWm?lPW?.fG!EI20FH}Zurg5ug-wvp]+FNMA3kyHAYkc;,4uaKuq[i6b4-);^.5Sr{YY+SFKeEW^*Oc3-/*Wq[fn_hjLleJdAQsYF*jm)[HA3,X3FJgl6/A7aR.pxut?*p^0#LRyvRH;,zu?cytIwGL1zalfIiSc8Wx;Z(u9xzQQnY$-7r(ddXilwPxflOv{h0QJE11g5$W0DlK[fP,0WY6LizFsubpwmPuO1MVS/3T$M;x-do]Dc-/6L7gl8*u//bqVuFh)i_/Ya5%m1dq)NquI)WrFMKwc{GbVZpR[}#hfRr8+XUtB7YR?9WDWp[},4SI%d[wT,-F8A$3RqL*Knrjumg?hIz(gBH@NQy]H,9C[[SIP!Q6{{L7Ix6@mUl(U8CX%/%{ekv[S=vHVb_EECnx}u;VR@/..hr6X,tBC2$p9(Mg;*tKv!!#CTgWbvqeoEopOXKfwI:sOf.!e/Phu$F%b1MCIe$AHwG2?@sEI:U?IbXBoLJ+CIHY3UT#+a+Jue?7SRC]kM2dpj@?CM3Zc%jYKvEOVJ0d1gHl0)=_1(l#m%ZX[#uet7[hp=MM@y:;YxVpp:1X[0h-Aq[-ink02mBW.R$v^!:oy9z^f00vMf%}0mNCAWYzufI0@0.rZ(!Pa{Lhy26y=iV(5_D!Pr%L13J!Hl*P9ehR+8Qv%q86,0r$kZG3%V8V.]Eeb4S%Lw4*zc4m]wP0siPv+Up_%YZnn^@Z;bLgTs#y#N@(]WP0vtJ?CN/1(N,QT$ER-w(NVPjXB+Ji6QItxk?aiLkSZ9@A0:Q7M9irwKfWkO^v(f@A0xaHZ5ED?^v,,L;Vrq/Fe%8eVB)mNcX,hb(ZY7jnQuB5jklA#ztO(?DAx:tn8BC*8,oFBn;W/o:9zX=8[}ne*Zw?+,#C:RgUgJj%HZS]:!z@(z5lvF1Zl*qRtk!!p-+p/z);)A]vLHxPagG4HVdBkyqH:e*Z+$?2zXSXsqwap?^@3H:}V0@NsHWD)Tr5]I)RwRGEcxh[]x0@936#19(5Do%(k8zQ)p+35bvruDHRM{Zb!)q?kqy?8w4K,B^ohr${(r$SBF%i^!Fch5rmI}UV$Lpj#jxy(XhhYszNYBdA@ZgNtX18}SvC3imqjNfB_K{b_^C@6x-]W9MKSWqt4:-%5q@]vK_K*5B_Bht{.$WnQ},v%)F1UM*)Rv$y]=x;(P[LVeH92QwcQ@0c2!;A{IzlDKQ$MK-dsKYFer?hJRh@5mK#+d;i=Z8!xehc@WucL4;j:mbXVN2DCSfx8!?hXgz=R2$ty/h}Lo1Bp.OeCG5^8P9J36Ol.zH3tLQ_Mg%,a[#l^gCeDw@AiP--#,Sf3sY_K7fW@SMfX8b#?v$0$=-+ABkCtpa?Vr+!X,hL0@T3;9U;J:!Q4wWr,FI%XYg%fljoQ0xNDA^:hO,(%a10(%3-V]05kR1.-7!mKv{?pOXxj92EP64SK3qPm1:muG)%u;(#;)+^qr.wI4?nmwN/3j0_BWz$92n80=P@zx_c%^}E,KAVAfChb7J{noO$5[aTZAT$Cc*$w_A5lXe;=mW?I3,lUprh!y[^G0z6aV.D)nZ9FcPuIH0VVpy7=bx]kz^SVvAR(^@ytfmQzvi.h6M9sYCsy@*rAPB*,Gps{f,XlzhPBb-YXevTYl0eE+MyQo;p+AoSwE}e%jHecbrmAV0NJ-WC?_rC]7P3MvIhLY1e[=igTfDtJdGq](1b//BSH?_+h{TWsL9]zssxrOiY[(/50%DtXgWg4$:E)[bMOmEst[DbGj1-%hebaX[wBFdv4$WFMlQTbpRN?SBzAPZCM18!(@f87f:!2(y[^5=$^PN]Fw9Lb-%.P2gfMf;fM79DVk3LTS[Tu#KNn#4a,6*jF@F[;9%RF,^R-$rdx2b=*)RRE!+;tr@I)c)imnEz[a$#nt0*9-cQUZ%GFtbo[8AS1DQ.9[Y+^+p539KN(Mv?.Jr,?jyo_oaZo0U!SD2do5p,:($U8^mF4t,=LDdtOZdV9tscL;YQ-V;RW[TKN1)cb@5koJs^=6JOiqF$hdYOM+hHSgw9:##4vJ7m+vsm8u08J,b]dj7[5]*T[XzeQhcR?L#)aey0AWvvgE*7#wDc/FtfP9IASRcjI*0(ki]zb3DGhAqxNr;bAesIZL{kt@+M)^:3)2W#aBz0ikB3.$4Q?ih7Nv3!EiR)zr[pFVbSJrkB^2DWk9?@#qq*iQqj.@(y)c1]LCy?{hnh_[o;ylD+orto);b;^=QDVsyZc%(iaj,D?EH)2s+:85QOH.b?^iv#EzPa]UQpdr{8?R=d/FK{uk)qf*]RC:,v;v*JQg5}IbI0w.[kdudLEb4m2*5:^Pbqv!*1Derz0VYl]aU=?GKkNmb!Hr93DO?21FpwOF#D!Xf4[A/qvs7+*HY)JjV=:f-%uwYp!EgKR+O/Y.$5%F6ZgEsgN2NwPK?7mef+sg(Y8PL(6el?hlohM,LZtM)afdW5xLsu/.9l)y@m3/Gr%Mj0izu9:?WZn})c}$t#+BS@A1OwBj@W{76}GEffT/vruY!RH0K6G]Z$VAFGc5MUBZU;5w=Xs]s(5:Pg%7n@3GOr_pf:Jn7/qOwM9[=LQfSX[QZW!hjwsv@o6s=SNVmn*$I+?}cZkr=Dj5/xiVXCe$MmSX47im5Uf?vFZr?Zt*%Epe^W2_9SXmJ(7^$hoyPT]JT{lPxZA+1+5Fd^m=a,l_V]_t(qH)!Z0e=1r*I:5Ee!R{8]tGuf7dPojn1u+_E!ztH7Q;N9fVSXt)1uVManly/PIe)?Bj.[VBTMGN3.bY(FJ^8rA87GhU@UfqKadXIS3@OvCX12s]zml9h(,q$hs@x.7oO?kt8KCv?WH,nmqmpid8@{l=1OKf)4aMnX?ebr*u_=/WgrvZ6_0y9()oYKg$i89D9DguiYy?OIV#B{xGK3W5,1S{ptLDvE)86S-4+1P.Fr@KU9UiJu5(]6ofXTaByx:8aCzZ+jL)1rKF08sD6AfHe0cj]OZi7SsI/YO@!D,0(x[70xHBf%#VX!,#(VsM-2i.QEmftLNpLEdQ6I+-mL[+l:zFR#+/Dls/NhTc/[W}8X5m45L/CxYIKUMpxfT.wP!jR.0DZu#3UqWMl.;@nPj1Hat4:ch6Y8_hf%bTE@cn@#*mF@8jD61Fi:1agnXY1LT@:SYSS3zb[08%kOS?1s#$a-Rd%Pgpcex)O4u0V{lX(qfgr.pqOamk$DunIPs^Q}z7e$0[-gW!^);p++)}ETqs?x[roQ/XXmLNJl^En]=9M*XoMG!rhRMyO^-)1p7A230SjADHk(KyMUS=xBB9rP_RR7FPyA%w5rJ3gfEN85VSWLy^[$1]0;7}3[h@s=aj#PcSSB+7sY)2rh#lz-w=ps!JFAP]d+*)}n?TbC_5wuL3LSE^K?4/kZC,/@lx!obZJIa5k#1SBUxwZpQn^ncXAv7!;:kErr0j}5M!+gNZ](OIjLA7DOq9Jf6K7K)vqxqdVVQ}aL_tRF86bIXsZq!%oVS={Ukc,LdSTOnWNA7H]3Ai;5alYw4h$AM7_HFK/H%A6aS,[}rV=bF/VrN-%j!JJFjw!:2@(1Gw98$5gVj4oM:lf$/DS(,(*WXcij(nDyj]O$uU.KaV@L$Bx/h];Qa%Zme%=#bhB[x5N1@3d.cJ1AVtb42++SaNp7Gf:hkL#vWy,_ogYY929UV+BQfg+OAdu6V@8(WcvlANlPXjTmK)(a1tvy7ZO[3Pc8NMyf2/3rS8AM-sz3YpZ}!B6ZyEtG3Y,=MQ6sfDU)!*=wKtZp8X2AKCC#dUsmpan]Jsak{aRW,%}_=SHtKe}roR58;;_Z{Vr7lm4Q7VPTlmJx%$UEz(9q*_KfNr%LTB]@As504zq-VkP*_u!tu6)7C$MR4xRkMfT7]X51uzFja_T1SJ?i[K:Rxr:lke]PWG0]4?/J?L/dpQ-8HB6QgjJ.GY=$u(]jzG8YZ:cto9m7go6nqF8Y@ThWA}d{7Q_v{9Ll6C0oV#APf^,ys*Fqf1nJp-m!(0Ui^0!LECTXf0x7?bm}Gu#Z8cz8*RJ+Lz}xl1CD*tG(/apeo2)l;6Zks[gzEj3U4m;UH0r8ZrPvd(0.vu#aPqS6$5R1xT/9W?5;0ok4N{S%/bn?Se89.MErf3(dJl9(%daA1WqjT}_1[RS@[hS)(=6Q3qhaH.dz(JGS6+3.vK,5U()DXMDNj+[K/@4mM=5KZy-6yf80si1s5CkKXr=akMndPtoBIxK4t)hgTUW?$#R8^S*/Oa4jbym3(:ypC4CaBlYZlj7^n#x9e4rbum@^TTwQ@/1;_L#eH]=nIE9^jg:!dMabP%29-r;.{Mta)*=A]?k;;MiTbDVO29hu*#4Se(fsuNU4nsR4EW!Q=3F=SFukGBrVMYkfBWp}x%}Moh;dA3yeq/29IvUE5OYCGV6rx1w.uTN@qcP:;+wQMmLXOEb3E{dPXLH0v0NssYN.nu(vo[P$1_P_c_Tgp6$oKz4hO^#,HjR).$cV(#KCY[F7$:xiM/JD%J@a!$/:[i/h7VT0GDcmPV=v3D3s!$fcWJh)NKPcL6TzX@ngeJZvgHLd-PDc]5H3:jyHIBPQeIO:}d%oe6z!9Z8]2gPlmTgrK-d=5HY0{b7]kvQ#,.S1+TN#r/(S0en8%ta9%B$]DdAUG8AFBzGwi=ncU#tih%eOgG+H_@AC*u7x@8mdrJCempg5#@Xa%);lAx^(*{a]@8]hF2fFjKNE]p}[TjNB;qWfHQgJH]PZ7H$c.5wam0$#R5BfW1X[oP_s56NR;99Y[0T_k.+9}.E@!_M};#F@Hju-X+N/D8DX%?ubSteegQ;TH52[Vp]X$St;llRs8W]00We2Dxi,6UqYjhB+?G3%vd#w}^y@Wh8Yj[l3NjKD{fi0L^,F4TqSHTk+ME5nPOAjWYCDD%yO.x_{QAdboFrzIKzM.ip{wmaCKT4].1NJgklBUxb19%!DqM}W{Ki]*9+vb}vYt{;r:NYT7OkPN.H*VtVWu5zo3IO=Lk+BVCVB1Qj{[s}6yffYYDQVC*!p}y2ztQ@SO$hZ#A?9e![G;}=kW.[.]zs$YiIv0/v28:{lK6G8(.^L.UQF22U%Z2p3Lf6*d:KUadZ$J*zh{S*Hn={}EGyq9L.+pLXP47sKG}biaZ.-;9uhNl;o^VDnD=#0BtzyPF1M%Y35Z7^*$%?1*X5?tqa5)A==3Onx[vq5rd7JFI)C!jbBaoc%yn%dCM7BPiZl(j3ga:UJ2lt3F$VI;%SV8FP=XJ/ODCIM5xhoX%F]]y0mRE9WZmePxmWVAYlga3R;AJ!9BX-lWBh{}^wYo.GU6cx*=4ql7(xJVeSvU,E5KF^y5[[J.r_HF{/=3{CdF?a-(pj0/VaxB%:JrHwc+sF(#6xb/+E?{hC_-Rnyx3;FP[@gP)s39PFpnl*Qev^o7mvXA2Y3QdbOM.:fShF-]-q4WCrTXpmK(.ue_16$.neL]5ig6z1m6TcnMzJo5wAB4Y.I]OcyO3^0bzeO9sl=It5MV,XK![h5u(tNSF1Z(Ck7V:)NkVrf]ruRFJLl,lt;9adDj,i)dyqxKt!k#_FbPGrx7;8(pZ#p(z=?HZID%DY8lZb!ftT}t@-lJt7k5OSXMokNGI];O{)aL.J@zZs1#BBRLOjq.Am}8R(L%j?K-t1OMRRrUur85K^y=QQvn;^V/O;TOkhvvGw27^mRIih+@G;x%fTeY,#3ioj0Xu};Q6,J.lyVU#Qpf/-T9l;Z^EK9/sYZ-LUHKGJKnUhI)!fw6%_cv*IHM?zW[y#Ns]gXZL#+CLOpY,VeoFtB52y2#bRf-,r8OLB},H@;!5h#LM9:%X1QA:y+JB5!BD7UcU82EyxxrX6N@VS8uGm!!%m]4HS{w1qnF{;Dx2yTicE)/1S,Be0jJMW!h5[VT/BqtR23TWMa7b}/TD/N+{:b+xxza#sL=T{s20QAe:}{7RatPQq;TX)*tG6[GIO3p*M5+Gb@rq(+[KEz]mO}%8rk48%tYwvUM#Uv+},D4)s@-c+R%%s@owd#0iN@]]{#tv@#5:Aph+fe[)N[wY)#I2j*XNCYUXJxtfgtSY8aMSvj{RphR4jEpjc-W2Gf/M?xi,+^YE;TIYxR@Uho{*hRrG$VaS5ZGTvyYOefyeN[M:#Wmr=7QV,qqg@zU0Hg0$FrwXYO$H.p?Sid-gFY(bMl_l77q)}oCY_a!5rbYpL$]+]E/=siux}!1Se7JdHTkK0[!$%Tr-E:$]JE39?Im,y;!B9jZ!/h3+DH#qr5Ro@JB@dTopor3zFK#3wc@@xw0Z8/HHS+WB[?}-7?E3;;gwAQN0Zj/RY(stwKGCMDXvz.DbtCvZ!uADnK(Uyj0C$vNQ04z-0SQebEV{v+Q,RpFx:wW=4$W6Ds#=lHu9cXM+vJ-WDDH#lz.EIh77oIWC9S?PG,qkhVu*P1eZ$sb!-!P)[dKO9xW1gNG{R@GVTnUmYv9J=[NxAH4k:H1iI.m2Ceq[n;9iFA?/5.kVHx?esdTcS/A,r7]HP7Iri#.I[WeHd3j!3qe++</monojunk160117.lua>
    <MRAA.lua Encoding="Ascii85">r5W39,sJjF4fqfGFqLbNjK[53$1S+llNiOKNwA2GzG#)zB1bmCYllPGf+@l.(zT#C6y;CCF0#luw;kH7y!+;9zohl*$;+.h++fkDamR$nss_F0gI6@tyZdd!qK(xeM19k=tXvh0_NSoEStBA5!(8^lRT2w-:Pho),]RvEyY#5H]1t#s]o5;LKdV]:KRr1.De5FH$hxZ%k/{FuJS,W^6;FMiJUBfeBwG^s8byM4jEF}85za*%D{qqJma#{4eec[O]@FD1gTHwahZQX_c/UG+jw2!#AWtAxS?A:DLrfQvuqr*0ksk,[Y,0l3cz62.WzT{gl7xcdw51u1:=b+J,f);AhrgF_tqTFV[W;]6BCqPo72{=i5_0U4gL$%OPNl2]tNZ_YkhCUzF}2zD%SfKI-OA5sb@(LX@FWD.:s.hJL!yXSeXFCM[8C_7vSqYu!CuuvxY]Ql.}Obyu)t(57p*mCRi$2^VA0=^ike5[DwU[e5c}#Vl^%#C;#Rx/fo4*@Pmfu[Nc/wrg-$HF;C5*,q@{%/bb+3t5vE.gs)1]c@jQYXR@*:r*#GvQ]YM[qafoHcd8I.KeOg@uZ2e4I;oEA(x:X@kCiQFD(?c;x%S-YI3fej]QxgD*1p]RZwT#2{]0Am^k_J)f+KeBOCGup1dIM2vBMRC$ryG*0q:[?$0*_zpA,kYJIYf,qDEDm]%RvwIB43]KfUNQlK1E6bICk+S)(}D6KsN!{d.n/fa_Cu^xJwqpW8nTjkitM75Zw%1S@ofKfT;v]eDBPYc8Q_5);m49#*:4Q=QCtBwV%KGbzp#^-1VW+b?%}o]Xw$IoZWwBWzDx:SyJ:VlO!F2H:q7^f.VZ)S:$y[E4.CYEfXMP$?LA4!DIf:l4w@(BYoh/UaLypuH:Dai3nl!,gt5CO1p_y%0vudjEQfU(lHYzMeA%a7XXc=kbKOU@;#Qt..U1hj=kFdln}PLeg1M%nf./:1[2aG[;r{.2!ghTA)M]=TdI.XC.@^J=xN{%lLiBc!I;Qx5+M7skOU,w1,gnnkOUILgLU3Rp*f}_=tsNk!C[H/u_;}e3wD;cAoEsGRp.8eWTfGB!=?UzB)ADjNI3Pb+p5x%?NiWzGzstmc!U9mAqs^P?XijnWddJT.HRWslZ],yN{$i!fDD*dRWa/TIV^0KMIEP#qVMUD]2LT?%nL(YE*2cd)hL0Hz}*D9.,9_=.t)OKLvld)!G!-/a0M8cSTG=A1w+}kk!Vk3OLLe+D*t0n#[L+WisMMd$a-Kx2l+!ma@E:y@payV6:4F-C77FC6rf505@(7IL@-loo}sCkanpdH[w^Wh[+NYc6Qcw;yv;72H-^I)veJMpg*eGtR7ft:K1e1%b8$B^xw+UKPBSRY4iIB(YgkYhit6a/^r2}dh%ilK=E7#TY$_^!S=PGjKHClUr%XHoJ4jSQFktCpxUuIrfzN,.agm9wbsk[:a,O]i70Egtuw-Qek=YV?V!;@m.%#fvijF.y9.zAVwGJ:TuhOV7[}1SMQ0:o![XQSLd{jr890l[]R.u1?#[cAagdggz5;EQJ(9Y^/$S(v0^t$RfrPQ(R]DA^V]aun@foV#KV68xkDk#uh)N?wXx=Z)/HhTB(-E[J+T7}*$Fp.{,@L5Gh/2aitMee9EjGy:0KVkv31ZaYxAIHROy]7d-Rw?Mo#xO,840HvPj_7;T5p_^M%XBN7/Hm}e;jQSl-qqCwwD=zEAV2zs^!HTN]Y69I*T=Fh,fb_3w8/g)HmcsYHqjoXGyf3?,K*s@e(}/^dxor$rO)tp)4@zhTY4m}SjN4/0p3Q95hZZ?oNKDE97jjL;*c@/1zwmBnp857FUl[G6DJW,neg.Okzj[iNWo#V00:KOv/G{6CHv*k5Ms!^%^%^JT;Vs3DP6j/UCgN!ZjeI@%qu#eWAB!8g$(pULT:IlqK4dr:8y5#UhW8;FMGiDb+7q+0oLZQI6uxGoITv![)[;k[]f!89XmT8JPgB]AIxMPpE_m}y{QR[:?MN9G:VqcgU!+0x-7w*5G8QNE9Cm)E?56rRZ;o0rHpg-1-y-:_NNIPC:Pt=R6IQ-sL./%-pX}tIu94..S!Tph*L?[@mLTye3P4GlY/TN+V0wqI!*mO[WV@]I?.SP*WdmPMYuRv.@YUxpze#nwd!,#3.1r)gWzG[hkuS%(t3oSbqZ]?f+P,I*Z1vcN6](RkE}:;KvN,zDIqG@%6LRVgmF@dk+R+^HfdKj[p1Utre(/6#fC!ch[X)ZZiZQ9N,+7IE^nY3lE54fhQ8KA;Enf1z8owYm5O8u,88Fq29Zq/iag#Tjbh[eT5gADO+(FzgaH87:,J6y$HA^XLOi%yFuDB@^q^%C2o%TNyl:HP!7wxDD57a]u?8WJpWChJ.]?2Lgpa2su1yEtimLP$FppW%c;wd,)mSj^Ke2?ZE#g=N4Y*A_ghDVdp?_(.9_aE%7]W7H[!3vzVOW7MsM_j*lo8)m61=l5y{f6hc2J(:P.$U,Kj,^LF6!/M%ne=gl^i_)lhZ8Du$}):*7%ksYOiHxPj]#oaOzRG:fv77j[.0dg^WySceo0oyZzM2HQe*?$!+ej(4WH@w;/ske)@0?UIdXJzEOLBvu#wPVNPd(G.;_mwfW_7+FlDbLift1S^!Y;CApiMk8IUFxWA?QVi,IP*GGZS!Gd6/b-Q7,3xPv?e.-WcEo}E1%UbXgl}iz)2ZdKXBon[nfwo):U+53K*$26+;xn?h](%=WsEl%,D1{/DAP@KRDt{%t-J0f)4BuvpZ=ol[83sR.G)3vrIhNLIdU,j.w])Pj29pdzg9pQ]p!+=c89[:l5M#H53vlQkp/^!VP3@6G*g1-H]E%%iYH$^#9oV3+$x_um9EvaK[;Hb:AV@Wy4Z*!7F@nI2TPF8YS:kh/WED7/:hRfWPaFQhJy={yn:I^610$,V$aPf^C%J4K;2:?_H4CFxoYrxL3QfU54msmPpH^#$gWCwmG;lgu1ba?H;?WZ7S+KJDqE}W^j?(Zn59M2}7St19lGuL$</MRAA.lua>
  </Files>
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Homeworld Deserts of Kharak (click 1st: load Scripts)"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}
if syntaxcheck==true then return '' end
--

-- common function
local Apack,Unpack = table.pack or pack,table.unpack or unpack
if loadTableFile == nil then
  local loaded = {}
  function getLoadedChunks(p)
    p = type(p)=='string' and {p} or p
    local r,c = {},0
    for i=1,#p do
      local v = loaded[p[i]]
      if v~=nil then
        r[p[i]]=v
        c = c + 1
      end
    end
    return c, r
  end
  function loadChunks(t)
    for i,m in ipairs(t) do
      loadTableFile(t[i],true)
    end
  end
  function loadTableFile(n,mode)
    local hdr = 'loadTableFile: '
    assert(type(n)=='string',hdr.."input should be a string -"..tostring(n).." of "..type(n))
    local m = assert(findTableFile(n),hdr.."can't find table file -"..n).Stream
    m = assert(readStringLocal(m.Memory,m.Size),hdr.."can't read content -"..n)
    if type(mode)~='boolean' then return m end
    m = assert(loadstring(m,n),hdr.."lua script load fail -"..n)
    if type(m)=='function' then loaded[n]=m end
    return mode and m() or m or nil
  end
end

local target= {"monojunk160117.lua","MRAA.lua"}

local skip_Print = AA_CHECK~=true and ( true )
-- suppress informative or warning message, not error throw

if getLoadedChunks(target)==0 then
  local original_print = _G['print']

  if skip_Print then _G['print'] = function()end end
  loadChunks(target)
  _G['print'] = original_print
end

Bit64 = targetIs64Bit() and 1 or 2

{$asm}

[ENABLE]

useDomain()

[DISABLE]

monoDetach()

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>225</ID>
          <Description>"Start Setup &amp; Tools (click 2nd: Global Storage)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
LuaRet(AddAssm('BBI.Game'))
globalalloc(__,$4000)
__:
dq __

__+08:
{$lua}
if getOpenedProcessID()==0 then
  return "db 0"
elseif targetIs64Bit() then
  autoAssemble("define(PSIZE,8)\nregistersymbol(PSIZE)")
  PSIZE = 8

  return "db 8\nMR(64,Color=0xff)\nMR(32,Color=0x00)"
else
  autoAssemble("define(PSIZE,4)\nregistersymbol(PSIZE)")
  PSIZE = 4
  return "db 4\nMR(32,Color=0xff)\nMR(64,Color=0x00)"
end
{$asm}

//__+2c:
//dd 1

//MR(32,Active = true)
//MR(64,Active = true)


[DISABLE]

</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>250</ID>
      <Description>"32bit &gt;"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <Color>000000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
assert(__+08,4)
[DISABLE]

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>237</ID>
          <Description>"rapid"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]


Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(pwf,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','ProcessWeaponFire')) // static 3: 1-2-1
Eval(ammo,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','set_HasLimitedAmmo'))
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.CommanderID','ID'))
//Eval(saet,$GetMonoMethAddr('BBI.Game.Simulation.WeaponsProcessor','ShowAttackingEntityToTarget'))

assert(pwf,55)
globalalloc(wfo,$200,pwf)

wfo:
dq wfo,pwf,cid,plyr

label(done)
wfo+20:
readmem(pwf,16)



wfo+80:
push  ebp
mov   ebp,esp
pushad

mov   edi,wfo+18
mov   eax,[ebp+08] // attacking entity
sub   esp,08
push  eax
push  edi
call  cid
add   esp,0c

mov   edi,wfo+10
sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[wfo+10]
cmp   eax,[wfo+18]
jne   done

mov   eax,[wfo+30] // rapid factor
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)8
@@:
cmp   eax,(float)16
jle   @f
mov   eax,(float)16
@@:
mov   [wfo+30],eax

// mul deltatime
fild  qword ptr [ebp+0c]
fmul  dword ptr [wfo+30]
fistp qword ptr [ebp+0c]

// set use no ammo
mov   eax,[ebp+14]
sub   esp,8
push  0
push  eax
call  ammo
add   esp,10

done:
popad
pop   ebp

ReassembleEx(pwf,_Len)
jmp   pwf+_Len


pwf:
jmp   wfo+80

[DISABLE]
[wfo+08]:
readmem(wfo+20,16)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>240</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>wfo+30</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>241</ID>
          <Description>"speed move"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
MVPA0 = GetMonoMethAddr('BBI.Game.Simulation.ManeuveringProcessor','TickManeuvering')
MVPA1 = MVPA0+0x40
MVPA2 = MVPA0+0x80

--print(MVPA0,MVPA1,MVPA2)
{$asm}


Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

Eval(mvp,$GetMonoMethAddr('BBI.Game.Simulation.ManeuveringProcessor','TickManeuvering')) // static 1 : 2
Eval(mvs,$GetMonoMethAddr('BBI.Game.Simulation.Maneuvering','TickManeuver')) // static 1 : 2
Eval(mvd,$GetMonoMethAddr('BBI.Game.Simulation.Maneuvering','TickDeathManeuver')) // static 1 : 2

AOBScanRegion(aob1,$MVPA0,$MVPA1, b8 ?? ?? ?? ?? 8b 08)
AOBScanRegion(aob2,$MVPA1,$MVPA2, b8 ?? ?? ?? ?? 8b 08)

globalalloc(spd,$200,mvp)

spd:
dq spd,mvp,mvs,mvd
dq aob1,aob2 // +20 , +28
spd+40:
readmem(aob1,7)
spd+48:
readmem(aob2,7)

spd+50:
dq 0
spd+60:
dq 0,0
spd+70:
dq 0

label(nomod)
spd+80:
pushad

mov   edi,spd+60
mov   eax,[ebp+08] // attacking entity
sub   esp,08
push  eax
push  edi
call  cid
add   esp,0c

mov   edi,spd+68
sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[spd+60]
cmp   eax,[spd+68]
jne   nomod

mov   eax,[spd+50]
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)4
@@:
cmp   eax,(float)8
jle   @f
mov   eax,(float)8
@@:
mov   [spd+50],eax

mov   eax,aob1
mov   eax,[eax+1]
mov   [spd+58],eax
fild  qword ptr[eax]
fmul  dword ptr[spd+50]
fistp qword ptr[spd+70]

popad

mov   eax,spd+70
mov   ecx,[eax]
ret

nomod:
popad

readmem(aob1,5)
mov   ecx,[eax]
ret


//aob1:
//call   spd+80
//nop
//nop
aob2:
call   spd+80
nop
nop


[DISABLE]

[spd+20]://-&gt; aob1
readmem(spd+40,7)
[spd+28]://-&gt; aob2
readmem(spd+48,7)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>244</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>spd+50</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>245</ID>
          <Description>"unit production resource free"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
RES1 = GetMonoMethAddr('BBI.Game.Simulation.AbilityProductionResourceCostsMetValidator','GetProduceUnitResourceCost')
RES2 = RES1 + 0x50
--print(MVPA0,MVPA1,MVPA2)
{$asm}

Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

AOBScanRegion(cost,$RES1,$RES2, 83 c4 10 85 c0 0f)

// 83 c4 10 85 c0 0f

globalalloc(res,$200,cost)

res:
dq res,cost

res+20:
readmem(cost,16)



label(done)
label(nomod)
res+40:
ReassembleEx(cost,_Len)
jne   nomod                 // no resource string case, will give free resource
pushad                      // but we need to check if player
sub   esp,8
lea   edi,[esp]

sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[ebp+0c]
mov   [res+30],eax
add   esp,8
cmp   eax,[edi]
jne   done
xor   eax,eax
inc   eax
test  eax,eax   // should be jne
popad
jmp   cost+_Len
//
done:
popad
test  eax,eax
nomod:
jmp   cost+_Len




cost:
jmp   res+40

[DISABLE]

[res+08]:
readmem(res+20,16)

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>248</ID>
          <Description>"unit production instance"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
RTIME1 = GetMonoMethAddr('BBI.Game.Simulation.AbilityHelper','GetAbilityProductionTime')
RTIME2 = RTIME1 + 0x30
--print(RTIME1,RTIME2)
{$asm}

Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

AOBScanRegion(rtm,$RTIME1,$RTIME2,8b 75 0c 85 f6)

globalalloc(rtime,$200,rtm)

rtime:
dq rtime,rtm//cost

rtime+20:
readmem(rtm,16)



label(done)
label(nomod)
rtime+40:
ReassembleEx(rtm,_Len)  //
je    nomod
pushad                      // but we need to check if player
sub   esp,8
lea   edi,[esp]

sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[ebp+10]
mov   [rtime+30],eax
add   esp,8
cmp   eax,[edi]
jne   done
//                          // should be je
popad
jmp   nomod
//
done:
popad
test  esi,esi
nomod:
jmp   rtm+_Len




rtm:
jmp   rtime+40

[DISABLE]

[rtime+08]:
readmem(rtime+20,16)

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>251</ID>
          <Description>"PopCap adder"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
{$asm}

Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(popc,$GetMonoMethAddr('BBI.Game.Simulation.Commander','get_PopCap'))

Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

globalalloc(popcap,$100,popc)

popcap:
dq popcap,popc

popcap+20:
readmem(popc,16)



popcap+40:
pop   dword ptr [popcap+3c]
push  @f
ReassembleEx(popc,_Len)  //
jmp   popc+_Len
@@:
push  dword ptr [popcap+3c]
push  ebp
mov   ebp,esp
push  edi
push  eax

mov   eax,[popcap+30]
test  eax,eax
jge    @f
mov   eax,#30
@@:
cmp   eax,#300
jle   @f
mov   eax,#300
@@:
mov   [popcap+30],eax

mov   eax,popcap+18

sub   esp,0c
push  eax
call  plyr
add   esp,0c

mov   edi,[ebp+08]

mov   eax,[edi+cmdID]
cmp   eax,[popcap+18]  // local player commander ?
jne   @f
mov   [popcap+10],edi
@@:
cmp   eax,[popcap+18]  // local player commander ?
pop   eax
pop   edi
pop   ebp
jne    @f
add   eax,[popcap+30]
@@:
ret


popc:
jmp   popcap+40

MR(32/PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[popcap+08]:
readmem(popcap+20,16)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>252</ID>
              <Description>"add amount"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>popcap+30</Address>
              <Hotkeys>
                <Hotkey>
                  <Action>Set Value</Action>
                  <Keys>
                    <Key>191</Key>
                  </Keys>
                  <Value>100</Value>
                  <ID>0</ID>
                </Hotkey>
                <Hotkey>
                  <Action>Set Value</Action>
                  <Keys>
                    <Key>220</Key>
                  </Keys>
                  <Value>0</Value>
                  <ID>1</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>253</ID>
              <Description>"Commander Pointer"</Description>
              <Options moHideChildren="1"/>
              <LastState RealAddress="00000000"/>
              <VariableType>String</VariableType>
              <Length>0</Length>
              <Unicode>0</Unicode>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>popcap+10</Address>
              <Offsets>
                <Offset>0</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>254</ID>
                  <Description>"Name"</Description>
                  <VariableType>String</VariableType>
                  <Length>255</Length>
                  <Unicode>1</Unicode>
                  <ZeroTerminate>1</ZeroTerminate>
                  <Address>+010</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>255</ID>
          <Description>"slow heating (high divisor for virtuallly no heating)"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--print(string.format("%X",GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedHeat') or -1))
{$asm}

Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(inch,$GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedHeat')) // static 3

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
//Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

globalalloc(heat,$100,inch)

heat:
dq heat,inch

heat+20:
readmem(inch,16)

heat+30: // mode, no heat or mul, mul factor @heat+38
dd 0

label(done)
heat+40:
push  ebp
mov   ebp,esp
pushad

mov   edi,heat+18
mov   eax,[ebp+08]
sub   esp,08
push  eax
push  edi
call  cid
add   esp,0c

mov   edi,heat+10
sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[heat+10]
cmp   eax,[heat+18]
jne   done


mov   eax,[heat+38]
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)4
@@:
cmp   eax,(float)1000
jle   @f
mov   eax,(float)1000
@@:
mov   [heat+38],eax


lea   edi,[ebp+10]

mov   eax,[edi]
cmp   eax,[heat+3c]
jle   @f
mov   [heat+3c],eax
@@:
mov   eax,[edi]
test  eax,eax
jle   @f

fild  dword ptr [edi]
fdiv  dword ptr [heat+38]
fistp dword ptr [edi]
@@:

done:
popad
pop   ebp
ReassembleEX(inch,_Len)
jmp   inch+_Len


inch:
jmp   heat+40

//MR(PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[heat+08]:
readmem(heat+20,16)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>257</ID>
              <Description>"divisor"</Description>
              <VariableType>Float</VariableType>
              <Address>heat+38</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>258</ID>
              <Description>"last max heat increment (all entity)"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>heat+3c</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>259</ID>
              <Description>"clear last max heat inc"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
heat+3c:
dd 1
[DISABLE]
heat+3c:
dd 0

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>260</ID>
          <Description>"no powerpool decrease (power likely maxout soon, no harm?) "</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--print(string.format("%X",GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedpower') or -1))
{$asm}

Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(decp,$GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','DecreaseCurrentReservePower')) // static 3

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
//Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

globalalloc(power,$100,decp)

power:
dq power,decp

power+20:
readmem(decp,16)

power+30: // mode, no power or mul, mul factor @power+38
dd 0

label(done)
power+40:
push  ebp
mov   ebp,esp
pushad

mov   edi,power+18
mov   eax,[ebp+08]
sub   esp,08
push  eax
push  edi
call  cid
add   esp,0c

mov   edi,power+10
sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[power+10]
cmp   eax,[power+18]
jne   done

xor   eax,eax

mov   [ebp+10],eax

done:
popad
pop   ebp
ReassembleEX(decp,_Len)
jmp   decp+_Len


decp:
jmp   power+40

//MR(PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[power+08]:
readmem(power+20,16)

</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>262</ID>
      <Description>"64bit &gt;"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <Color>000000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
assert(__+08,8)
[DISABLE]

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>263</ID>
          <Description>"rapid"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]


Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(pwf,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','ProcessWeaponFire')) // static 3: 1-2-1
Eval(ammo,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','set_HasLimitedAmmo'))
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

//Eval(rott,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','SetCurrentTarget')) // static 0

//Eval(rott,$GetMonoMethAddr('BBI.Game.Simulation.HarvesterProcessor','GetHarvesterCountOnTargetNode')) // static 0
//Eval(rot2,$GetMonoMethAddr('BBI.Game.Simulation.WeaponsProcessor','DeactivateWeaponsForUnit')) // static 0

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.CommanderID','ID'))
//Eval(saet,$GetMonoMethAddr('BBI.Game.Simulation.WeaponsProcessor','ShowAttackingEntityToTarget'))

assert(pwf,55)
alloc(wfo,$400,pwf)
registersymbol(wfo)

wfo:
dq wfo,pwf//,cid,plyr

label(done)
wfo+20:
readmem(pwf,24)

//wfo+60:
//dq rott,rot2


wfo+80:
push  rbp
mov   rbp,rsp
//pushad
push  rcx   // -08
push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

mov   rdi,rcx
//movsxd  rcx,dword ptr[rbp+38]


mov   rcx,wfo+10
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,wfo+18

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

mov   eax,[wfo+10]
cmp   eax,[wfo+18]
jne   short done




mov   eax,[wfo+50] // rapid factor
cmp   eax,(float)0.1
jg    short @f
mov   eax,(float)8
@@:
cmp   eax,(float)16
jle   short @f
mov   eax,(float)16
@@:
mov   [wfo+50],eax


// mul deltatime
mov   rax,[rbp+38] // deltatime
mov   [wfo+48],rax
fild  qword ptr [rbp+38] // deltatime
fmul  dword ptr [wfo+50]
fistp qword ptr [rbp+38]

// set use no ammo
mov   rcx,rdi  // wfo item
xor   rax,rax  // false
sub   rsp,8
push  rax
sub   rsp,20
mov   r11,ammo
call  r11d
add   rsp,30


done:
//popad
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
pop  rdx
pop  rcx


pop   rbp

ReassembleEx(pwf,_Len,,wfo)
jmp   pwf+_Len


pwf:
jmp   wfo+80

[DISABLE]
[wfo+08]:
readmem(wfo+20,24)
unregistersymbol(wfo)
dealloc(wfo)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>264</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>wfo+50</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>265</ID>
          <Description>"speed move"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
MVPA0 = GetMonoMethAddr('BBI.Game.Simulation.ManeuveringProcessor','TickManeuvering')
MVPA1 = MVPA0+0x150

--print(MVPA0,MVPA1,MVPA2)
{$asm}


Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

//Eval(mvs,$GetMonoMethAddr('BBI.Game.Simulation.Maneuvering','TickManeuver')) // static 1 : 2
//Eval(mvd,$GetMonoMethAddr('BBI.Game.Simulation.Maneuvering','TickDeathManeuver')) // static 1 : 2

Eval(mvp,$GetMonoMethAddr('BBI.Game.Simulation.ManeuveringProcessor','TickManeuvering')) // static 1 : 2

//AOBScanRegion(aob1,$MVPA0,$MVPA1, b8 ?? ?? ?? ?? 8b 08)
//                               00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17
//                                              00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17
//                                                             00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17
AOBScanRegion(aob,$MVPA0,$MVPA1, e9 ?? ?? 00 00 b8 ?? ?? ?? ?? 48 8b 00 48 ?? ?? ?? 48 83 ec 08 48 8b ce)

alloc(spd,$400,aob)
registersymbol(spd)

spd:
dq spd,aob // +0 , +8
spd+40:
readmem(aob+5,24)

spd+60:
dq 0,0
spd+70:
dq 0

label(nomod)
label(done)
label(finish)
spd+80:

//push  rbp
//mov   rbp,rsp
//pushad
push  rcx   // -08
push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

{
mov   rax,spd
mov   eax,[rax+41]
mov   [spd+70],eax
mov   [spd+5c],eax
}

xor   eax,eax
dec   eax
mov   [spd+60],eax
mov   [spd+68],eax

mov   rdi,rcx
//movsxd  rcx,dword ptr[rbp+38]


mov   rcx,spd+60
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,spd+68

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

mov   eax,[spd+60]
cmp   eax,[spd+68]
je    short @f
xor   rax,rax
jmp   finish
@@:


mov   eax,[spd+78]
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)4
@@:
cmp   eax,(float)8
jle   @f
mov   eax,(float)8
@@:
mov   [spd+78],eax

mov   rax,spd
mov   eax,[rax+41]


//mov   [spd+70],rax


fild  qword ptr[rax]
fmul  dword ptr[spd+78]
fistp qword ptr[spd+70]


mov   rax,spd+70

finish:
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
pop  rdx
pop  rcx

//pop  rbp

test rax,rax
jne  done
nomod:
reassemble(aob+05)
done:
reassemble(aob+0a)
reassemble(aob+0d)
reassemble(aob+11)
jmp   aob+15

//aob1:
//call   spd+80
//nop
//nop
aob+05:
jmp   spd+80


[DISABLE]

[spd+08]+05://-&gt; aob
readmem(spd+40,24)
unregistersymbol(spd)
dealloc(spd)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>266</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>spd+78</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>267</ID>
          <Description>"unit production resource free"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
RES1 = GetMonoMethAddr('BBI.Game.Simulation.AbilityProductionResourceCostsMetValidator','GetProduceUnitResourceCost')
RES2 = RES1 + 0x70
if bDebug then print(RES1,RES2) end
{$asm}

[ENABLE]

//Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

AOBScanRegion(cost,$RES1,$RES2, 0f 85 ?? ?? 00 00)

cost:
db 90 e9

// 83 c4 10 85 c0 0f
{
alloc(res,$200,cost)
registersymbol(res)

res:
dq res,cost

res+20:
readmem(cost,24)



label(done)
label(nomod)
res+40:
ReassembleEx(cost,_Len,,res)
jne   nomod                 // no resource string case, will give free resource
pushad                      // but we need to check if player
sub   esp,8
lea   edi,[esp]

sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[ebp+0c]
mov   [res+30],eax
add   esp,8
cmp   eax,[edi]
jne   done
xor   eax,eax
inc   eax
test  eax,eax   // should be jne
popad
jmp   cost+_Len
//
done:
popad
test  eax,eax
nomod:
jmp   cost+_Len




cost:
jmp   res+40
}
[DISABLE]
{
[res+08]:
readmem(res+20,24)
unregistersymbol(res)
dealloc(res)

}

AOBScanRegion(cost,$RES1,$RES2, 90 e9 ?? ?? 00 00)

cost:
db 0f 85

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>268</ID>
          <Description>"unit production instance"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
RTIME1 = GetMonoMethAddr('BBI.Game.Simulation.AbilityHelper','GetAbilityProductionTime')
RTIME2 = RTIME1 + 0x30
if bDebug then print(RTIME1,RTIME2) end
{$asm}
[ENABLE]

//Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

AOBScanRegion(rtm,$RTIME1,$RTIME2,0f 84 ?? ?? 00 00)


rtm:
db 90 e9

{
alloc(rtime,$200,rtm)
registersymbol(rtime)

rtime:
dq rtime,rtm//cost

rtime+20:
readmem(rtm,16)



label(done)
label(nomod)
rtime+40:
ReassembleEx(rtm,_Len,,rtime)  //
je    nomod
pushad                      // but we need to check if player
sub   esp,8
lea   edi,[esp]

sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[ebp+10]
mov   [rtime+30],eax
add   esp,8
cmp   eax,[edi]
jne   done
//                          // should be je
popad
jmp   nomod
//
done:
popad
test  esi,esi
nomod:
jmp   rtm+_Len




rtm:
jmp   rtime+40
}


[DISABLE]



{
[rtime+08]:
readmem(rtime+20,16)
unregistersymbol(rtime)
dealloc(rtime)
}


AOBScanRegion(rtm,$RTIME1,$RTIME2,90 e9 ?? ?? 00 00)


rtm:
db 0f 84

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>269</ID>
          <Description>"PopCap adder"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
{$asm}

Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(popc,$GetMonoMethAddr('BBI.Game.Simulation.Commander','get_PopCap'))

Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

alloc(popcap,$100,popc)
registersymbol(popcap)

popcap:
dq popcap,popc

popcap+20:
readmem(popc,24)

popcap+30:
dd #30      // INITIAL popcap add amount
dd #300     // Max popcap add amount allowed

popcap+40:

pop   dword ptr [popcap+38]
push  @f
ReassembleEx(popc,_Len,,popcap)  //
jmp   popc+_Len
@@:
push  dword ptr [popcap+38]

push  rax

mov   eax,[popcap+30]
test  eax,eax
jge    @f
mov   eax,#30
@@:
cmp   eax,[popcap+34]
jle   @f
mov   eax,[popcap+34]
@@:
mov   [popcap+30],eax

pop   rax
{
push  ebp
mov   ebp,esp
push  edi
push  eax

mov   eax,[popcap+30]
test  eax,eax
jge    @f
mov   eax,#30
@@:
cmp   eax,#300
jle   @f
mov   eax,#300
@@:
mov   [popcap+30],eax

mov   eax,popcap+18

sub   esp,0c
push  eax
call  plyr
add   esp,0c

mov   edi,[ebp+08]

mov   eax,[edi+cmdID]
cmp   eax,[popcap+18]  // local player commander ?
jne   @f
mov   [popcap+10],edi
@@:
cmp   eax,[popcap+18]  // local player commander ?
pop   eax
pop   edi
pop   ebp
jne    @f
}
add   eax,[popcap+30]
@@:
ret


popc:
jmp   popcap+40

MR(64/PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[popcap+08]:
readmem(popcap+20,24)
unregistersymbol(popcap)
dealloc(popcap)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>270</ID>
              <Description>"add amount"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>popcap+30</Address>
              <Hotkeys>
                <Hotkey>
                  <Action>Set Value</Action>
                  <Keys>
                    <Key>191</Key>
                  </Keys>
                  <Value>100</Value>
                  <ID>0</ID>
                </Hotkey>
                <Hotkey>
                  <Action>Set Value</Action>
                  <Keys>
                    <Key>220</Key>
                  </Keys>
                  <Value>0</Value>
                  <ID>1</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>271</ID>
              <Description>"Commander Pointer"</Description>
              <Options moHideChildren="1"/>
              <LastState RealAddress="00000000"/>
              <VariableType>String</VariableType>
              <Length>0</Length>
              <Unicode>0</Unicode>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>popcap+10</Address>
              <Offsets>
                <Offset>0</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>272</ID>
                  <Description>"Name"</Description>
                  <VariableType>String</VariableType>
                  <Length>255</Length>
                  <Unicode>1</Unicode>
                  <ZeroTerminate>1</ZeroTerminate>
                  <Address>+020</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>273</ID>
          <Description>"slow heating (high divisor for virtuallly no heating)"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--print(string.format("%X",GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedHeat') or -1))
{$asm}

Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(inch,$GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedHeat')) // static 3

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
//Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

alloc(heat,$200,inch)
registersymbol(heat)
heat:
dq heat,inch

heat+20:
readmem(inch,24)


label(done)
heat+40:
push  rbp
mov   rbp,rsp
//pushad
push  rcx   // -08
//push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

mov   rdi,rcx
mov   rbx,rdx
//movsxd  rcx,dword ptr[rbp+38]

push  rdx

mov   rcx,heat+10
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,heat+18

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

pop   rdx

mov   eax,[heat+10]
cmp   eax,[heat+18]
jne   short done


mov   eax,[heat+38]
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)4
@@:
cmp   eax,(float)1000
jle   @f
mov   eax,(float)1000
@@:
mov   [heat+38],eax


lea   rdi,[rbp+38]

mov   eax,[rdi]
cmp   eax,[heat+3c]
jle   @f
mov   [heat+3c],eax
@@:
mov   eax,[rdi]
test  eax,eax
jle   @f

push  rbx
fild  dword ptr [rsp]
fdiv  dword ptr [heat+38]
fistp dword ptr [rsp]
pop   rdx
@@:

done:
//popad
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
//pop  rdx
pop  rcx


pop   rbp

ReassembleEX(inch,_Len,,heat)
jmp   inch+_Len


inch:
jmp   heat+40

//MR(PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[heat+08]:
readmem(heat+20,24)
unregistersymbol(heat)
dealloc(heat)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>274</ID>
              <Description>"divisor"</Description>
              <VariableType>Float</VariableType>
              <Address>heat+38</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>275</ID>
              <Description>"last max heat increment (all entity)"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>heat+3c</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>276</ID>
              <Description>"clear last max heat inc"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
heat+3c:
dd 1
[DISABLE]
heat+3c:
dd 0

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>277</ID>
          <Description>"no powerpool decrease (power likely maxout soon, no harm?) "</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--print(string.format("%X",GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedpower') or -1))
{$asm}

Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(decp,$GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','DecreaseCurrentReservePower')) // static 3

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
//Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

alloc(power,$200,decp)
registersymbol(power)

power:
dq power,decp

power+20:
readmem(decp,24)


label(done)
power+40:
push  rbp
mov   rbp,rsp
//pushad
push  rcx   // -08
//push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

mov   rdi,rcx
mov   rbx,rdx
//movsxd  rcx,dword ptr[rbp+38]

push  rdx

mov   rcx,power+10
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,power+18

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

pop   rdx

mov   eax,[power+10]
cmp   eax,[power+18]
jne   short done

xor   rdx,rdx

done:
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
//pop  rdx
pop  rcx


pop   rbp

ReassembleEX(decp,_Len,,power)
jmp   decp+_Len


decp:
jmp   power+40

//MR(PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[power+08]:
readmem(power+20,24)

unregistersymbol(power)
dealloc(power)
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>__</Name>
      <Address>9F2F0400</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>MT</Name>
      <Address>9F2F0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>rtime</Name>
      <Address>06BD0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>res</Name>
      <Address>06BD0200</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>PSIZE</Name>
      <Address>8</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
</CheatTable>
