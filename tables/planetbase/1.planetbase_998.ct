<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="19">
  <Files>
    <MRAA.lua Encoding="Ascii85">r5W39,sJjF4fqfGFqLbNjK[53$1S+llNiOKNwA2GzG#)zB1bmCYllPGf+@l.(zT#C6y;CCF0#luw;kH7y!+;9zohl*$;+.h++fkDamR$nss_F0gI6@tyZdd!qK(xeM19k=tXvh0_NSoEStBA5!(8^lRT2w-:Pho),]RvEyY#5H]1t#s]o5;LKdV]:KRr1.De5FH$hxZ%k/{FuJS,W^6;FMiJUBfeBwG^s8byM4jEF}85za*%D{qqJma#{4eec[O]@FD1gTHwahZQX_c/UG+jw2!#AWtAxS?A:DLrfQvuqr*0ksk,[Y,0l3cz62.WzT{gl7xcdw51u1:=b+J,f);AhrgF_tqTFV[W;]6BCqPo72{=i5_0U4gL$%OPNl2]tNZ_YkhCUzF}2zD%SfKI-OA5sb@(LX@FWD.:s.hJL!yXSeXFCM[8C_7vSqYu!CuuvxY]Ql.}Obyu)t(57p*mCRi$2^VA0=^ike5[DwU[e5c}#Vl^%#C;#Rx/fo4*@Pmfu[Nc/wrg-$HF;C5*,q@{%/bb+3t5vE.gs)1]c@jQYXR@*:r*#GvQ]YM[qafoHcd8I.KeOg@uZ2e4I;oEA(x:X@kCiQFD(?c;x%S-YI3fej]QxgD*1p]RZwT#2{]0Am^k_J)f+KeBOCGup1dIM2vBMRC$ryG*0q:[?$0*_zpA,kYJIYf,qDEDm]%RvwIB43]KfUNQlK1E6bICk+S)(}D6KsN!{d.n/fa_Cu^xJwqpW8nTjkitM75Zw%1S@ofKfT;v]eDBPYc8Q_5);m49#*:4Q=QCtBwV%KGbzp#^-1VW+b?%}o]Xw$IoZWwBWzDx:SyJ:VlO!F2H:q7^f.VZ)S:$y[E4.CYEfXMP$?LA4!DIf:l4w@(BYoh/UaLypuH:Dai3nl!,gt5CO1p_y%0vudjEQfU(lHYzMeA%a7XXc=kbKOU@;#Qt..U1hj=kFdln}PLeg1M%nf./:1[2aG[;r{.2!ghTA)M]=TdI.XC.@^J=xN{%lLiBc!I;Qx5+M7skOU,w1,gnnkOUILgLU3Rp*f}_=tsNk!C[H/u_;}e3wD;cAoEsGRp.8eWTfGB!=?UzB)ADjNI3Pb+p5x%?NiWzGzstmc!U9mAqs^P?XijnWddJT.HRWslZ],yN{$i!fDD*dRWa/TIV^0KMIEP#qVMUD]2LT?%nL(YE*2cd)hL0Hz}*D9.,9_=.t)OKLvld)!G!-/a0M8cSTG=A1w+}kk!Vk3OLLe+D*t0n#[L+WisMMd$a-Kx2l+!ma@E:y@payV6:4F-C77FC6rf505@(7IL@-loo}sCkanpdH[w^Wh[+NYc6Qcw;yv;72H-^I)veJMpg*eGtR7ft:K1e1%b8$B^xw+UKPBSRY4iIB(YgkYhit6a/^r2}dh%ilK=E7#TY$_^!S=PGjKHClUr%XHoJ4jSQFktCpxUuIrfzN,.agm9wbsk[:a,O]i70Egtuw-Qek=YV?V!;@m.%#fvijF.y9.zAVwGJ:TuhOV7[}1SMQ0:o![XQSLd{jr890l[]R.u1?#[cAagdggz5;EQJ(9Y^/$S(v0^t$RfrPQ(R]DA^V]aun@foV#KV68xkDk#uh)N?wXx=Z)/HhTB(-E[J+T7}*$Fp.{,@L5Gh/2aitMee9EjGy:0KVkv31ZaYxAIHROy]7d-Rw?Mo#xO,840HvPj_7;T5p_^M%XBN7/Hm}e;jQSl-qqCwwD=zEAV2zs^!HTN]Y69I*T=Fh,fb_3w8/g)HmcsYHqjoXGyf3?,K*s@e(}/^dxor$rO)tp)4@zhTY4m}SjN4/0p3Q95hZZ?oNKDE97jjL;*c@/1zwmBnp857FUl[G6DJW,neg.Okzj[iNWo#V00:KOv/G{6CHv*k5Ms!^%^%^JT;Vs3DP6j/UCgN!ZjeI@%qu#eWAB!8g$(pULT:IlqK4dr:8y5#UhW8;FMGiDb+7q+0oLZQI6uxGoITv![)[;k[]f!89XmT8JPgB]AIxMPpE_m}y{QR[:?MN9G:VqcgU!+0x-7w*5G8QNE9Cm)E?56rRZ;o0rHpg-1-y-:_NNIPC:Pt=R6IQ-sL./%-pX}tIu94..S!Tph*L?[@mLTye3P4GlY/TN+V0wqI!*mO[WV@]I?.SP*WdmPMYuRv.@YUxpze#nwd!,#3.1r)gWzG[hkuS%(t3oSbqZ]?f+P,I*Z1vcN6](RkE}:;KvN,zDIqG@%6LRVgmF@dk+R+^HfdKj[p1Utre(/6#fC!ch[X)ZZiZQ9N,+7IE^nY3lE54fhQ8KA;Enf1z8owYm5O8u,88Fq29Zq/iag#Tjbh[eT5gADO+(FzgaH87:,J6y$HA^XLOi%yFuDB@^q^%C2o%TNyl:HP!7wxDD57a]u?8WJpWChJ.]?2Lgpa2su1yEtimLP$FppW%c;wd,)mSj^Ke2?ZE#g=N4Y*A_ghDVdp?_(.9_aE%7]W7H[!3vzVOW7MsM_j*lo8)m61=l5y{f6hc2J(:P.$U,Kj,^LF6!/M%ne=gl^i_)lhZ8Du$}):*7%ksYOiHxPj]#oaOzRG:fv77j[.0dg^WySceo0oyZzM2HQe*?$!+ej(4WH@w;/ske)@0?UIdXJzEOLBvu#wPVNPd(G.;_mwfW_7+FlDbLift1S^!Y;CApiMk8IUFxWA?QVi,IP*GGZS!Gd6/b-Q7,3xPv?e.-WcEo}E1%UbXgl}iz)2ZdKXBon[nfwo):U+53K*$26+;xn?h](%=WsEl%,D1{/DAP@KRDt{%t-J0f)4BuvpZ=ol[83sR.G)3vrIhNLIdU,j.w])Pj29pdzg9pQ]p!+=c89[:l5M#H53vlQkp/^!VP3@6G*g1-H]E%%iYH$^#9oV3+$x_um9EvaK[;Hb:AV@Wy4Z*!7F@nI2TPF8YS:kh/WED7/:hRfWPaFQhJy={yn:I^610$,V$aPf^C%J4K;2:?_H4CFxoYrxL3QfU54msmPpH^#$gWCwmG;lgu1ba?H;?WZ7S+KJDqE}W^j?(Zn59M2}7St19lGuL$</MRAA.lua>
    <monojunk160117.lua Encoding="Ascii85">y+(MM,cvWIt2?+G0jJbMvZgdv,UCu3LOYI}[VTVt]kLIEn@6:GMM5@uBB;!M$G%,rx4,%RH%KYz[4OrfL.^P(VzFOX0Q}R(]O{{i^.F8A*6/L9CjFIno2E+Vs#vk@idSEMg?5z/;#rDF*mge=;omJ(3G33uicjdJZkYOAZmO(,;MEQ{CJ{208T)izEno4h3xfwij5YYrCtl=S;!xz;%2(WBo^$K{-gIdPAoK%OAOE@a,cx=5DL!r65]WL?GA+iPJdIy+o,lswRu$dd@XjswI2O)V0OaLjbvHhHbCovhVD1%DgEv]ItUIdv@vRIOo91O+*vxOASDxl}KuA!,JFDsrMhYc=fmM89yj+v8Z+fdv7qKN!eH}x0qGA:l=c$E+HS1;AbK+BJM6s-64tF%Vw]Z%mLR6w02QQJ^xJX,;dSjz)1xiGEi)I?FJp3dICKqpCK7aZ8j4Jet2G9gRWmodD4wrErVGUzB(f49Yhk2AFLA5Ctya]weJ=Dtvkd4Q^Bi0oquQxy)U#6Q=C*(#4WpM@i+G{iN/y]b1+X?L:MH3eyfySa-4pU2D3OIS%NFo@n5vKx^0J,VEOYvq+SEo;./i6JpFq+Gg=v}F_J#z-rGV^lw;MSrZ?T(d+6PM8F!YGEOfYBm2KRzTz-rQ3,[y_qdF{s.f:Yr0gm;OYytb[.^F1c.tx=$Gv47Gv}U;+;Snieui4LgAOi]P*Qg2[(!$l)//m[3^mMfmvL^66X9W^Nt%4Nx*sZz=TjSdVfRtpN*I5Z:V!#W#}GLYaUn0WTXmy0UKg%]Y#]q02*?a!Ex_frU0kwgA?GvE%;@[vaKET[Nmw,NEdp3XNB-L/vTZDqoX%f?Z;4s@;#7Epi-MIPBiKdR3:6$([0G*}tkLv=;:I6iJ$.g14dR8-WaW9@mWop}HAI2t[iDsg4QTZBKTJonYOpnEQ2wCg75HFUs[i_Jc-ukh=G}BfmwZTNDV6=Jlac/Y8gMqRpP5nVwZ8sZ({eX(Dz}Qj}F3CRO;#0FTG)rl]8GD(v5Sk692}xGZ7u%[))*mfsmP?XYiMR(h^JbyI1KEjb0P[fSlLOZSP;W,y]Fv#jPeq!5SM@x%PbLh$R_dSZzbkS5!K6rd+-.)wpOJiK1;is!#Hb.jHF#d#RnM5/rK=4aQ-=}3X(FswGti_8kR8?VRz8q3rG3BaBm5Du7{by[rSs5uhB@o,,Spi(d.+(2@6v68IWBBqW@IZPEmS=fwBs=-?$2;OH:Eb-JT18r/-G%B;_SqqeaE3)FDK}$/U0zftRakE.zLQTlB$ZjC.s9HqqNDj.;F=E)zTdb-JGfB{NloASTzw/^-ZdS#=).(9nfYwDWQrm*{3?TtBN;m@epqWg9KL=WufI$-)o=ulp,@TXLe9W;W%i/IbK%7-cR)%=7C%[%WRLZ$,%*!gLK]*/H;@r6]7]sYuK+m^%oTr($Xsk_70+[$FrK@s%)e.@OIJk!Wp7B}kdh2+Q=Ic}5);6hSJWyv55Qo)t=Cl@luA9(ckYS;aVWPXb=O.AGLue4i52L/6bbOwm+miifw@Oc8w3$*ZSw.75+!iHOAmK;?4-[*t;jQ8+6u@}2jtn/V7q+@hqJWEMo2KEFVrFTFl.x0yDt93o,$Tae=J]8{iUpdbrVITjCH9ya4f{$j:_{3%d6#Ba7Bh3c+j!#?Y4r=x!YI$C,ypHWwQzliXkD!N(]=#}B/C;A@/Ah5R5i9YRjV5azXt,1d;W5c?bO/o[o7/Xp+O0Zc!(IW$-Ar5Ja5pll}vppmsJc^QYdm^y#zR5w$.jN.Xq/j)2Ew/COA6*Y2+(yWGF67d_j?K6}DmpIuG(34NNgk1AKjsL4[nUNd^ISf_P$0ofU.CMp$E$m.i3rK{bGB^Uob%e$jSm).b-C.-7rjAURe{GXs0xCU=3s0d0ljLsQmg^.se+;%_tv9no=QN[,/BaE59Fclie.ld;F(09Bog%H8=E]E6bIj.87+(3,q-wvLn6?q{nP6jDgZBmj(Dge)ofAxV]86f]it#{*=SsG=9^LeY5xr76q}7b5z{3p3Q9XC*!r5+l0FQGiHN]DwR+l$ji]/!IM?46z%0e1V6Q,)331WR/.IE)eXV3;foUXgGD$2YF]umhyPo8?vkcI;ll9IV#f+tm@1{xSxL.g[Cjg(B%?Ls+b_C=r6oUFp^RDtA(;WCFoppVGUs-]WafPlT^S{$.a(hhAn+)ohyIan5_VAI1Bs_BKaAAvuA5L;S;XYS,3%:;)E@74XOB@6IWa6jq=eWBHYf+/YXD;muA[XklxIm=maVGxpJ_N6IQ5fFANCBQ]uIx5*a3Tn6z9(s.+Txi=rpvm_w8q$AYhN/O9TSp{{w%labhylZ@.@LlC_Lc!$d9R[OV]hPqT{-kvM4@_Ccy?AYyCL5!S_I3T0AX9+nu50K(Y#_^wAswDx}@Pkm_]0WQJE:k{G;MDK/QQS@%fB=9/fS+LqV@9RhQ!M-qK4Y0.3]inH$;W}E7@Z.j#A{C:gHFk@w!p.g^zpvP#^zTN8UBL[-kv*WP?Xd*k:yNyu-%X,ssS6,Im;LF-N8CC+]B4UCq.W!S8X=7r1W4W8EAA.]zti%p@spBAQlG]AQFsf80=P@zxzAe_9cSEfB:OA9,o)@XfmlH-^nX]gx2k)q{?eHyNwb/#$fl]IxBW^R^T4ic[w;2hL*CT9+;Kq;nMegXp(}AC$[W1]upt).kw@:R?/onX(P!^SQYV{XZ!p?1q;x-alk.}-jG;#8a,_H+?]CDen{DtUW(C{r9G{$a#0qJ+6HJ@L7^q8eM-8%^z[*h@O]My7h;.8P%K#U@0@KY(9:zx;FZ}2U_AKmcV)Q]i,J7C9jv1xL^,BOoUJw}lR#_KZqT{rYM!35mNuMhE7m_43ZsopkA7fjVQ2E2+]c1RW@)SY%[KX6oG+*thbWJCn3##-3F[b{3O,Mw4Zl1,JuCAtEAx1X_5QL=3j?{/MX^-P[Lt^pf3,4nN)}SgGclM8D*Y#hTY/[M-KK(bi=-v/;87h=I*@uBby;o@BNcjdaw(}zi]0Te7#LYdR0dHz,Eg=Nz{q!%R)GNcHWKuh6_m#/DR(}5MIwD-cM-c=7+{6k%dHY?dY:d^/a[-c%rc_+SSGl:[ZxV$[kYTyzSFnW6XgOmR7p+sw0Sp]Bu{nH=BGqqg(6yiq-ECIL.VZC=I+.p[${IEJ+$p:jstW@mC-)!PS3f@[QLu,nLZK{%F-k[1lm+:^oO8EGpup]4siWSEF#*=5xLxMF%hPW.ovS5LNC.I=ZV%#T_7y=dnBG/B{Bhy%cqZ:b-rH3C/3-o,VXYS@3@ha@Zb^X-+!#vFujS{xQNquLDn;e_EBPFJaxweZEZ4#wz.qm!FTKl=RJBkDa_}gns(1Yi={#_y74r!xsSORBnwwtwnp^;r$!)x:E,AX7mK?(hgd:,N1uk5tZEQq?Gy*.U9Wgrxw9iTIGbodG8!,y!}rG[XKd$)wLmkNaRDuuOI!d2$,1aX$VvEcRe*Nj!i_]yP[d3#yh}w)a;+OK-+3Og1uy*3W0ET@wrcHGsg[P*0{!!+@?Co0?1o13l;^ZsCdCLmvDDtl-?#1-Zf03CxSz,0TPGYClI)QJVIe}cT]Mc6rkjd9p.g$iu5Tx*#g^0r%qtQ%KwYqxZ-Rj,04y3;aOzE(G}7yyM-nR-aE/68if_k[xiaanh(qJ^dK*Poj67W#;QJ_HvM!$OwAo.F/gmgGv#ox#EmCFi@ii{UF+4NA(?AaLcI2h)T}u8oPYR)s0lYvV=Toyxey.25(HBf+SYa{b#4w7rDR)KCW4jarh8YBliG%of/Vc6wmeJ}lWmZHk,!fGgVo24gq/d=US7m}=,5G1;;59}X!eB$TM88FG1QO[+C;[*x6h=I1RPLwRRZBA+u@_.a#}*[V#dN6q*ZUsRta?,C52k}6*li[Uy2WVuT?]rA?NPJ4:C^A^RK.3tlf^4!d^/l,75=O^it)]y-aMv3X%yQ9rU522o6OD{;KLzB#VmN1:1dAy.2KBj#%d/J1!O%#CCCI+CFVuI!wLs[,LU5F1NE2P6_678HmBvfUIF7:/Ah8+FP2Nu$uV_@),kgId/GowGlo{7U^#yr!]uH?ia*_Yr41fbX(-)6tmwS$EXD-6nE3sEc#A@:^IGq0!yMJZq2Q_eFjnbT.YFeDiNs[*DFLGoqlb9^ajKqpkRFOc;kkJwqt/$h)E,c7^yjh(?S+{4-H]CSDgMcIn__g:#DFAD,YD%rCP%KJp%iUNoJ-i3G]]4rR,Q-}wzbQ^WEd.iDK-kSy2^cnq^0_fE^GhBqVip*2UZBba/!Ux^(xsZ,ssl8.0Wal,oM)e0c/X@2,h1{[yMN3J*Nc);l8${O,-i:3-c^NRE,q(J?cYjbBSALs/D,[)[X+1w4FX,f*WwQ]X-z=h{?G9,az_-x/FGIA!(pV!v5gckiH#l;rIn!QbLX:CScLnu3?H@1/xm+H4$A{I79+3)F??6(%6rMA.k;?WAZpCLM;]z)gnpPxukui9Ln?CvbvxXreH-FnE4]SQV2DJ#2^=xFyt$Hwb+p5sHpvsExgj:MT0E%PEy#$J,_0CKz!@NZgawd1Orb;[_YH=?gEzQKVBC43?wujU)hgStc#!JIVYeu#9wJ2V8THmLB{SOfm%zC11%bI/e1SE;uw{,r[bx[r#?e9E2jqrV:lpMhi(Am%hu(;aB@}DPg#qD!=OPNp/H;0Wk._-n}eA8NBjAK6Z?w3y}JZcfdfU$ivwEniNhrB,3Nn$yx)MYkh!=lq43ku/m]%PAZqD^RxX(*r2]M.IAU0h=duav-U#q8?D+:3D[Y7y@4m2kG4dLXS9?1::]EukEFQGk.Q0hWN#bx}+t510XiCe,=Y3%LUsR5r4ejZo+JvG+^gVrlt*H]z4PT^qXJsB_(1xB@tBx:]i^07(hl{}QxZr(n(K_#=pG3_Q82Jkm!-VXqo:.4oR]y@[nJRHI*xNM[^4?)dV/.ahz}[UBG+O4f*rGeCV(OE%=t93znFJ6fvvJHq2{-3bq,_1K*;^PmhqT2W7[fP8bIfH@f3@)}qi}kspBXM.VZxwfP6hLLWE%l5ta1fJlHxjBDneF1+6K)l+.U%a,U7oX2?51OfuQE-5]}[miDDR[K}fj(I;n3HLM=,QM-YL13=lh?bPTVbEY%h=TG6]neMSalQr4i^506k{[ZMLl0k%-h]}FmS10Z%y7#RZgu=@Cy657203A_uNQ+QDMf*ZGDC]_/GX*,96eqk[4thnVNxAXi%$pj[q66dxof,Q._bN8V401Vh;,QPYG3ocynhqQutrN{ws%O%gcFE}mib=awxfZ;I^8b#$t$R6eQkZ^yAT%V%BA26L3/^n/Dpq7;Y66}MJIfH3ArKRMny8H6D8Vha9=#I_xzT_ejDzYxdtZGYX1KdKB3$3[sjwka2w7#*4#5xhVJIf$fkxF@!2y2=Zs5+Wrb1,eVXI=T]MZSu=bTJK@/I+J/Sd0PvTamqxNC2kS6w0LH(Gv6kzMYGIPl8yh:E6IGf5q],lMXQ#b[z]7MvUu$mnRQ?c%,[;d#enZ0bJwJ!#n^XONhlZVOC2%Svg%--hDjd;5%oa*47BYrsi.v^U8ljDK0#8+MvA24$Dbic%GPZraF}R(8*Q:9;XD8i{@iJDIIj0Kf@+2ih{}.m-_FP]56Y$6[Yy%76/Tr=ar]AHMO0uRx[Y?gQra.42eoF8z/tM9a=MBasU2eczaYTQ,xvvQ,hEMdit%cr{mzKPF4C#O^E-9k#/JLtF:b^MJk;QMHsFv8o,Zd9Q,#!h_e(%l/6^m*5x_Wzkzg5NdM=]r%81[8TWFX/O6(H_EQcN2.y6ionL6#[]BVQN3O@h?it58j2P{Dc1iHA3+sul2/#Kc?0g]o#?Cc+qU#;uA4LNU=c]-16*nAc7tXqBKcC}-(Oh6hH.WVr*OeQB1y#8th=oEZt)r36=.pRb-Zk=B3(n?X(!T.;457ACA}R.Jlvr[#rp0^tI+7x2eL5r1oDX7q9wHa(f?/}p,@ZGg#ZC{yxClzWc}JZYQwo-0@6Kpr4Z,z31iS5qgC_x;n)mVkO4CRrn6rC)ow.WvUwYRf*KPzP==E5[KkcwbeLp7_ylK{v,?UW?$iq1D8jDvNM$WlP[YTF-S(M-gf2p_:#D,tWr/9mE5C[/C9-iHqqvEI[=K.hPOb5X9QS(.d$5sKxv.ZHvZDDZ#ZoJ63p^p3gJulI/@:d^x$lV+?!_$SXPoJm{xhe%/EkfdviXL[CNVL?N$;:=-VfCvpB%^Zp82(oPrsZK(8ZnN5t}Cx)9jVjOVpT+JIIZhaU}uF*+e(.#[w1;y@ETOa2g2:4w!rSl?(?7;mMDEP-P*gXcLG4k4)=gPASMAlu!K-IB3z{DQOXxwjF2eAV]OVBO_PI-pIXHtOc5JWCX;.;=0JLtBX-lWBU$JwwY,)tOq2_r%%scmXv@X69;HIB3foA0nqF+LE-$l+qldzH=#Va[OMdfeZjW-qLk3bI9x^]?,$mI,.MLb.#lGOW.,}gF$7a{pe$=?jWRnrTcm%dTz#V_1BVd+Ta,WFVBa59lP_KiiIi.%UmphaYPTg+0?v;-i?NK}-Q$eXr.]N$:(JDF14;pr]R]zGp?qf/08Abhe:42POpwwnvt=opg7*%(MPkC[)9Fn]gfJt^GS!(?E:WX#Mt?]4J#X]C8Ki[io):sFc,[ND3^K=eT4Qm#eoJKT;.4SXt=G1PK@dS(Ks%H{IK_Enoujm+k?InZii@zUk$b6n*Yo)[4*eUDD[?R[}skXDk1)E[0gwrt=6}F.DCL#l*1ABWsgLZ(zxzNhbXI9({y0oL0n0o[3hPEI/Y{+rxGMxAfg1DcazkT]o*$2EJfBoCp,mJRLdB;YJmYWY]QBlyyQTJ4fJ{.!(B+_#xmKc4Ip]PB/)0I44BJ5;z7L#W.=p]{n0hJ{^NGNW)Sc4F+S$K:2cNviqh9r+NRnao+.^k_2F=d9w=!H%{$w{0%hPvrE]jHN*vZ:a+rYi@$h:;dXoI2AJp5=W_g(qdct3+RDGL_$cpYfPR2mhtaW!^lSjfOczu@6WQ.V4pBWui*Q8v]I*Vx{=6@nQ^h7F*ox18DHTltgOMcTMQg$ONCExMb!YEHPZ!N}IvuxjeLMSOawWNi_yl9][OZ?=vG[_KH=6bxCOOAK]S@$UZeXB5l(W;8Gu+rcWbP!=2b%Q(77#JZA0yX]W;mY_peEAH2O%-.1zEj++[tFL.NbVYA993_VlI#v2W#;FB.zvf}z*CQX70IRxt#K2RmwsNG4QOr#1NBj;EExjcjyd0KhPRNkPa/*e)vnIu8yDDY_;m0).dn%^fbWr:j:![5.?VlJ8uZ%MRu*A5]/p)G9_%FIV+WG9g)%).bZH3u1ptjp;G4C](6$nINQ-bhB]JeCpz.OM)+/j+Tzu$S{qz)VNk[G-_=f_yO]/HN@Fb!DI82fDf.I+,h=ffQK1Ik@D06%i:c_9S$gJ}gxK+;^M-!%N0:$]f(?zG[nCR1Q*t+;uE4CP8E4K9}-C:Vq8W2s.+i@)}}fQWzIQ/jT#ZY:aFWQdQrxls?D7d@X(ahk%DU4pps(8.^$o]ol_D?{!q_xCdb)*z0}L!a$${VHw(8A#?[4/A,r7%jXjZOeUvk@!,.d]3*}0gy^64o8e2a/^+xD==Bu}FkgsDbiD3/lZY}N+3tE,a]7S#UFf6eVn))#8i[td+[ckCh_*f*hf*6o5Ph}MzCn]dK6G#Q0@G=[INN]J@x$bSKZ)NG]:hyk-$7o^-hO%894w(E[hE0_Spz(:K/:a!cUQ(9YJaisUaG$}NfzsD2Vn.mB/7?8f%kHinhfByu3!s)n9KSDh;vJdq}6^K-T:HTg!UJ$^LqQ_a*Lo%!P1p/2_$c/Hj;](hYa[6!xMVmk8mcU6Ezuo-p3sDdO[q?9DY.1on^+1iT/jL.fnaQj2[HZCOtK5kuyp+L!FuYqN(_I4G+@T?LT8E^Q]iOG.$wkTWN%+f#R9#s^T,;QVY,?%i9myW?,;F@.iE3</monojunk160117.lua>
  </Files>
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Planet Base (click 1st: load Scripts)"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}
if syntaxcheck==true then return '' end
--

-- common function
local Apack,Unpack = table.pack or pack,table.unpack or unpack
if loadTableFile == nil then
  local loaded = {}
  function getLoadedChunks(p)
    p = type(p)=='string' and {p} or p
    local r,c = {},0
    for i=1,#p do
      local v = loaded[p[i]]
      if v~=nil then
        r[p[i]]=v
        c = c + 1
      end
    end
    return c, r
  end
  function loadChunks(t)
    for i,m in ipairs(t) do
      loadTableFile(t[i],true)
    end
  end
  function loadTableFile(n,mode)
    local hdr = 'loadTableFile: '
    assert(type(n)=='string',hdr.."input should be a string -"..tostring(n).." of "..type(n))
    local m = assert(findTableFile(n),hdr.."can't find table file -"..n).Stream
    m = assert(readStringLocal(m.Memory,m.Size),hdr.."can't read content -"..n)
    if type(mode)~='boolean' then return m end
    m = assert(loadstring(m,n),hdr.."lua script load fail -"..n)
    if type(m)=='function' then loaded[n]=m end
    return mode and m() or m or nil
  end
end

local target= {"monojunk160117.lua","MRAA.lua"}

local skip_Print = AA_CHECK~=true and ( true )
-- suppress informative or warning message, not error throw

if getLoadedChunks(target)==0 then
  local original_print = _G['print']

  if skip_Print then _G['print'] = function()end end
  loadChunks(target)
  _G['print'] = original_print
end

Bit64 = targetIs64Bit() and 1 or 2

{$asm}

[ENABLE]

useDomain()

[DISABLE]

monoDetach()

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>225</ID>
          <Description>"Start Setup &amp; Tools (click 2nd: Global Storage)"</Description>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//LuaRet(AddAssm('BBI.Game'))
globalalloc(__,$4000)
__:
dq __

__+08:
{$lua}
if getOpenedProcessID()==0 then
  return "db 0"
elseif targetIs64Bit() then
  autoAssemble("define(PSIZE,8)\nregistersymbol(PSIZE)")
  PSIZE = 8

  return "db 8\nMR(64,Color=0xff)\nMR(32,Color=0x00)"
else
  autoAssemble("define(PSIZE,4)\nregistersymbol(PSIZE)")
  PSIZE = 4
  return "db 4\nMR(32,Color=0xff)\nMR(64,Color=0x00)"
end
{$asm}

//__+2c:
//dd 1

//MR(32,Active = true)
//MR(64,Active = true)


[DISABLE]

</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>250</ID>
      <Description>"32bit &gt;"</Description>
      <Options moHideChildren="1"/>
      <LastState Activated="1"/>
      <Color>0000FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
assert(__+08,4)
[DISABLE]

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>319</ID>
          <Description>"decay rate"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>define(cave,indc)
define(hack,idec)

[ENABLE]

Eval(idec,$MONO'Planetbase.Indicator::decrease')

alloc(indc,$200,hack)
registersymbol(indc)

assert(hack,55)

cave:
dq cave,hack

cave+20:
readmem(hack,24)

cave+70:
dd (float)64
cave+74:
dd (float)-1

label(done)
cave+80:
ReassembleEx(hack,_Len)
push  eax
mov   eax,[ebp+0c] // decrease amount
test  eax,eax
jle   done

mov   eax,[cave+70]
cmp   eax,(float)8
jge   @f
mov   eax,(float)8
@@:
cmp   eax,(float)640
jle   @f
mov   eax,(float)640
@@:
mov   [cave+70],eax

fld   dword ptr [ebp+0c]
fdiv  dword ptr [cave+70]
fstp  dword ptr [ebp+0c]

done:
pop   eax
jmp   hack+_Len

hack:
jmp   cave+80

[DISABLE]


[cave+08]:
readmem(cave+20,24)


unregistersymbol(indc)
dealloc(indc)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>320</ID>
              <Description>"div"</Description>
              <VariableType>Float</VariableType>
              <Address>indc+70</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>323</ID>
              <Description>"pseudo time scale"</Description>
              <Options moHideChildren="1"/>
              <LastState Activated="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>define(cave,xupd)
define(hack,cnupd)

[ENABLE]

Eval(cnupd,$MONO'Planetbase.Construction::updateAll')//2
Eval(chupd,$MONO'Planetbase.Character::updateAll')//2
//Eval(shupd,$MONO'Planetbase.Ship::updateAll')
Eval(rsupd,$MONO'Planetbase.Resource::updateAll')//2
Eval(inupd,$MONO'Planetbase.Interaction::updateAll')//1

alloc(xupd,$1000,hack)
registersymbol(xupd)

assert(hack,55)

cave:
dq cave,hack,chupd,rsupd,inupd

cave+040:
readmem(hack,24)
cave+060:
readmem(chupd,24)
cave+080:
readmem(rsupd,24)
cave+0a0:
readmem(inupd,24)


cave+0f0:
dd 8

label(loop1)
label(loop2)
label(loop3)
label(loop4)

//=======================================
cave+100:
pop   dword ptr [cave+0e0]
cmp   dword ptr [cave+0f0],8
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],7
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],6
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],5
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],4
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],3
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],2
jl    @f
call  loop1
@@:
cmp   dword ptr [cave+0f0],1
jl    @f
call  loop1
@@:
push  dword ptr [cave+0e0]
loop1:
ReassembleEx(hack,_Len1)
jmp   hack+_Len1
//=======================================


//=======================================
cave+200:
pop   dword ptr [cave+0e4]
cmp   dword ptr [cave+0f0],8
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],7
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],6
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],5
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],4
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],3
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],2
jl    @f
call  loop2
@@:
cmp   dword ptr [cave+0f0],1
jl    @f
call  loop2
@@:
push  dword ptr [cave+0e4]
loop2:
ReassembleEx(chupd,_Len2)
jmp   chupd+_Len2
//=======================================


//=======================================
cave+300:
pop   dword ptr [cave+0e8]
cmp   dword ptr [cave+0f0],8
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],7
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],6
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],5
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],4
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],3
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],2
jl    @f
call  loop3
@@:
cmp   dword ptr [cave+0f0],1
jl    @f
call  loop3
@@:
push  dword ptr [cave+0e8]
loop3:
ReassembleEx(rsupd,_Len3)
jmp   rsupd+_Len3
//=======================================

//=======================================
cave+400:
pop   dword ptr [cave+0ec]
cmp   dword ptr [cave+0f0],8
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],7
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],6
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],5
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],4
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],3
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],2
jl    @f
call  loop4
@@:
cmp   dword ptr [cave+0f0],1
jl    @f
call  loop4
@@:
push  dword ptr [cave+0ec]
loop4:
ReassembleEx(inupd,_Len4)
jmp   inupd+_Len4
//=======================================



hack:
jmp   cave+100

chupd:
jmp   cave+200

rsupd:
jmp   cave+300

inupd:
jmp   cave+400

[DISABLE]


[cave+08]:
readmem(cave+040,24)
[cave+10]:
readmem(cave+060,24)
[cave+18]:
readmem(cave+080,24)
[cave+20]:
readmem(cave+0a0,24)


unregistersymbol(xupd)
dealloc(xupd)

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>324</ID>
                  <Description>"mul"</Description>
                  <VariableType>4 Bytes</VariableType>
                  <Address>xupd+0f0</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>328</ID>
          <Description>"place module every where (risky?)"</Description>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>define(cave,place)
define(hack,module)

[ENABLE]

//Eval(oxy,$MONO'Planetbase.Module::canPlaceComponent')
Eval(module,$MONO'Planetbase.Module::canPlaceModule')

alloc(place,$200,hack)
registersymbol(place)

assert(hack,55)

cave:
dq cave,hack

cave+20:
readmem(hack,24)

cave+70:
dd (float)8

cave+80:
xor eax,eax
inc eax
ret
ReassembleEx(hack,_Len)
fld   dword ptr [ebp+24]// size
fdiv  dword ptr [cave+70]
fstp  dword ptr [ebp+24]

jmp   hack+_Len
{
pop   dword ptr [cave+7c]
push  @f
ReassembleEx(hack,_Len)
jmp   hack+_Len
@@:
push  dword ptr [cave+7c]

test  eax,eax
jge   @f
neg   eax
@@:
shl   eax,3

ret
}

hack:
jmp   cave+80

[DISABLE]


[cave+08]:
readmem(cave+20,24)


unregistersymbol(place)
dealloc(place)

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>327</ID>
          <Description>"oxygen generation x8"</Description>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>define(cave,ogen)
define(hack,oxy)

[ENABLE]

Eval(oxy,$MONO'Planetbase.Module::getOxygenGeneration')

alloc(ogen,$200,hack)
registersymbol(ogen)

assert(hack,55)

cave:
dq cave,hack

cave+20:
readmem(hack,24)

cave+80:
pop   dword ptr [cave+7c]
push  @f
ReassembleEx(hack,_Len)
jmp   hack+_Len
@@:
push  dword ptr [cave+7c]

test  eax,eax
jge   @f
neg   eax
@@:
shl   eax,3

ret

hack:
jmp   cave+80

[DISABLE]


[cave+08]:
readmem(cave+20,24)


unregistersymbol(ogen)
dealloc(ogen)

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>325</ID>
          <Description>"power/water generation"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>define(cave,pgen)
define(hack,gen)

[ENABLE]

Eval(gen,$MONO'Planetbase.Grid::getGeneration')

alloc(pgen,$200,hack)
registersymbol(pgen)

assert(hack,55)

cave:
dq cave,hack

cave+20:
readmem(hack,24)


label(done)
cave+80:
pop   dword ptr [cave+7c]
push  @f
ReassembleEx(hack,_Len)
jmp   hack+_Len
@@:
push  dword ptr [cave+7c]

push  eax

mov   eax,[cave+70]
cmp   eax,(float)0.99
jg    @f
mov   eax,(float)8
@@:
cmp   eax,(float)32
jle   @f
mov   eax,(float)32
@@:
mov   [cave+70],eax

fst   dword ptr [cave+78]
mov   eax,[cave+78]
test  eax,eax
jg    @f

fdiv  dword ptr [cave+70]
jmp   done

@@:
fmul  dword ptr [cave+70]
done:
pop   eax
ret

hack:
jmp   cave+80

[DISABLE]


[cave+08]:
readmem(cave+20,24)


unregistersymbol(pgen)
dealloc(pgen)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>326</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>pgen+70</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>321</ID>
          <Description>"commision trading rate"</Description>
          <Options moHideChildren="1"/>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>define(cave,commrate)
define(hack,comup)

[ENABLE]

Eval(comup,$MONO'Planetbase.GuiMerchantWindow::updateUi')
Eval(mcomm,$MONO'Planetbase.MerchantShip:=mCommission')
Eval(mship,$MONO'Planetbase.GuiMerchantWindow:=mMerchantShip')

alloc(commrate,$200,hack)
registersymbol(commrate)

assert(hack,55)

cave:
dq cave,hack

cave+20:
readmem(hack,24)

cave+70:
dd #-98

cave+80:
ReassembleEx(hack,_Len)
push  edi
mov   edi,[ebp+08]
mov   edi,[edi+mship]
cmp   edi,10000
jle   @f
mov   eax,[cave+70]
mov   [edi+mcomm],eax
@@:
pop   edi
jmp   hack+_Len


hack:
jmp   cave+80

[DISABLE]

[cave+08]:
readmem(cave+20,24)


unregistersymbol(commrate)
dealloc(commrate)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>322</ID>
              <Description>"-95=&gt; 1:20, -50=&gt;1:2, +50=&gt;3:2"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>commrate+70</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>262</ID>
      <Description>"64bit &gt;(empty)"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <Color>000000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
assert(__+08,8)
[DISABLE]

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>263</ID>
          <Description>"rapid"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]


Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(pwf,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','ProcessWeaponFire')) // static 3: 1-2-1
Eval(ammo,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','set_HasLimitedAmmo'))
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

//Eval(rott,$GetMonoMethAddr('BBI.Game.Simulation.WeaponFireOperation','SetCurrentTarget')) // static 0

//Eval(rott,$GetMonoMethAddr('BBI.Game.Simulation.HarvesterProcessor','GetHarvesterCountOnTargetNode')) // static 0
//Eval(rot2,$GetMonoMethAddr('BBI.Game.Simulation.WeaponsProcessor','DeactivateWeaponsForUnit')) // static 0

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.CommanderID','ID'))
//Eval(saet,$GetMonoMethAddr('BBI.Game.Simulation.WeaponsProcessor','ShowAttackingEntityToTarget'))

assert(pwf,55)
alloc(wfo,$400,pwf)
registersymbol(wfo)

wfo:
dq wfo,pwf//,cid,plyr

label(done)
wfo+20:
readmem(pwf,24)

//wfo+60:
//dq rott,rot2


wfo+80:
push  rbp
mov   rbp,rsp
//pushad
push  rcx   // -08
push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

mov   rdi,rcx
//movsxd  rcx,dword ptr[rbp+38]


mov   rcx,wfo+10
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,wfo+18

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

mov   eax,[wfo+10]
cmp   eax,[wfo+18]
jne   short done




mov   eax,[wfo+50] // rapid factor
cmp   eax,(float)0.1
jg    short @f
mov   eax,(float)8
@@:
cmp   eax,(float)16
jle   short @f
mov   eax,(float)16
@@:
mov   [wfo+50],eax


// mul deltatime
mov   rax,[rbp+38] // deltatime
mov   [wfo+48],rax
fild  qword ptr [rbp+38] // deltatime
fmul  dword ptr [wfo+50]
fistp qword ptr [rbp+38]

// set use no ammo
mov   rcx,rdi  // wfo item
xor   rax,rax  // false
sub   rsp,8
push  rax
sub   rsp,20
mov   r11,ammo
call  r11d
add   rsp,30


done:
//popad
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
pop  rdx
pop  rcx


pop   rbp

ReassembleEx(pwf,_Len,,wfo)
jmp   pwf+_Len


pwf:
jmp   wfo+80

[DISABLE]
[wfo+08]:
readmem(wfo+20,24)
unregistersymbol(wfo)
dealloc(wfo)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>264</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>wfo+50</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>265</ID>
          <Description>"speed move"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
MVPA0 = GetMonoMethAddr('BBI.Game.Simulation.ManeuveringProcessor','TickManeuvering')
MVPA1 = MVPA0+0x150

--print(MVPA0,MVPA1,MVPA2)
{$asm}


Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

//Eval(mvs,$GetMonoMethAddr('BBI.Game.Simulation.Maneuvering','TickManeuver')) // static 1 : 2
//Eval(mvd,$GetMonoMethAddr('BBI.Game.Simulation.Maneuvering','TickDeathManeuver')) // static 1 : 2

Eval(mvp,$GetMonoMethAddr('BBI.Game.Simulation.ManeuveringProcessor','TickManeuvering')) // static 1 : 2

//AOBScanRegion(aob1,$MVPA0,$MVPA1, b8 ?? ?? ?? ?? 8b 08)
//                               00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17
//                                              00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17
//                                                             00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17
AOBScanRegion(aob,$MVPA0,$MVPA1, e9 ?? ?? 00 00 b8 ?? ?? ?? ?? 48 8b 00 48 ?? ?? ?? 48 83 ec 08 48 8b ce)

alloc(spd,$400,aob)
registersymbol(spd)

spd:
dq spd,aob // +0 , +8
spd+40:
readmem(aob+5,24)

spd+60:
dq 0,0
spd+70:
dq 0

label(nomod)
label(done)
label(finish)
spd+80:

//push  rbp
//mov   rbp,rsp
//pushad
push  rcx   // -08
push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

{
mov   rax,spd
mov   eax,[rax+41]
mov   [spd+70],eax
mov   [spd+5c],eax
}

xor   eax,eax
dec   eax
mov   [spd+60],eax
mov   [spd+68],eax

mov   rdi,rcx
//movsxd  rcx,dword ptr[rbp+38]


mov   rcx,spd+60
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,spd+68

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

mov   eax,[spd+60]
cmp   eax,[spd+68]
je    short @f
xor   rax,rax
jmp   finish
@@:


mov   eax,[spd+78]
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)4
@@:
cmp   eax,(float)8
jle   @f
mov   eax,(float)8
@@:
mov   [spd+78],eax

mov   rax,spd
mov   eax,[rax+41]


//mov   [spd+70],rax


fild  qword ptr[rax]
fmul  dword ptr[spd+78]
fistp qword ptr[spd+70]


mov   rax,spd+70

finish:
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
pop  rdx
pop  rcx

//pop  rbp

test rax,rax
jne  done
nomod:
reassemble(aob+05)
done:
reassemble(aob+0a)
reassemble(aob+0d)
reassemble(aob+11)
jmp   aob+15

//aob1:
//call   spd+80
//nop
//nop
aob+05:
jmp   spd+80


[DISABLE]

[spd+08]+05://-&gt; aob
readmem(spd+40,24)
unregistersymbol(spd)
dealloc(spd)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>266</ID>
              <Description>"mul"</Description>
              <VariableType>Float</VariableType>
              <Address>spd+78</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>267</ID>
          <Description>"unit production resource free"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
RES1 = GetMonoMethAddr('BBI.Game.Simulation.AbilityProductionResourceCostsMetValidator','GetProduceUnitResourceCost')
RES2 = RES1 + 0x70
if bDebug then print(RES1,RES2) end
{$asm}

[ENABLE]

//Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

AOBScanRegion(cost,$RES1,$RES2, 0f 85 ?? ?? 00 00)

cost:
db 90 e9

// 83 c4 10 85 c0 0f
{
alloc(res,$200,cost)
registersymbol(res)

res:
dq res,cost

res+20:
readmem(cost,24)



label(done)
label(nomod)
res+40:
ReassembleEx(cost,_Len,,res)
jne   nomod                 // no resource string case, will give free resource
pushad                      // but we need to check if player
sub   esp,8
lea   edi,[esp]

sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[ebp+0c]
mov   [res+30],eax
add   esp,8
cmp   eax,[edi]
jne   done
xor   eax,eax
inc   eax
test  eax,eax   // should be jne
popad
jmp   cost+_Len
//
done:
popad
test  eax,eax
nomod:
jmp   cost+_Len




cost:
jmp   res+40
}
[DISABLE]
{
[res+08]:
readmem(res+20,24)
unregistersymbol(res)
dealloc(res)

}

AOBScanRegion(cost,$RES1,$RES2, 90 e9 ?? ?? 00 00)

cost:
db 0f 85

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>268</ID>
          <Description>"unit production instance"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
RTIME1 = GetMonoMethAddr('BBI.Game.Simulation.AbilityHelper','GetAbilityProductionTime')
RTIME2 = RTIME1 + 0x30
if bDebug then print(RTIME1,RTIME2) end
{$asm}
[ENABLE]

//Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0

AOBScanRegion(rtm,$RTIME1,$RTIME2,0f 84 ?? ?? 00 00)


rtm:
db 90 e9

{
alloc(rtime,$200,rtm)
registersymbol(rtime)

rtime:
dq rtime,rtm//cost

rtime+20:
readmem(rtm,16)



label(done)
label(nomod)
rtime+40:
ReassembleEx(rtm,_Len,,rtime)  //
je    nomod
pushad                      // but we need to check if player
sub   esp,8
lea   edi,[esp]

sub   esp,0c
push  edi
call  plyr
add   esp,0c

mov   eax,[ebp+10]
mov   [rtime+30],eax
add   esp,8
cmp   eax,[edi]
jne   done
//                          // should be je
popad
jmp   nomod
//
done:
popad
test  esi,esi
nomod:
jmp   rtm+_Len




rtm:
jmp   rtime+40
}


[DISABLE]



{
[rtime+08]:
readmem(rtime+20,16)
unregistersymbol(rtime)
dealloc(rtime)
}


AOBScanRegion(rtm,$RTIME1,$RTIME2,90 e9 ?? ?? 00 00)


rtm:
db 0f 84

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>269</ID>
          <Description>"PopCap adder"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
{$asm}

Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(popc,$GetMonoMethAddr('BBI.Game.Simulation.Commander','get_PopCap'))

Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

alloc(popcap,$100,popc)
registersymbol(popcap)

popcap:
dq popcap,popc

popcap+20:
readmem(popc,24)

popcap+30:
dd #30      // INITIAL popcap add amount
dd #300     // Max popcap add amount allowed

popcap+40:

pop   dword ptr [popcap+38]
push  @f
ReassembleEx(popc,_Len,,popcap)  //
jmp   popc+_Len
@@:
push  dword ptr [popcap+38]

push  rax

mov   eax,[popcap+30]
test  eax,eax
jge    @f
mov   eax,#30
@@:
cmp   eax,[popcap+34]
jle   @f
mov   eax,[popcap+34]
@@:
mov   [popcap+30],eax

pop   rax
{
push  ebp
mov   ebp,esp
push  edi
push  eax

mov   eax,[popcap+30]
test  eax,eax
jge    @f
mov   eax,#30
@@:
cmp   eax,#300
jle   @f
mov   eax,#300
@@:
mov   [popcap+30],eax

mov   eax,popcap+18

sub   esp,0c
push  eax
call  plyr
add   esp,0c

mov   edi,[ebp+08]

mov   eax,[edi+cmdID]
cmp   eax,[popcap+18]  // local player commander ?
jne   @f
mov   [popcap+10],edi
@@:
cmp   eax,[popcap+18]  // local player commander ?
pop   eax
pop   edi
pop   ebp
jne    @f
}
add   eax,[popcap+30]
@@:
ret


popc:
jmp   popcap+40

MR(64/PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[popcap+08]:
readmem(popcap+20,24)
unregistersymbol(popcap)
dealloc(popcap)
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>270</ID>
              <Description>"add amount"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>popcap+30</Address>
              <Hotkeys>
                <Hotkey>
                  <Action>Set Value</Action>
                  <Keys>
                    <Key>191</Key>
                  </Keys>
                  <Value>100</Value>
                  <ID>0</ID>
                </Hotkey>
                <Hotkey>
                  <Action>Set Value</Action>
                  <Keys>
                    <Key>220</Key>
                  </Keys>
                  <Value>0</Value>
                  <ID>1</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>271</ID>
              <Description>"Commander Pointer"</Description>
              <Options moHideChildren="1"/>
              <LastState RealAddress="00000000"/>
              <VariableType>String</VariableType>
              <Length>0</Length>
              <Unicode>0</Unicode>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>popcap+10</Address>
              <Offsets>
                <Offset>0</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>272</ID>
                  <Description>"Name"</Description>
                  <VariableType>String</VariableType>
                  <Length>255</Length>
                  <Unicode>1</Unicode>
                  <ZeroTerminate>1</ZeroTerminate>
                  <Address>+020</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>273</ID>
          <Description>"slow heating (high divisor for virtuallly no heating)"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--print(string.format("%X",GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedHeat') or -1))
{$asm}

Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(inch,$GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedHeat')) // static 3

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
//Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

alloc(heat,$200,inch)
registersymbol(heat)
heat:
dq heat,inch

heat+20:
readmem(inch,24)


label(done)
heat+40:
push  rbp
mov   rbp,rsp
//pushad
push  rcx   // -08
//push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

mov   rdi,rcx
mov   rbx,rdx
//movsxd  rcx,dword ptr[rbp+38]

push  rdx

mov   rcx,heat+10
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,heat+18

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

pop   rdx

mov   eax,[heat+10]
cmp   eax,[heat+18]
jne   short done


mov   eax,[heat+38]
cmp   eax,(float)0.1
jg    @f
mov   eax,(float)4
@@:
cmp   eax,(float)1000
jle   @f
mov   eax,(float)1000
@@:
mov   [heat+38],eax


lea   rdi,[rbp+38]

mov   eax,[rdi]
cmp   eax,[heat+3c]
jle   @f
mov   [heat+3c],eax
@@:
mov   eax,[rdi]
test  eax,eax
jle   @f

push  rbx
fild  dword ptr [rsp]
fdiv  dword ptr [heat+38]
fistp dword ptr [rsp]
pop   rdx
@@:

done:
//popad
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
//pop  rdx
pop  rcx


pop   rbp

ReassembleEX(inch,_Len,,heat)
jmp   inch+_Len


inch:
jmp   heat+40

//MR(PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[heat+08]:
readmem(heat+20,24)
unregistersymbol(heat)
dealloc(heat)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>274</ID>
              <Description>"divisor"</Description>
              <VariableType>Float</VariableType>
              <Address>heat+38</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>275</ID>
              <Description>"last max heat increment (all entity)"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>heat+3c</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>276</ID>
              <Description>"clear last max heat inc"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
heat+3c:
dd 1
[DISABLE]
heat+3c:
dd 0

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>277</ID>
          <Description>"no powerpool decrease (power likely maxout soon, no harm?) "</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--print(string.format("%X",GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','IncreaseCurrentProducedpower') or -1))
{$asm}

Eval(cid,$GetMonoMethAddr('BBI.Game.Simulation.Sim','GetEntityCommanderID')) // static 1
Eval(plyr,$GetMonoMethAddr('BBI.Game.Simulation.SimController','get_LocalPlayerCommanderID')) // static 0
Eval(decp,$GetMonoMethAddr('BBI.Game.Simulation.PowerShuntProcessor','DecreaseCurrentReservePower')) // static 3

//Eval(cmdID,$GetMonoOffset('BBI.Game.Simulation.Commander','ID'))
//Eval(mName,$GetMonoOffset('BBI.Game.Simulation.Commander','mName'))

alloc(power,$200,decp)
registersymbol(power)

power:
dq power,decp

power+20:
readmem(decp,24)


label(done)
power+40:
push  rbp
mov   rbp,rsp
//pushad
push  rcx   // -08
//push  rdx   // -10
push  r8    // -18
push  r9    // -20
push  rdi
push  rsi
push  rbx

mov   rdi,rcx
mov   rbx,rdx
//movsxd  rcx,dword ptr[rbp+38]

push  rdx

mov   rcx,power+10
sub   rsp,20
mov   r11,plyr
call  r11d
add   rsp,20

mov   rsi,[rbp+30]  // entity
mov   rcx,power+18

sub   rsp,10
mov   [rsp],esi
//push  rdi    // [ebp+08] // attacking entity
sub   rsp,20
mov   r11,cid
call  r11d
add   rsp,30

pop   rdx

mov   eax,[power+10]
cmp   eax,[power+18]
jne   short done

xor   rdx,rdx

done:
pop  rbx
pop  rsi
pop  rdi
pop  r9
pop  r8
//pop  rdx
pop  rcx


pop   rbp

ReassembleEX(decp,_Len,,power)
jmp   decp+_Len


decp:
jmp   power+40

//MR(PopCap/Commander/Name,Address=+mName,Type=vtString)

[DISABLE]

[power+08]:
readmem(power+20,24)

unregistersymbol(power)
dealloc(power)
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
  <LuaScript>--print(GetMonoOffset('PlanetBase.GuiMerchantWindow','mMerchantShip' ))



--print(Stat.Klass['PlanetBase.GuiMerchantWindow'].cc)

for k in pairs(Stat.Klass) do
  if k:match('Merchant') then
    print('&lt;'..k..'&gt;')
  end
end

local fs = mono_class_enumFields(Stat.Klass['Planetbase.GuiMerchantWindow'].cc)
print(#fs)
</LuaScript>
</CheatTable>
